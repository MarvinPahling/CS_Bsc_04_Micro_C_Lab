   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "main.c"
  18              		.section	.text.byte_fifo_put_possible,"ax",%progbits
  19              		.align	2
  20              		.syntax unified
  21              		.arm
  23              	byte_fifo_put_possible:
  24              	.LFB5:
  25              		.file 2 "trace32/../lib/byte_fifo.h"
   1:trace32/../lib/byte_fifo.h **** /* Byte FIFO queue implementation.
   2:trace32/../lib/byte_fifo.h ****  *
   3:trace32/../lib/byte_fifo.h ****  * Implements a simple reader/write save byte FIFO on top of a data buffer, that lets
   4:trace32/../lib/byte_fifo.h ****  * you enqueue and dequeue single bytes.
   5:trace32/../lib/byte_fifo.h ****  */
   6:trace32/../lib/byte_fifo.h **** 
   7:trace32/../lib/byte_fifo.h **** #ifndef __BYTE_FIFO_H__
   8:trace32/../lib/byte_fifo.h **** #define __BYTE_FIFO_H__
   9:trace32/../lib/byte_fifo.h **** 
  10:trace32/../lib/byte_fifo.h **** 
  11:trace32/../lib/byte_fifo.h **** typedef struct
  12:trace32/../lib/byte_fifo.h **** {
  13:trace32/../lib/byte_fifo.h **** 	unsigned short rd;
  14:trace32/../lib/byte_fifo.h **** 	unsigned short wr;
  15:trace32/../lib/byte_fifo.h ****     unsigned short mask;
  16:trace32/../lib/byte_fifo.h **** 	unsigned char  buf[];
  17:trace32/../lib/byte_fifo.h **** } byte_fifo_t;
  18:trace32/../lib/byte_fifo.h **** 
  19:trace32/../lib/byte_fifo.h **** #define TEST_2erPOTENZ(x) (((x) & ((x) - 1))?0:(x))
  20:trace32/../lib/byte_fifo.h **** #define TEST_64k(x)       ((x)>0x10000?0:(x))
  21:trace32/../lib/byte_fifo.h **** #define TEST_SIZE(x)      (TEST_64k(TEST_2erPOTENZ(x)))
  22:trace32/../lib/byte_fifo.h **** 
  23:trace32/../lib/byte_fifo.h **** //size muss einer 2er Potenzzahl sein, andernfalls gibt der Compiler
  24:trace32/../lib/byte_fifo.h **** //die Fehlermeldung aus, dass die Array-Größe (hier -1) ungültit ist
  25:trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_INIT(size)  (byte_fifo_t) {.rd=0,\
  26:trace32/../lib/byte_fifo.h ****                                              .wr=0,\
  27:trace32/../lib/byte_fifo.h **** 						        	         .mask=TEST_SIZE(size)-1,\
  28:trace32/../lib/byte_fifo.h **** 								    		 .buf={[TEST_SIZE(size)-1]=0}\
  29:trace32/../lib/byte_fifo.h **** 									    	}
  30:trace32/../lib/byte_fifo.h **** 
  31:trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_TYPEOF_RDWR typeof (((byte_fifo_t *)0)->rd)
  32:trace32/../lib/byte_fifo.h **** 
  33:trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic push
  34:trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  35:trace32/../lib/byte_fifo.h **** 
  36:trace32/../lib/byte_fifo.h **** static int byte_fifo_put_possible(byte_fifo_t *fifo)
  37:trace32/../lib/byte_fifo.h **** {
  26              		.loc 2 37 1
  27              		.cfi_startproc
  28              		@ Function supports interworking.
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 04B02DE5 		str	fp, [sp, #-4]!
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 11, -4
  35 0004 00B08DE2 		add	fp, sp, #0
  36              		.cfi_def_cfa_register 11
  37 0008 0CD04DE2 		sub	sp, sp, #12
  38 000c 08000BE5 		str	r0, [fp, #-8]
  38:trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
  39              		.loc 2 38 11
  40 0010 08301BE5 		ldr	r3, [fp, #-8]
  41 0014 B230D3E1 		ldrh	r3, [r3, #2]
  42              		.loc 2 38 15
  43 0018 013083E2 		add	r3, r3, #1
  44              		.loc 2 38 24
  45 001c 08201BE5 		ldr	r2, [fp, #-8]
  46 0020 B420D2E1 		ldrh	r2, [r2, #4]
  47              		.loc 2 38 18
  48 0024 023003E0 		and	r3, r3, r2
  49              		.loc 2 38 40
  50 0028 08201BE5 		ldr	r2, [fp, #-8]
  51 002c B020D2E1 		ldrh	r2, [r2]
  52              		.loc 2 38 4
  53 0030 020053E1 		cmp	r3, r2
  54 0034 0100001A 		bne	.L2
  39:trace32/../lib/byte_fifo.h **** 		return -1;
  55              		.loc 2 39 10
  56 0038 0030E0E3 		mvn	r3, #0
  57 003c 000000EA 		b	.L3
  58              	.L2:
  40:trace32/../lib/byte_fifo.h **** 	
  41:trace32/../lib/byte_fifo.h **** 	return 0;
  59              		.loc 2 41 9
  60 0040 0030A0E3 		mov	r3, #0
  61              	.L3:
  42:trace32/../lib/byte_fifo.h **** }
  62              		.loc 2 42 1
  63 0044 0300A0E1 		mov	r0, r3
  64 0048 00D08BE2 		add	sp, fp, #0
  65              		.cfi_def_cfa_register 13
  66              		@ sp needed
  67 004c 04B09DE4 		ldr	fp, [sp], #4
  68              		.cfi_restore 11
  69              		.cfi_def_cfa_offset 0
  70 0050 1EFF2FE1 		bx	lr
  71              		.cfi_endproc
  72              	.LFE5:
  74              		.section	.text.byte_fifo_remain,"ax",%progbits
  75              		.align	2
  76              		.syntax unified
  77              		.arm
  79              	byte_fifo_remain:
  80              	.LFB6:
  43:trace32/../lib/byte_fifo.h **** 
  44:trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_remain(byte_fifo_t *fifo)
  45:trace32/../lib/byte_fifo.h **** {
  81              		.loc 2 45 1
  82              		.cfi_startproc
  83              		@ Function supports interworking.
  84              		@ args = 0, pretend = 0, frame = 8
  85              		@ frame_needed = 1, uses_anonymous_args = 0
  86              		@ link register save eliminated.
  87 0000 04B02DE5 		str	fp, [sp, #-4]!
  88              		.cfi_def_cfa_offset 4
  89              		.cfi_offset 11, -4
  90 0004 00B08DE2 		add	fp, sp, #0
  91              		.cfi_def_cfa_register 11
  92 0008 0CD04DE2 		sub	sp, sp, #12
  93 000c 08000BE5 		str	r0, [fp, #-8]
  46:trace32/../lib/byte_fifo.h **** 	return fifo->mask - ((fifo->wr-fifo->rd)&fifo->mask);
  94              		.loc 2 46 37
  95 0010 08301BE5 		ldr	r3, [fp, #-8]
  96 0014 B020D3E1 		ldrh	r2, [r3]
  97              		.loc 2 46 28
  98 0018 08301BE5 		ldr	r3, [fp, #-8]
  99 001c B230D3E1 		ldrh	r3, [r3, #2]
 100              		.loc 2 46 20
 101 0020 033042E0 		sub	r3, r2, r3
 102 0024 0338A0E1 		lsl	r3, r3, #16
 103 0028 2338A0E1 		lsr	r3, r3, #16
 104 002c 013043E2 		sub	r3, r3, #1
 105 0030 0338A0E1 		lsl	r3, r3, #16
 106 0034 2338A0E1 		lsr	r3, r3, #16
 107 0038 0338A0E1 		lsl	r3, r3, #16
 108 003c 4328A0E1 		asr	r2, r3, #16
 109              		.loc 2 46 47
 110 0040 08301BE5 		ldr	r3, [fp, #-8]
 111 0044 B430D3E1 		ldrh	r3, [r3, #4]
 112 0048 0338A0E1 		lsl	r3, r3, #16
 113 004c 4338A0E1 		asr	r3, r3, #16
 114              		.loc 2 46 20
 115 0050 023003E0 		and	r3, r3, r2
 116 0054 0338A0E1 		lsl	r3, r3, #16
 117 0058 4338A0E1 		asr	r3, r3, #16
 118 005c 0338A0E1 		lsl	r3, r3, #16
 119 0060 2338A0E1 		lsr	r3, r3, #16
  47:trace32/../lib/byte_fifo.h **** }
 120              		.loc 2 47 1
 121 0064 0300A0E1 		mov	r0, r3
 122 0068 00D08BE2 		add	sp, fp, #0
 123              		.cfi_def_cfa_register 13
 124              		@ sp needed
 125 006c 04B09DE4 		ldr	fp, [sp], #4
 126              		.cfi_restore 11
 127              		.cfi_def_cfa_offset 0
 128 0070 1EFF2FE1 		bx	lr
 129              		.cfi_endproc
 130              	.LFE6:
 132              		.section	.text.byte_fifo_used,"ax",%progbits
 133              		.align	2
 134              		.syntax unified
 135              		.arm
 137              	byte_fifo_used:
 138              	.LFB7:
  48:trace32/../lib/byte_fifo.h **** 	
  49:trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_used(byte_fifo_t *fifo)
  50:trace32/../lib/byte_fifo.h **** {
 139              		.loc 2 50 1
 140              		.cfi_startproc
 141              		@ Function supports interworking.
 142              		@ args = 0, pretend = 0, frame = 8
 143              		@ frame_needed = 1, uses_anonymous_args = 0
 144              		@ link register save eliminated.
 145 0000 04B02DE5 		str	fp, [sp, #-4]!
 146              		.cfi_def_cfa_offset 4
 147              		.cfi_offset 11, -4
 148 0004 00B08DE2 		add	fp, sp, #0
 149              		.cfi_def_cfa_register 11
 150 0008 0CD04DE2 		sub	sp, sp, #12
 151 000c 08000BE5 		str	r0, [fp, #-8]
  51:trace32/../lib/byte_fifo.h **** 	return (fifo->wr-fifo->rd)&fifo->mask;
 152              		.loc 2 51 14
 153 0010 08301BE5 		ldr	r3, [fp, #-8]
 154 0014 B220D3E1 		ldrh	r2, [r3, #2]
 155              		.loc 2 51 23
 156 0018 08301BE5 		ldr	r3, [fp, #-8]
 157 001c B030D3E1 		ldrh	r3, [r3]
 158              		.loc 2 51 18
 159 0020 033042E0 		sub	r3, r2, r3
 160 0024 0338A0E1 		lsl	r3, r3, #16
 161 0028 2338A0E1 		lsr	r3, r3, #16
 162 002c 0338A0E1 		lsl	r3, r3, #16
 163 0030 4328A0E1 		asr	r2, r3, #16
 164              		.loc 2 51 33
 165 0034 08301BE5 		ldr	r3, [fp, #-8]
 166 0038 B430D3E1 		ldrh	r3, [r3, #4]
 167 003c 0338A0E1 		lsl	r3, r3, #16
 168 0040 4338A0E1 		asr	r3, r3, #16
 169              		.loc 2 51 28
 170 0044 023003E0 		and	r3, r3, r2
 171 0048 0338A0E1 		lsl	r3, r3, #16
 172 004c 4338A0E1 		asr	r3, r3, #16
 173 0050 0338A0E1 		lsl	r3, r3, #16
 174 0054 2338A0E1 		lsr	r3, r3, #16
  52:trace32/../lib/byte_fifo.h **** }
 175              		.loc 2 52 1
 176 0058 0300A0E1 		mov	r0, r3
 177 005c 00D08BE2 		add	sp, fp, #0
 178              		.cfi_def_cfa_register 13
 179              		@ sp needed
 180 0060 04B09DE4 		ldr	fp, [sp], #4
 181              		.cfi_restore 11
 182              		.cfi_def_cfa_offset 0
 183 0064 1EFF2FE1 		bx	lr
 184              		.cfi_endproc
 185              	.LFE7:
 187              		.section	.text.byte_fifo_put,"ax",%progbits
 188              		.align	2
 189              		.syntax unified
 190              		.arm
 192              	byte_fifo_put:
 193              	.LFB8:
  53:trace32/../lib/byte_fifo.h **** 	
  54:trace32/../lib/byte_fifo.h **** static int byte_fifo_put(byte_fifo_t *fifo,unsigned char val)
  55:trace32/../lib/byte_fifo.h **** {
 194              		.loc 2 55 1
 195              		.cfi_startproc
 196              		@ Function supports interworking.
 197              		@ args = 0, pretend = 0, frame = 8
 198              		@ frame_needed = 1, uses_anonymous_args = 0
 199              		@ link register save eliminated.
 200 0000 04B02DE5 		str	fp, [sp, #-4]!
 201              		.cfi_def_cfa_offset 4
 202              		.cfi_offset 11, -4
 203 0004 00B08DE2 		add	fp, sp, #0
 204              		.cfi_def_cfa_register 11
 205 0008 0CD04DE2 		sub	sp, sp, #12
 206 000c 08000BE5 		str	r0, [fp, #-8]
 207 0010 0130A0E1 		mov	r3, r1
 208 0014 09304BE5 		strb	r3, [fp, #-9]
  56:trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
 209              		.loc 2 56 11
 210 0018 08301BE5 		ldr	r3, [fp, #-8]
 211 001c B230D3E1 		ldrh	r3, [r3, #2]
 212              		.loc 2 56 15
 213 0020 013083E2 		add	r3, r3, #1
 214              		.loc 2 56 24
 215 0024 08201BE5 		ldr	r2, [fp, #-8]
 216 0028 B420D2E1 		ldrh	r2, [r2, #4]
 217              		.loc 2 56 18
 218 002c 023003E0 		and	r3, r3, r2
 219              		.loc 2 56 40
 220 0030 08201BE5 		ldr	r2, [fp, #-8]
 221 0034 B020D2E1 		ldrh	r2, [r2]
 222              		.loc 2 56 4
 223 0038 020053E1 		cmp	r3, r2
 224 003c 0100001A 		bne	.L9
  57:trace32/../lib/byte_fifo.h **** 		return -1;
 225              		.loc 2 57 10
 226 0040 0030E0E3 		mvn	r3, #0
 227 0044 190000EA 		b	.L10
 228              	.L9:
  58:trace32/../lib/byte_fifo.h **** 	
  59:trace32/../lib/byte_fifo.h **** 	fifo->buf[fifo->wr]=val;
 229              		.loc 2 59 16
 230 0048 08301BE5 		ldr	r3, [fp, #-8]
 231 004c B230D3E1 		ldrh	r3, [r3, #2]
 232 0050 0320A0E1 		mov	r2, r3
 233              		.loc 2 59 21
 234 0054 08301BE5 		ldr	r3, [fp, #-8]
 235 0058 023083E0 		add	r3, r3, r2
 236 005c 09205BE5 		ldrb	r2, [fp, #-9]
 237 0060 0620C3E5 		strb	r2, [r3, #6]
  60:trace32/../lib/byte_fifo.h **** 	fifo->wr=(fifo->wr+1)&(fifo->mask);
 238              		.loc 2 60 16
 239 0064 08301BE5 		ldr	r3, [fp, #-8]
 240 0068 B230D3E1 		ldrh	r3, [r3, #2]
 241              		.loc 2 60 20
 242 006c 013083E2 		add	r3, r3, #1
 243 0070 0338A0E1 		lsl	r3, r3, #16
 244 0074 2338A0E1 		lsr	r3, r3, #16
 245 0078 0338A0E1 		lsl	r3, r3, #16
 246 007c 4328A0E1 		asr	r2, r3, #16
 247              		.loc 2 60 29
 248 0080 08301BE5 		ldr	r3, [fp, #-8]
 249 0084 B430D3E1 		ldrh	r3, [r3, #4]
 250 0088 0338A0E1 		lsl	r3, r3, #16
 251 008c 4338A0E1 		asr	r3, r3, #16
 252              		.loc 2 60 23
 253 0090 023003E0 		and	r3, r3, r2
 254 0094 0338A0E1 		lsl	r3, r3, #16
 255 0098 4338A0E1 		asr	r3, r3, #16
 256 009c 0338A0E1 		lsl	r3, r3, #16
 257 00a0 2328A0E1 		lsr	r2, r3, #16
 258              		.loc 2 60 10
 259 00a4 08301BE5 		ldr	r3, [fp, #-8]
 260 00a8 B220C3E1 		strh	r2, [r3, #2]	@ movhi
  61:trace32/../lib/byte_fifo.h **** 	return 0;
 261              		.loc 2 61 9
 262 00ac 0030A0E3 		mov	r3, #0
 263              	.L10:
  62:trace32/../lib/byte_fifo.h **** }
 264              		.loc 2 62 1
 265 00b0 0300A0E1 		mov	r0, r3
 266 00b4 00D08BE2 		add	sp, fp, #0
 267              		.cfi_def_cfa_register 13
 268              		@ sp needed
 269 00b8 04B09DE4 		ldr	fp, [sp], #4
 270              		.cfi_restore 11
 271              		.cfi_def_cfa_offset 0
 272 00bc 1EFF2FE1 		bx	lr
 273              		.cfi_endproc
 274              	.LFE8:
 276              		.section	.text.byte_fifo_get_possible,"ax",%progbits
 277              		.align	2
 278              		.syntax unified
 279              		.arm
 281              	byte_fifo_get_possible:
 282              	.LFB9:
  63:trace32/../lib/byte_fifo.h **** 
  64:trace32/../lib/byte_fifo.h **** static int byte_fifo_get_possible(byte_fifo_t *fifo)
  65:trace32/../lib/byte_fifo.h **** {
 283              		.loc 2 65 1
 284              		.cfi_startproc
 285              		@ Function supports interworking.
 286              		@ args = 0, pretend = 0, frame = 8
 287              		@ frame_needed = 1, uses_anonymous_args = 0
 288              		@ link register save eliminated.
 289 0000 04B02DE5 		str	fp, [sp, #-4]!
 290              		.cfi_def_cfa_offset 4
 291              		.cfi_offset 11, -4
 292 0004 00B08DE2 		add	fp, sp, #0
 293              		.cfi_def_cfa_register 11
 294 0008 0CD04DE2 		sub	sp, sp, #12
 295 000c 08000BE5 		str	r0, [fp, #-8]
  66:trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 296              		.loc 2 66 9
 297 0010 08301BE5 		ldr	r3, [fp, #-8]
 298 0014 B020D3E1 		ldrh	r2, [r3]
 299              		.loc 2 66 21
 300 0018 08301BE5 		ldr	r3, [fp, #-8]
 301 001c B230D3E1 		ldrh	r3, [r3, #2]
 302              		.loc 2 66 4
 303 0020 030052E1 		cmp	r2, r3
 304 0024 0100001A 		bne	.L12
  67:trace32/../lib/byte_fifo.h **** 		return -1;
 305              		.loc 2 67 10
 306 0028 0030E0E3 		mvn	r3, #0
 307 002c 000000EA 		b	.L13
 308              	.L12:
  68:trace32/../lib/byte_fifo.h **** 		
  69:trace32/../lib/byte_fifo.h **** 	return 0;
 309              		.loc 2 69 9
 310 0030 0030A0E3 		mov	r3, #0
 311              	.L13:
  70:trace32/../lib/byte_fifo.h **** }
 312              		.loc 2 70 1
 313 0034 0300A0E1 		mov	r0, r3
 314 0038 00D08BE2 		add	sp, fp, #0
 315              		.cfi_def_cfa_register 13
 316              		@ sp needed
 317 003c 04B09DE4 		ldr	fp, [sp], #4
 318              		.cfi_restore 11
 319              		.cfi_def_cfa_offset 0
 320 0040 1EFF2FE1 		bx	lr
 321              		.cfi_endproc
 322              	.LFE9:
 324              		.section	.text.byte_fifo_get,"ax",%progbits
 325              		.align	2
 326              		.syntax unified
 327              		.arm
 329              	byte_fifo_get:
 330              	.LFB10:
  71:trace32/../lib/byte_fifo.h **** 
  72:trace32/../lib/byte_fifo.h **** static int byte_fifo_get(byte_fifo_t *fifo,unsigned char *val)
  73:trace32/../lib/byte_fifo.h **** {
 331              		.loc 2 73 1
 332              		.cfi_startproc
 333              		@ Function supports interworking.
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 1, uses_anonymous_args = 0
 336              		@ link register save eliminated.
 337 0000 04B02DE5 		str	fp, [sp, #-4]!
 338              		.cfi_def_cfa_offset 4
 339              		.cfi_offset 11, -4
 340 0004 00B08DE2 		add	fp, sp, #0
 341              		.cfi_def_cfa_register 11
 342 0008 0CD04DE2 		sub	sp, sp, #12
 343 000c 08000BE5 		str	r0, [fp, #-8]
 344 0010 0C100BE5 		str	r1, [fp, #-12]
  74:trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 345              		.loc 2 74 9
 346 0014 08301BE5 		ldr	r3, [fp, #-8]
 347 0018 B020D3E1 		ldrh	r2, [r3]
 348              		.loc 2 74 21
 349 001c 08301BE5 		ldr	r3, [fp, #-8]
 350 0020 B230D3E1 		ldrh	r3, [r3, #2]
 351              		.loc 2 74 4
 352 0024 030052E1 		cmp	r2, r3
 353 0028 0100001A 		bne	.L15
  75:trace32/../lib/byte_fifo.h **** 		return -1;
 354              		.loc 2 75 10
 355 002c 0030E0E3 		mvn	r3, #0
 356 0030 1A0000EA 		b	.L16
 357              	.L15:
  76:trace32/../lib/byte_fifo.h **** 		
  77:trace32/../lib/byte_fifo.h **** 	*val=fifo->buf[fifo->rd];
 358              		.loc 2 77 21
 359 0034 08301BE5 		ldr	r3, [fp, #-8]
 360 0038 B030D3E1 		ldrh	r3, [r3]
 361 003c 0320A0E1 		mov	r2, r3
 362              		.loc 2 77 16
 363 0040 08301BE5 		ldr	r3, [fp, #-8]
 364 0044 023083E0 		add	r3, r3, r2
 365 0048 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 366              		.loc 2 77 6
 367 004c 0C301BE5 		ldr	r3, [fp, #-12]
 368 0050 0020C3E5 		strb	r2, [r3]
  78:trace32/../lib/byte_fifo.h **** 	fifo->rd=(fifo->rd+1)&(fifo->mask);
 369              		.loc 2 78 16
 370 0054 08301BE5 		ldr	r3, [fp, #-8]
 371 0058 B030D3E1 		ldrh	r3, [r3]
 372              		.loc 2 78 20
 373 005c 013083E2 		add	r3, r3, #1
 374 0060 0338A0E1 		lsl	r3, r3, #16
 375 0064 2338A0E1 		lsr	r3, r3, #16
 376 0068 0338A0E1 		lsl	r3, r3, #16
 377 006c 4328A0E1 		asr	r2, r3, #16
 378              		.loc 2 78 29
 379 0070 08301BE5 		ldr	r3, [fp, #-8]
 380 0074 B430D3E1 		ldrh	r3, [r3, #4]
 381 0078 0338A0E1 		lsl	r3, r3, #16
 382 007c 4338A0E1 		asr	r3, r3, #16
 383              		.loc 2 78 23
 384 0080 023003E0 		and	r3, r3, r2
 385 0084 0338A0E1 		lsl	r3, r3, #16
 386 0088 4338A0E1 		asr	r3, r3, #16
 387 008c 0338A0E1 		lsl	r3, r3, #16
 388 0090 2328A0E1 		lsr	r2, r3, #16
 389              		.loc 2 78 10
 390 0094 08301BE5 		ldr	r3, [fp, #-8]
 391 0098 B020C3E1 		strh	r2, [r3]	@ movhi
  79:trace32/../lib/byte_fifo.h **** 	return 0;
 392              		.loc 2 79 9
 393 009c 0030A0E3 		mov	r3, #0
 394              	.L16:
  80:trace32/../lib/byte_fifo.h **** }
 395              		.loc 2 80 1
 396 00a0 0300A0E1 		mov	r0, r3
 397 00a4 00D08BE2 		add	sp, fp, #0
 398              		.cfi_def_cfa_register 13
 399              		@ sp needed
 400 00a8 04B09DE4 		ldr	fp, [sp], #4
 401              		.cfi_restore 11
 402              		.cfi_def_cfa_offset 0
 403 00ac 1EFF2FE1 		bx	lr
 404              		.cfi_endproc
 405              	.LFE10:
 407              		.section	.text.byte_fifo_cb_put_possible,"ax",%progbits
 408              		.align	2
 409              		.syntax unified
 410              		.arm
 412              	byte_fifo_cb_put_possible:
 413              	.LFB11:
 414              		.file 3 "trace32/../lib/byte_fifo_cb.h"
   1:trace32/../lib/byte_fifo_cb.h **** /* Byte FIFO with CallBack
   2:trace32/../lib/byte_fifo_cb.h ****  *
   3:trace32/../lib/byte_fifo_cb.h ****  * Appends the Byte_Fifo with a callback function, which is called
   4:trace32/../lib/byte_fifo_cb.h ****  * when putting some stuff into the fifo (e.g. Enable transmitting interrupt)
   5:trace32/../lib/byte_fifo_cb.h ****  */
   6:trace32/../lib/byte_fifo_cb.h **** 
   7:trace32/../lib/byte_fifo_cb.h **** #ifndef __BYTE_FIFO_CB_H__
   8:trace32/../lib/byte_fifo_cb.h **** #define __BYTE_FIFO_CB_H__
   9:trace32/../lib/byte_fifo_cb.h **** 
  10:trace32/../lib/byte_fifo_cb.h **** #include "byte_fifo.h"
  11:trace32/../lib/byte_fifo_cb.h **** 
  12:trace32/../lib/byte_fifo_cb.h **** typedef void (*byte_fifo_cb)(void);
  13:trace32/../lib/byte_fifo_cb.h **** 
  14:trace32/../lib/byte_fifo_cb.h **** typedef struct {
  15:trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_cb cb;
  16:trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_t  byte_fifo; //Aufgrund des Flexible Array Member hier hinter keine weiteren Strukturel
  17:trace32/../lib/byte_fifo_cb.h **** } byte_fifo_cb_t;
  18:trace32/../lib/byte_fifo_cb.h **** 
  19:trace32/../lib/byte_fifo_cb.h **** #define BYTE_FIFO_CB_INIT(size,func)  (byte_fifo_cb_t) {.cb=func, \
  20:trace32/../lib/byte_fifo_cb.h ****                                                         .byte_fifo=BYTE_FIFO_INIT(size) \
  21:trace32/../lib/byte_fifo_cb.h **** 									    			   }
  22:trace32/../lib/byte_fifo_cb.h **** 
  23:trace32/../lib/byte_fifo_cb.h **** size_t byte_fifo_cb_putsize(byte_fifo_cb_t *fifo,const unsigned char *start,size_t len);
  24:trace32/../lib/byte_fifo_cb.h **** 
  25:trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic push
  26:trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  27:trace32/../lib/byte_fifo_cb.h **** 
  28:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put_possible(byte_fifo_cb_t *fifo)
  29:trace32/../lib/byte_fifo_cb.h **** {
 415              		.loc 3 29 1
 416              		.cfi_startproc
 417              		@ Function supports interworking.
 418              		@ args = 0, pretend = 0, frame = 8
 419              		@ frame_needed = 1, uses_anonymous_args = 0
 420 0000 00482DE9 		push	{fp, lr}
 421              		.cfi_def_cfa_offset 8
 422              		.cfi_offset 11, -8
 423              		.cfi_offset 14, -4
 424 0004 04B08DE2 		add	fp, sp, #4
 425              		.cfi_def_cfa 11, 4
 426 0008 08D04DE2 		sub	sp, sp, #8
 427 000c 08000BE5 		str	r0, [fp, #-8]
  30:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_put_possible(&fifo->byte_fifo);
 428              		.loc 3 30 9
 429 0010 08301BE5 		ldr	r3, [fp, #-8]
 430 0014 043083E2 		add	r3, r3, #4
 431 0018 0300A0E1 		mov	r0, r3
 432 001c 18309FE5 		ldr	r3, .L19
 433 0020 0FE0A0E1 		mov	lr, pc
 434 0024 13FF2FE1 		bx	r3
 435              	.LVL0:
 436 0028 0030A0E1 		mov	r3, r0
  31:trace32/../lib/byte_fifo_cb.h **** }
 437              		.loc 3 31 1
 438 002c 0300A0E1 		mov	r0, r3
 439 0030 04D04BE2 		sub	sp, fp, #4
 440              		.cfi_def_cfa 13, 8
 441              		@ sp needed
 442 0034 0048BDE8 		pop	{fp, lr}
 443              		.cfi_restore 14
 444              		.cfi_restore 11
 445              		.cfi_def_cfa_offset 0
 446 0038 1EFF2FE1 		bx	lr
 447              	.L20:
 448              		.align	2
 449              	.L19:
 450 003c 00000000 		.word	byte_fifo_put_possible
 451              		.cfi_endproc
 452              	.LFE11:
 454              		.section	.text.byte_fifo_cb_put,"ax",%progbits
 455              		.align	2
 456              		.syntax unified
 457              		.arm
 459              	byte_fifo_cb_put:
 460              	.LFB12:
  32:trace32/../lib/byte_fifo_cb.h **** 	
  33:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put(byte_fifo_cb_t *fifo,unsigned char val)
  34:trace32/../lib/byte_fifo_cb.h **** {
 461              		.loc 3 34 1
 462              		.cfi_startproc
 463              		@ Function supports interworking.
 464              		@ args = 0, pretend = 0, frame = 16
 465              		@ frame_needed = 1, uses_anonymous_args = 0
 466 0000 00482DE9 		push	{fp, lr}
 467              		.cfi_def_cfa_offset 8
 468              		.cfi_offset 11, -8
 469              		.cfi_offset 14, -4
 470 0004 04B08DE2 		add	fp, sp, #4
 471              		.cfi_def_cfa 11, 4
 472 0008 10D04DE2 		sub	sp, sp, #16
 473 000c 10000BE5 		str	r0, [fp, #-16]
 474 0010 0130A0E1 		mov	r3, r1
 475 0014 11304BE5 		strb	r3, [fp, #-17]
  35:trace32/../lib/byte_fifo_cb.h **** 	int ret=byte_fifo_put(&fifo->byte_fifo,val);
 476              		.loc 3 35 10
 477 0018 10301BE5 		ldr	r3, [fp, #-16]
 478 001c 043083E2 		add	r3, r3, #4
 479 0020 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 480 0024 0210A0E1 		mov	r1, r2
 481 0028 0300A0E1 		mov	r0, r3
 482 002c 48309FE5 		ldr	r3, .L24
 483 0030 0FE0A0E1 		mov	lr, pc
 484 0034 13FF2FE1 		bx	r3
 485              	.LVL1:
 486 0038 08000BE5 		str	r0, [fp, #-8]
  36:trace32/../lib/byte_fifo_cb.h **** 	if( !ret && fifo->cb)
 487              		.loc 3 36 4
 488 003c 08301BE5 		ldr	r3, [fp, #-8]
 489 0040 000053E3 		cmp	r3, #0
 490 0044 0700001A 		bne	.L22
 491              		.loc 3 36 18 discriminator 1
 492 0048 10301BE5 		ldr	r3, [fp, #-16]
 493 004c 003093E5 		ldr	r3, [r3]
 494              		.loc 3 36 11 discriminator 1
 495 0050 000053E3 		cmp	r3, #0
 496 0054 0300000A 		beq	.L22
  37:trace32/../lib/byte_fifo_cb.h **** 		fifo->cb();
 497              		.loc 3 37 7
 498 0058 10301BE5 		ldr	r3, [fp, #-16]
 499 005c 003093E5 		ldr	r3, [r3]
 500              		.loc 3 37 3
 501 0060 0FE0A0E1 		mov	lr, pc
 502 0064 13FF2FE1 		bx	r3
 503              	.LVL2:
 504              	.L22:
  38:trace32/../lib/byte_fifo_cb.h **** 	return ret;
 505              		.loc 3 38 9
 506 0068 08301BE5 		ldr	r3, [fp, #-8]
  39:trace32/../lib/byte_fifo_cb.h **** }
 507              		.loc 3 39 1
 508 006c 0300A0E1 		mov	r0, r3
 509 0070 04D04BE2 		sub	sp, fp, #4
 510              		.cfi_def_cfa 13, 8
 511              		@ sp needed
 512 0074 0048BDE8 		pop	{fp, lr}
 513              		.cfi_restore 14
 514              		.cfi_restore 11
 515              		.cfi_def_cfa_offset 0
 516 0078 1EFF2FE1 		bx	lr
 517              	.L25:
 518              		.align	2
 519              	.L24:
 520 007c 00000000 		.word	byte_fifo_put
 521              		.cfi_endproc
 522              	.LFE12:
 524              		.section	.text.byte_fifo_cb_get_possible,"ax",%progbits
 525              		.align	2
 526              		.syntax unified
 527              		.arm
 529              	byte_fifo_cb_get_possible:
 530              	.LFB13:
  40:trace32/../lib/byte_fifo_cb.h **** 
  41:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get_possible(byte_fifo_cb_t *fifo)
  42:trace32/../lib/byte_fifo_cb.h **** {
 531              		.loc 3 42 1
 532              		.cfi_startproc
 533              		@ Function supports interworking.
 534              		@ args = 0, pretend = 0, frame = 8
 535              		@ frame_needed = 1, uses_anonymous_args = 0
 536 0000 00482DE9 		push	{fp, lr}
 537              		.cfi_def_cfa_offset 8
 538              		.cfi_offset 11, -8
 539              		.cfi_offset 14, -4
 540 0004 04B08DE2 		add	fp, sp, #4
 541              		.cfi_def_cfa 11, 4
 542 0008 08D04DE2 		sub	sp, sp, #8
 543 000c 08000BE5 		str	r0, [fp, #-8]
  43:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get_possible(&fifo->byte_fifo);
 544              		.loc 3 43 9
 545 0010 08301BE5 		ldr	r3, [fp, #-8]
 546 0014 043083E2 		add	r3, r3, #4
 547 0018 0300A0E1 		mov	r0, r3
 548 001c 18309FE5 		ldr	r3, .L28
 549 0020 0FE0A0E1 		mov	lr, pc
 550 0024 13FF2FE1 		bx	r3
 551              	.LVL3:
 552 0028 0030A0E1 		mov	r3, r0
  44:trace32/../lib/byte_fifo_cb.h **** }
 553              		.loc 3 44 1
 554 002c 0300A0E1 		mov	r0, r3
 555 0030 04D04BE2 		sub	sp, fp, #4
 556              		.cfi_def_cfa 13, 8
 557              		@ sp needed
 558 0034 0048BDE8 		pop	{fp, lr}
 559              		.cfi_restore 14
 560              		.cfi_restore 11
 561              		.cfi_def_cfa_offset 0
 562 0038 1EFF2FE1 		bx	lr
 563              	.L29:
 564              		.align	2
 565              	.L28:
 566 003c 00000000 		.word	byte_fifo_get_possible
 567              		.cfi_endproc
 568              	.LFE13:
 570              		.section	.text.byte_fifo_cb_get,"ax",%progbits
 571              		.align	2
 572              		.syntax unified
 573              		.arm
 575              	byte_fifo_cb_get:
 576              	.LFB14:
  45:trace32/../lib/byte_fifo_cb.h **** 
  46:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get(byte_fifo_cb_t *fifo,unsigned char *val)
  47:trace32/../lib/byte_fifo_cb.h **** {
 577              		.loc 3 47 1
 578              		.cfi_startproc
 579              		@ Function supports interworking.
 580              		@ args = 0, pretend = 0, frame = 8
 581              		@ frame_needed = 1, uses_anonymous_args = 0
 582 0000 00482DE9 		push	{fp, lr}
 583              		.cfi_def_cfa_offset 8
 584              		.cfi_offset 11, -8
 585              		.cfi_offset 14, -4
 586 0004 04B08DE2 		add	fp, sp, #4
 587              		.cfi_def_cfa 11, 4
 588 0008 08D04DE2 		sub	sp, sp, #8
 589 000c 08000BE5 		str	r0, [fp, #-8]
 590 0010 0C100BE5 		str	r1, [fp, #-12]
  48:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get(&fifo->byte_fifo,val);
 591              		.loc 3 48 9
 592 0014 08301BE5 		ldr	r3, [fp, #-8]
 593 0018 043083E2 		add	r3, r3, #4
 594 001c 0C101BE5 		ldr	r1, [fp, #-12]
 595 0020 0300A0E1 		mov	r0, r3
 596 0024 18309FE5 		ldr	r3, .L32
 597 0028 0FE0A0E1 		mov	lr, pc
 598 002c 13FF2FE1 		bx	r3
 599              	.LVL4:
 600 0030 0030A0E1 		mov	r3, r0
  49:trace32/../lib/byte_fifo_cb.h **** }
 601              		.loc 3 49 1
 602 0034 0300A0E1 		mov	r0, r3
 603 0038 04D04BE2 		sub	sp, fp, #4
 604              		.cfi_def_cfa 13, 8
 605              		@ sp needed
 606 003c 0048BDE8 		pop	{fp, lr}
 607              		.cfi_restore 14
 608              		.cfi_restore 11
 609              		.cfi_def_cfa_offset 0
 610 0040 1EFF2FE1 		bx	lr
 611              	.L33:
 612              		.align	2
 613              	.L32:
 614 0044 00000000 		.word	byte_fifo_get
 615              		.cfi_endproc
 616              	.LFE14:
 618              		.global	main_data
 619              		.bss
 620              		.align	2
 623              	main_data:
 624 0000 000000   		.space	3
 625              		.section	.text._exit,"ax",%progbits
 626              		.align	2
 627              		.global	_exit
 628              		.syntax unified
 629              		.arm
 631              	_exit:
 632              	.LFB15:
   1:main.c        **** #include <stdint.h>
   2:main.c        **** #include <stdio.h>
   3:main.c        **** #include <string.h>
   4:main.c        **** #include <unistd.h> //fuer _exit() usleep()
   5:main.c        **** 
   6:main.c        **** // Ausführungsumgebung 'automatisch' erkennen
   7:main.c        **** #if defined(MODE_RAM) || defined(MODE_ROM) || defined(MODE_SIM)
   8:main.c        **** #define NXT
   9:main.c        **** #else
  10:main.c        **** #define COMPILER_EXPLORER
  11:main.c        **** #endif
  12:main.c        **** 
  13:main.c        **** #ifdef NXT
  14:main.c        **** #include "AT91SAM7S64.h"
  15:main.c        **** #include "lib/aic.h"
  16:main.c        **** #include "lib/display.h"
  17:main.c        **** #include "lib/nxt_avr.h"
  18:main.c        **** #include "lib/systick.h"
  19:main.c        **** #include "lib/term.h"
  20:main.c        **** #include "main.h"
  21:main.c        **** // #include "lib/adc.h"
  22:main.c        **** #if defined(MODE_RAM) || defined(MODE_SIM)
  23:main.c        **** #include "trace32/udmon3.h"
  24:main.c        **** #endif
  25:main.c        **** 
  26:main.c        **** #define ZYKLUS_MS 4
  27:main.c        **** #define IDLE_MS 2
  28:main.c        **** #define HERZSCHLAG_PORT SENSOR_2 // SENSOR_1...4
  29:main.c        **** #if IDLE_MS >= ZYKLUS_MS
  30:main.c        **** #error "Idle_ms muss kleiner als zyklus_ms sein"
  31:main.c        **** #endif
  32:main.c        **** #endif
  33:main.c        **** #ifdef COMPILER_EXPLORER
  34:main.c        **** uint32_t systick_get_ms(void);
  35:main.c        **** #endif
  36:main.c        **** 
  37:main.c        **** /*****************************************************************************/
  38:main.c        **** /*   Globale Variablen                                                       */
  39:main.c        **** /*****************************************************************************/
  40:main.c        **** #ifdef NXT
  41:main.c        **** struct {
  42:main.c        ****   signed char term_status; // 0->false->Alles Bestens   -1->true->Overflow
  43:main.c        ****   unsigned char term_cnt;
  44:main.c        ****   unsigned char lowbat_cnt;
  45:main.c        **** } main_data = {
  46:main.c        ****     .term_status = 0,
  47:main.c        ****     .term_cnt = 0,
  48:main.c        ****     .lowbat_cnt = 0,
  49:main.c        **** };
  50:main.c        **** #endif
  51:main.c        **** 
  52:main.c        **** /*****************************************************************************/
  53:main.c        **** /*   Hilfsroutinen                                                           */
  54:main.c        **** /*   Standard-C-Library (weitere befinden sich in newlib_syscalls.c)         */
  55:main.c        **** /*****************************************************************************/
  56:main.c        **** // Routine wird von C-Lib aufgerufen (bspw. printf() abort())
  57:main.c        **** #ifdef NXT
  58:main.c        **** void _exit(int status) {
 633              		.loc 1 58 24
 634              		.cfi_startproc
 635              		@ Function supports interworking.
 636              		@ args = 0, pretend = 0, frame = 8
 637              		@ frame_needed = 1, uses_anonymous_args = 0
 638              		@ link register save eliminated.
 639 0000 04B02DE5 		str	fp, [sp, #-4]!
 640              		.cfi_def_cfa_offset 4
 641              		.cfi_offset 11, -4
 642 0004 00B08DE2 		add	fp, sp, #0
 643              		.cfi_def_cfa_register 11
 644 0008 0CD04DE2 		sub	sp, sp, #12
 645 000c 08000BE5 		str	r0, [fp, #-8]
 646              	.L35:
  59:main.c        ****   (void)status;
  60:main.c        ****   // LED-Blinken lassen
  61:main.c        ****   // Breakpoint setzen
  62:main.c        ****   while (1)
 647              		.loc 1 62 9
 648 0010 0000A0E1 		nop
 649 0014 FDFFFFEA 		b	.L35
 650              		.cfi_endproc
 651              	.LFE15:
 653              		.global	trace_buf0
 654              		.bss
 655 0003 00       		.align	2
 658              	trace_buf0:
 659 0004 00000000 		.space	400
 659      00000000 
 659      00000000 
 659      00000000 
 659      00000000 
 660              		.global	trace_buf1
 661              		.align	2
 664              	trace_buf1:
 665 0194 00000000 		.space	400
 665      00000000 
 665      00000000 
 665      00000000 
 665      00000000 
 666              		.section	.text.trace_scope,"ax",%progbits
 667              		.align	2
 668              		.global	trace_scope
 669              		.syntax unified
 670              		.arm
 672              	trace_scope:
 673              	.LFB16:
  63:main.c        ****     ;
  64:main.c        **** }
  65:main.c        **** #endif
  66:main.c        **** /************************************************************************/
  67:main.c        **** /*   Hilfsroutine zur Darstellung eines analogen Verlaufes entsprechend */
  68:main.c        **** /*   einem Oszillosop                                                   */
  69:main.c        **** /************************************************************************/
  70:main.c        **** #ifdef NXT
  71:main.c        **** #define TRACE_SIZE 200
  72:main.c        **** int16_t trace_buf0[TRACE_SIZE];
  73:main.c        **** int16_t trace_buf1[TRACE_SIZE];
  74:main.c        **** // Darstellung des Puffers über 'v.draw %e trace_buf0 trace_buf1'
  75:main.c        **** void trace_scope(int channel, int16_t value) {
 674              		.loc 1 75 46
 675              		.cfi_startproc
 676              		@ Function supports interworking.
 677              		@ args = 0, pretend = 0, frame = 8
 678              		@ frame_needed = 1, uses_anonymous_args = 0
 679              		@ link register save eliminated.
 680 0000 04B02DE5 		str	fp, [sp, #-4]!
 681              		.cfi_def_cfa_offset 4
 682              		.cfi_offset 11, -4
 683 0004 00B08DE2 		add	fp, sp, #0
 684              		.cfi_def_cfa_register 11
 685 0008 0CD04DE2 		sub	sp, sp, #12
 686 000c 08000BE5 		str	r0, [fp, #-8]
 687 0010 0130A0E1 		mov	r3, r1
 688 0014 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
  76:main.c        ****   // #define TRACE_ROLL
  77:main.c        **** #ifdef TRACE_ROLL
  78:main.c        ****   if (channel == 0) {
  79:main.c        ****     for (int lauf = 0; lauf < (TRACE_SIZE - 1); lauf++)
  80:main.c        ****       trace_buf0[lauf] = trace_buf0[lauf + 1];
  81:main.c        ****     trace_buf0[TRACE_SIZE - 1] = value;
  82:main.c        ****   } else {
  83:main.c        ****     for (int lauf = 0; lauf < (TRACE_SIZE - 1); lauf++)
  84:main.c        ****       trace_buf1[lauf] = trace_buf1[lauf + 1];
  85:main.c        ****     trace_buf1[TRACE_SIZE - 1] = value;
  86:main.c        ****   }
  87:main.c        **** #else
  88:main.c        ****   static int trace_index = 0;
  89:main.c        ****   if (trace_index < TRACE_SIZE) {
 689              		.loc 1 89 19
 690 0018 A8309FE5 		ldr	r3, .L43
 691 001c 003093E5 		ldr	r3, [r3]
 692              		.loc 1 89 6
 693 0020 C70053E3 		cmp	r3, #199
 694 0024 110000CA 		bgt	.L37
  90:main.c        ****     if (channel == 0)
 695              		.loc 1 90 8
 696 0028 08301BE5 		ldr	r3, [fp, #-8]
 697 002c 000053E3 		cmp	r3, #0
 698 0030 0700001A 		bne	.L38
  91:main.c        ****       trace_buf0[trace_index] = value;
 699              		.loc 1 91 17
 700 0034 8C309FE5 		ldr	r3, .L43
 701 0038 003093E5 		ldr	r3, [r3]
 702              		.loc 1 91 31
 703 003c 88209FE5 		ldr	r2, .L43+4
 704 0040 8330A0E1 		lsl	r3, r3, #1
 705 0044 033082E0 		add	r3, r2, r3
 706 0048 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 707 004c B020C3E1 		strh	r2, [r3]	@ movhi
 708 0050 060000EA 		b	.L37
 709              	.L38:
  92:main.c        ****     else
  93:main.c        ****       trace_buf1[trace_index] = value;
 710              		.loc 1 93 17
 711 0054 6C309FE5 		ldr	r3, .L43
 712 0058 003093E5 		ldr	r3, [r3]
 713              		.loc 1 93 31
 714 005c 6C209FE5 		ldr	r2, .L43+8
 715 0060 8330A0E1 		lsl	r3, r3, #1
 716 0064 033082E0 		add	r3, r2, r3
 717 0068 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 718 006c B020C3E1 		strh	r2, [r3]	@ movhi
 719              	.L37:
  94:main.c        ****   } else {
  95:main.c        ****     // Pause, damit der Debugger in 'Ruhe' den gesamten Speicher auslesen kann
  96:main.c        ****   }
  97:main.c        ****   if (channel == 1) {
 720              		.loc 1 97 6
 721 0070 08301BE5 		ldr	r3, [fp, #-8]
 722 0074 010053E3 		cmp	r3, #1
 723 0078 0E00001A 		bne	.L42
  98:main.c        ****     trace_index++;
 724              		.loc 1 98 16
 725 007c 44309FE5 		ldr	r3, .L43
 726 0080 003093E5 		ldr	r3, [r3]
 727 0084 013083E2 		add	r3, r3, #1
 728 0088 38209FE5 		ldr	r2, .L43
 729 008c 003082E5 		str	r3, [r2]
  99:main.c        ****     trace_index = trace_index >= (3 * TRACE_SIZE) ? 0 : trace_index;
 730              		.loc 1 99 31
 731 0090 30309FE5 		ldr	r3, .L43
 732 0094 003093E5 		ldr	r3, [r3]
 733              		.loc 1 99 55
 734 0098 960F53E3 		cmp	r3, #600
 735 009c 020000AA 		bge	.L40
 736              		.loc 1 99 55 is_stmt 0 discriminator 1
 737 00a0 20309FE5 		ldr	r3, .L43
 738 00a4 003093E5 		ldr	r3, [r3]
 739 00a8 000000EA 		b	.L41
 740              	.L40:
 741              		.loc 1 99 55 discriminator 2
 742 00ac 0030A0E3 		mov	r3, #0
 743              	.L41:
 744              		.loc 1 99 17 is_stmt 1 discriminator 4
 745 00b0 10209FE5 		ldr	r2, .L43
 746 00b4 003082E5 		str	r3, [r2]
 747              	.L42:
 100:main.c        ****   }
 101:main.c        **** #endif
 102:main.c        **** }
 748              		.loc 1 102 1
 749 00b8 0000A0E1 		nop
 750 00bc 00D08BE2 		add	sp, fp, #0
 751              		.cfi_def_cfa_register 13
 752              		@ sp needed
 753 00c0 04B09DE4 		ldr	fp, [sp], #4
 754              		.cfi_restore 11
 755              		.cfi_def_cfa_offset 0
 756 00c4 1EFF2FE1 		bx	lr
 757              	.L44:
 758              		.align	2
 759              	.L43:
 760 00c8 6C040000 		.word	trace_index.4
 761 00cc 00000000 		.word	trace_buf0
 762 00d0 00000000 		.word	trace_buf1
 763              		.cfi_endproc
 764              	.LFE16:
 766              		.global	h
 767              		.bss
 768              		.align	2
 771              	h:
 772 0324 00000000 		.space	328
 772      00000000 
 772      00000000 
 772      00000000 
 772      00000000 
 773              		.section	.rodata
 774              		.align	2
 775              	.LC0:
 776 0000 0A0D00   		.ascii	"\012\015\000"
 777              		.section	.text.herzschlag_process,"ax",%progbits
 778              		.align	2
 779              		.global	herzschlag_process
 780              		.syntax unified
 781              		.arm
 783              	herzschlag_process:
 784              	.LFB17:
 103:main.c        **** #endif
 104:main.c        **** #ifdef COMPILER_EXPLORER
 105:main.c        **** void trace_scope(int mode, uint16_t value) {
 106:main.c        ****   static int pos0 = 0;
 107:main.c        ****   static int pos1 = 0;
 108:main.c        ****   int val = (value - 450) / 4;
 109:main.c        ****   val = val > 80 ? 80 : (val < 0 ? 0 : val);
 110:main.c        ****   if (mode == 0) {
 111:main.c        ****     pos0 = val;
 112:main.c        ****   } else {
 113:main.c        ****     pos1 = val;
 114:main.c        ****     if (pos1 == pos0) {
 115:main.c        ****       printf("%*c\n", pos0, '+');
 116:main.c        ****     } else if (pos1 > pos0) {
 117:main.c        ****       printf("%*c%*c\n", pos0, '*', pos1 - pos0, '-');
 118:main.c        ****     } else {
 119:main.c        ****       printf("%*c%*c\n", pos1, '-', pos0 - pos1, '*');
 120:main.c        ****     }
 121:main.c        ****   }
 122:main.c        **** }
 123:main.c        **** #endif
 124:main.c        **** #if defined MODE_SIM || defined COMPILER_EXPLORER
 125:main.c        **** // Nachfolgendes Const-Array enthält Rohdaten und 'ersetzt' den AD-Wanderl
 126:main.c        **** uint16_t simuli_idx = 0;
 127:main.c        **** const uint16_t simuli[] = {
 128:main.c        ****     595, 596, 594, 586, 578, 568, 555, 545, 532, 524, 516, 507, 499, 493, 487,
 129:main.c        ****     481, 476, 473, 471, 471, 473, 481, 487, 503, 513, 517, 518, 516, 515, 511,
 130:main.c        ****     507, 502, 497, 492, 489, 484, 479, 476, 473, 470, 468, 467, 467, 466, 467,
 131:main.c        ****     466, 465, 465, 465, 465, 465, 466, 466, 446, 440, 439, 440, 442, 447, 452,
 132:main.c        ****     455, 460, 463, 467, 470, 471, 472, 474, 474, 474, 473, 472, 471, 469, 468,
 133:main.c        ****     468, 467, 466, 465, 465, 465, 464, 465, 466, 466, 488, 495, 497, 499, 500,
 134:main.c        ****     505, 510, 518, 531, 543, 560, 572, 582, 591, 596, 598, 595, 591, 582, 572,
 135:main.c        ****     563, 550, 540, 527, 518, 512, 503, 497, 490, 484, 476, 469, 448, 436, 435,
 136:main.c        ****     437, 441, 447, 455, 462, 469, 475, 480, 485, 485, 485, 484, 481, 479, 476,
 137:main.c        ****     471, 467, 465, 461, 459, 457, 455, 455, 453, 454, 455, 456, 457, 461, 467,
 138:main.c        ****     468, 486, 490, 491, 489, 486, 483, 478, 474, 471, 466, 464, 462, 461, 460,
 139:main.c        ****     459, 459, 460, 461, 462, 463, 464, 465, 467, 467, 467, 467, 467, 467, 467,
 140:main.c        ****     462, 445, 440, 439, 440, 443, 446, 449, 456, 462, 471, 480, 490, 508, 524,
 141:main.c        ****     543, 558, 577, 586, 593, 597, 597, 592, 585, 575, 562, 552, 539, 530, 521,
 142:main.c        ****     511, 506, 501, 514, 515, 512, 507, 499, 492, 486, 480, 477, 475, 475, 477,
 143:main.c        ****     480, 482, 483, 484, 486, 485, 484, 483, 480, 478, 474, 471, 469, 467, 464,
 144:main.c        ****     461, 462, 462, 462, 463, 441, 436, 436, 439, 443, 447, 451, 455, 459, 461,
 145:main.c        ****     464, 465, 465, 467, 467, 466, 466, 465, 465, 466, 466, 466, 466, 466, 467,
 146:main.c        ****     467, 466, 467, 467, 466, 466, 467, 473, 477, 488, 493, 493, 492, 489, 486,
 147:main.c        ****     483, 481, 481, 480, 482, 486, 491, 501, 513, 525, 544, 556, 575, 587, 597,
 148:main.c        ****     605, 608, 606, 601, 595, 587, 578, 570, 555, 532, 516, 509, 505, 501, 499,
 149:main.c        ****     496, 493, 492, 490, 490, 490, 493, 494, 498, 501, 504, 507, 508, 508, 506,
 150:main.c        ****     503, 500, 497, 493, 490, 486, 482, 480, 477, 475, 476, 491, 498, 498, 496,
 151:main.c        ****     493, 489, 484, 482, 479, 474, 472, 470, 468, 468, 468, 468, 469, 470, 472,
 152:main.c        ****     472, 472, 473, 474, 473, 475, 474, 475, 475, 475, 475, 474, 469, 451, 443,
 153:main.c        ****     442, 442, 445, 447, 451, 455, 459, 463, 466, 470, 472, 475, 477, 480, 484,
 154:main.c        ****     488, 496, 508, 519, 531, 549, 561, 574, 581, 586, 587, 583, 576, 567, 558,
 155:main.c        ****     552, 544, 549, 544, 536, 529, 520, 510, 502, 492, 486, 481, 475, 473, 474,
 156:main.c        ****     475, 477, 482, 485, 490, 493, 496, 497, 498, 497, 496, 494, 491, 487, 483,
 157:main.c        ****     480, 470, 451, 443, 438, 438, 440, 443, 446, 451, 456, 461, 464, 469, 472,
 158:main.c        ****     474, 476, 477, 478, 478, 478, 478, 478, 478, 479, 479, 478, 479, 479, 478,
 159:main.c        ****     479, 478, 477, 479, 495, 501, 500, 498, 494, 490, 485, 480, 476, 472, 469,
 160:main.c        ****     466, 463, 463, 462, 462, 463, 465, 466, 471, 476, 483, 494, 506, 525, 540,
 161:main.c        ****     554, 571, 580, 588, 590, 588, 559, 547, 533, 523, 516, 507, 504, 499, 494,
 162:main.c        ****     492, 490, 488, 485, 480, 476, 472, 467, 463, 461, 461, 461, 465, 468, 472,
 163:main.c        ****     474, 478, 479, 480, 480, 479, 477, 475, 478, 478, 488, 489, 487, 485, 480,
 164:main.c        ****     477, 472, 469, 465, 460, 457, 456, 454, 453, 452, 452, 451, 451, 453, 452,
 165:main.c        ****     453, 454, 455, 455, 455, 455, 454, 454, 454, 450, 433, 426, 426, 427, 430,
 166:main.c        ****     433, 438, 442, 447, 450, 453, 456, 459, 461, 461, 462, 462, 463, 462, 462,
 167:main.c        ****     463, 463, 465, 467, 472, 477, 490, 501, 520, 536, 556, 572, 601, 622, 628,
 168:main.c        ****     629, 624, 615, 600, 586, 567, 555, 543, 527, 519, 509, 502, 496, 489, 483,
 169:main.c        ****     475, 470, 466, 463, 462, 463, 463, 465, 470, 472, 474, 476, 477, 474, 457,
 170:main.c        ****     449, 445, 444, 445, 447, 448, 449, 451, 452, 454, 456, 457, 459, 461, 461,
 171:main.c        ****     462, 461, 459, 459, 459, 457, 457, 455, 455, 456, 455, 456, 455, 456, 457,
 172:main.c        ****     460, 464, 471, 482, 486, 488, 486, 484, 482, 478, 474, 470, 467, 465, 461,
 173:main.c        ****     459, 456, 453, 452, 451, 449, 449, 449, 449, 451, 454, 455, 459, 461, 465,
 174:main.c        ****     472, 479, 486, 483, 493, 511, 527, 546, 558, 569, 576, 579, 577, 572, 565,
 175:main.c        ****     555, 546, 534, 527, 519, 511, 502, 497, 493, 487, 480, 475, 471, 467, 465,
 176:main.c        ****     464, 466, 467, 472, 475, 500, 508, 512, 512, 509, 504, 499, 494, 487, 483,
 177:main.c        ****     479, 473, 470, 467, 465, 464, 464, 464, 465, 466, 468, 470, 473, 472, 474,
 178:main.c        ****     475, 474, 474, 474, 472, 471, 467, 444, 439, 436, 436, 438, 441, 445, 449,
 179:main.c        ****     454, 458, 463, 466, 468, 470, 471, 472, 472, 471, 470, 469, 468, 467, 465,
 180:main.c        ****     464, 464, 463, 462, 463, 463, 464, 466, 471, 481, 493, 513, 534, 548, 561,
 181:main.c        ****     576, 587, 595, 598, 598, 594, 587, 577, 567, 553, 543, 532, 521, 514, 510,
 182:main.c        ****     504, 500, 494, 491, 487, 482, 478, 474, 470, 469, 466, 450, 445, 447, 452,
 183:main.c        ****     457, 462, 468, 473, 478, 480, 482, 483, 482, 480, 479, 476, 474, 473, 471,
 184:main.c        ****     470, 468, 466, 466, 466, 466, 467, 466, 467, 467, 469, 469, 470, 491, 496,
 185:main.c        ****     497, 494, 491, 486, 482, 478, 472, 469, 465, 463, 461, 459, 458, 458, 458,
 186:main.c        ****     457, 458, 458, 459, 459, 459, 459, 460, 460, 460, 460, 460, 460, 459, 455,
 187:main.c        ****     440, 433, 434, 440, 445, 455, 472, 487, 504, 527, 545, 566, 579, 588, 595,
 188:main.c        ****     596};
 189:main.c        **** #endif
 190:main.c        **** /*****************************************************************************/
 191:main.c        **** /*   Ihr Programm                                                            */
 192:main.c        **** /*****************************************************************************/
 193:main.c        **** #define true 1
 194:main.c        **** #define false 0
 195:main.c        **** #define BUFFER_SIZE_AD 128
 196:main.c        **** #define BUFFER_SIZE_BPM 16
 197:main.c        **** #define MIN_BPM 50
 198:main.c        **** #define MAX_BPM 200
 199:main.c        **** #define MIN_AD 350
 200:main.c        **** #define OFFSET_AD 20
 201:main.c        **** 
 202:main.c        **** struct {
 203:main.c        ****   uint16_t ad_buf[BUFFER_SIZE_AD];
 204:main.c        ****   int ad_idx;
 205:main.c        ****   int bpm_idx;
 206:main.c        ****   int ad_sum;
 207:main.c        ****   int bpm_sum;
 208:main.c        ****   int ad_avg;
 209:main.c        ****   int bpm_avg;
 210:main.c        ****   uint16_t prev_bpm[BUFFER_SIZE_BPM];
 211:main.c        ****   uint32_t prev_beat;
 212:main.c        ****   uint32_t begin;
 213:main.c        ****   uint32_t end;
 214:main.c        ****   _Bool onBeat;
 215:main.c        **** 
 216:main.c        **** } h = {
 217:main.c        ****     .ad_buf = {0},
 218:main.c        ****     .ad_idx = 0,
 219:main.c        ****     .ad_sum = 0,
 220:main.c        ****     .ad_avg = 0,
 221:main.c        ****     .prev_bpm = {0},
 222:main.c        ****     .bpm_idx = 0,
 223:main.c        ****     .bpm_sum = 0,
 224:main.c        ****     .bpm_avg = 0,
 225:main.c        ****     .prev_beat = 0,
 226:main.c        ****     .begin = 0,
 227:main.c        ****     .end = 0,
 228:main.c        ****     .onBeat = false,
 229:main.c        **** };
 230:main.c        **** 
 231:main.c        **** //>0 ermittelter Herzschlag =0 kein neuer Herzschlag <0 Fehler
 232:main.c        **** int herzschlag_process(int32_t ad) {
 785              		.loc 1 232 36
 786              		.cfi_startproc
 787              		@ Function supports interworking.
 788              		@ args = 0, pretend = 0, frame = 24
 789              		@ frame_needed = 1, uses_anonymous_args = 0
 790 0000 00482DE9 		push	{fp, lr}
 791              		.cfi_def_cfa_offset 8
 792              		.cfi_offset 11, -8
 793              		.cfi_offset 14, -4
 794 0004 04B08DE2 		add	fp, sp, #4
 795              		.cfi_def_cfa 11, 4
 796 0008 18D04DE2 		sub	sp, sp, #24
 797 000c 18000BE5 		str	r0, [fp, #-24]
 233:main.c        ****   trace_scope(0, ad);
 798              		.loc 1 233 3
 799 0010 18301BE5 		ldr	r3, [fp, #-24]
 800 0014 0338A0E1 		lsl	r3, r3, #16
 801 0018 4338A0E1 		asr	r3, r3, #16
 802 001c 0310A0E1 		mov	r1, r3
 803 0020 0000A0E3 		mov	r0, #0
 804 0024 78339FE5 		ldr	r3, .L57
 805 0028 0FE0A0E1 		mov	lr, pc
 806 002c 13FF2FE1 		bx	r3
 807              	.LVL5:
 234:main.c        **** 
 235:main.c        ****   // Ringbuffer
 236:main.c        ****   h.ad_sum += (ad - h.ad_buf[h.ad_idx]);
 808              		.loc 1 236 4
 809 0030 70339FE5 		ldr	r3, .L57+4
 810 0034 082193E5 		ldr	r2, [r3, #264]
 811              		.loc 1 236 31
 812 0038 68339FE5 		ldr	r3, .L57+4
 813 003c 003193E5 		ldr	r3, [r3, #256]
 814              		.loc 1 236 29
 815 0040 60139FE5 		ldr	r1, .L57+4
 816 0044 8330A0E1 		lsl	r3, r3, #1
 817 0048 033081E0 		add	r3, r1, r3
 818 004c B030D3E1 		ldrh	r3, [r3]
 819 0050 0310A0E1 		mov	r1, r3
 820              		.loc 1 236 19
 821 0054 18301BE5 		ldr	r3, [fp, #-24]
 822 0058 013043E0 		sub	r3, r3, r1
 823              		.loc 1 236 12
 824 005c 033082E0 		add	r3, r2, r3
 825 0060 40239FE5 		ldr	r2, .L57+4
 826 0064 083182E5 		str	r3, [r2, #264]
 237:main.c        ****   h.ad_buf[h.ad_idx] = (uint16_t)ad;
 827              		.loc 1 237 13
 828 0068 38339FE5 		ldr	r3, .L57+4
 829 006c 003193E5 		ldr	r3, [r3, #256]
 830              		.loc 1 237 24
 831 0070 18201BE5 		ldr	r2, [fp, #-24]
 832 0074 0228A0E1 		lsl	r2, r2, #16
 833 0078 2228A0E1 		lsr	r2, r2, #16
 834              		.loc 1 237 22
 835 007c 24139FE5 		ldr	r1, .L57+4
 836 0080 8330A0E1 		lsl	r3, r3, #1
 837 0084 033081E0 		add	r3, r1, r3
 838 0088 B020C3E1 		strh	r2, [r3]	@ movhi
 238:main.c        ****   h.ad_idx = (h.ad_idx + 1) & 127;
 839              		.loc 1 238 16
 840 008c 14339FE5 		ldr	r3, .L57+4
 841 0090 003193E5 		ldr	r3, [r3, #256]
 842              		.loc 1 238 24
 843 0094 013083E2 		add	r3, r3, #1
 844              		.loc 1 238 29
 845 0098 7F3003E2 		and	r3, r3, #127
 846              		.loc 1 238 12
 847 009c 04239FE5 		ldr	r2, .L57+4
 848 00a0 003182E5 		str	r3, [r2, #256]
 239:main.c        **** 
 240:main.c        ****   // floating average
 241:main.c        ****   h.ad_avg = (h.ad_sum >> 7) + (h.ad_avg >> 2) - OFFSET_AD;
 849              		.loc 1 241 16
 850 00a4 FC329FE5 		ldr	r3, .L57+4
 851 00a8 083193E5 		ldr	r3, [r3, #264]
 852              		.loc 1 241 24
 853 00ac C323A0E1 		asr	r2, r3, #7
 854              		.loc 1 241 34
 855 00b0 F0329FE5 		ldr	r3, .L57+4
 856 00b4 103193E5 		ldr	r3, [r3, #272]
 857              		.loc 1 241 42
 858 00b8 4331A0E1 		asr	r3, r3, #2
 859              		.loc 1 241 30
 860 00bc 033082E0 		add	r3, r2, r3
 861              		.loc 1 241 48
 862 00c0 143043E2 		sub	r3, r3, #20
 863              		.loc 1 241 12
 864 00c4 DC229FE5 		ldr	r2, .L57+4
 865 00c8 103182E5 		str	r3, [r2, #272]
 242:main.c        ****   trace_scope(1, h.ad_avg);
 866              		.loc 1 242 19
 867 00cc D4329FE5 		ldr	r3, .L57+4
 868 00d0 103193E5 		ldr	r3, [r3, #272]
 869              		.loc 1 242 3
 870 00d4 0338A0E1 		lsl	r3, r3, #16
 871 00d8 4338A0E1 		asr	r3, r3, #16
 872 00dc 0310A0E1 		mov	r1, r3
 873 00e0 0100A0E3 		mov	r0, #1
 874 00e4 B8329FE5 		ldr	r3, .L57
 875 00e8 0FE0A0E1 		mov	lr, pc
 876 00ec 13FF2FE1 		bx	r3
 877              	.LVL6:
 243:main.c        **** 
 244:main.c        ****   // Average not set
 245:main.c        ****   if (h.ad_avg < MIN_AD) {
 878              		.loc 1 245 8
 879 00f0 B0329FE5 		ldr	r3, .L57+4
 880 00f4 103193E5 		ldr	r3, [r3, #272]
 881              		.loc 1 245 6
 882 00f8 AC229FE5 		ldr	r2, .L57+8
 883 00fc 020053E1 		cmp	r3, r2
 884 0100 010000CA 		bgt	.L46
 246:main.c        ****     return 0;
 885              		.loc 1 246 12
 886 0104 0030A0E3 		mov	r3, #0
 887 0108 A10000EA 		b	.L47
 888              	.L46:
 247:main.c        ****   }
 248:main.c        ****   // AGC error
 249:main.c        ****   if (ad > (h.ad_avg << 1)) {
 889              		.loc 1 249 14
 890 010c 94329FE5 		ldr	r3, .L57+4
 891 0110 103193E5 		ldr	r3, [r3, #272]
 892              		.loc 1 249 22
 893 0114 8330A0E1 		lsl	r3, r3, #1
 894              		.loc 1 249 6
 895 0118 18201BE5 		ldr	r2, [fp, #-24]
 896 011c 030052E1 		cmp	r2, r3
 897 0120 010000DA 		ble	.L48
 250:main.c        ****     return 0;
 898              		.loc 1 250 12
 899 0124 0030A0E3 		mov	r3, #0
 900 0128 990000EA 		b	.L47
 901              	.L48:
 251:main.c        ****   }
 252:main.c        **** 
 253:main.c        ****   // start of beat
 254:main.c        ****   if (ad > h.ad_avg && !h.onBeat) {
 902              		.loc 1 254 13
 903 012c 74329FE5 		ldr	r3, .L57+4
 904 0130 103193E5 		ldr	r3, [r3, #272]
 905              		.loc 1 254 6
 906 0134 18201BE5 		ldr	r2, [fp, #-24]
 907 0138 030052E1 		cmp	r2, r3
 908 013c 100000DA 		ble	.L49
 909              		.loc 1 254 26 discriminator 1
 910 0140 60329FE5 		ldr	r3, .L57+4
 911 0144 4431D3E5 		ldrb	r3, [r3, #324]	@ zero_extendqisi2
 912              		.loc 1 254 24 discriminator 1
 913 0148 013023E2 		eor	r3, r3, #1
 914 014c FF3003E2 		and	r3, r3, #255
 915              		.loc 1 254 21 discriminator 1
 916 0150 000053E3 		cmp	r3, #0
 917 0154 0A00000A 		beq	.L49
 255:main.c        ****     h.begin = systick_get_ms();
 918              		.loc 1 255 15
 919 0158 50329FE5 		ldr	r3, .L57+12
 920 015c 0FE0A0E1 		mov	lr, pc
 921 0160 13FF2FE1 		bx	r3
 922              	.LVL7:
 923 0164 0030A0E1 		mov	r3, r0
 924              		.loc 1 255 13 discriminator 1
 925 0168 38229FE5 		ldr	r2, .L57+4
 926 016c 3C3182E5 		str	r3, [r2, #316]
 256:main.c        ****     h.onBeat = true;
 927              		.loc 1 256 14
 928 0170 30329FE5 		ldr	r3, .L57+4
 929 0174 0120A0E3 		mov	r2, #1
 930 0178 4421C3E5 		strb	r2, [r3, #324]
 257:main.c        ****     return 0;
 931              		.loc 1 257 12
 932 017c 0030A0E3 		mov	r3, #0
 933 0180 830000EA 		b	.L47
 934              	.L49:
 258:main.c        ****   }
 259:main.c        **** 
 260:main.c        ****   // end of beat
 261:main.c        ****   if (ad < h.ad_avg && h.onBeat) {
 935              		.loc 1 261 13
 936 0184 1C329FE5 		ldr	r3, .L57+4
 937 0188 103193E5 		ldr	r3, [r3, #272]
 938              		.loc 1 261 6
 939 018c 18201BE5 		ldr	r2, [fp, #-24]
 940 0190 030052E1 		cmp	r2, r3
 941 0194 7D0000AA 		bge	.L50
 942              		.loc 1 261 25 discriminator 1
 943 0198 08329FE5 		ldr	r3, .L57+4
 944 019c 4431D3E5 		ldrb	r3, [r3, #324]	@ zero_extendqisi2
 945              		.loc 1 261 21 discriminator 1
 946 01a0 000053E3 		cmp	r3, #0
 947 01a4 7900000A 		beq	.L50
 948              	.LBB7:
 262:main.c        ****     h.end = systick_get_ms();
 949              		.loc 1 262 13
 950 01a8 00329FE5 		ldr	r3, .L57+12
 951 01ac 0FE0A0E1 		mov	lr, pc
 952 01b0 13FF2FE1 		bx	r3
 953              	.LVL8:
 954 01b4 0030A0E1 		mov	r3, r0
 955              		.loc 1 262 11 discriminator 1
 956 01b8 E8219FE5 		ldr	r2, .L57+4
 957 01bc 403182E5 		str	r3, [r2, #320]
 263:main.c        ****     h.onBeat = false;
 958              		.loc 1 263 14
 959 01c0 E0319FE5 		ldr	r3, .L57+4
 960 01c4 0020A0E3 		mov	r2, #0
 961 01c8 4421C3E5 		strb	r2, [r3, #324]
 264:main.c        **** 
 265:main.c        ****     // timestamp of beat
 266:main.c        ****     uint32_t timestamp = h.begin + ((h.end - h.begin) >> 1);
 962              		.loc 1 266 27
 963 01cc D4319FE5 		ldr	r3, .L57+4
 964 01d0 3C2193E5 		ldr	r2, [r3, #316]
 965              		.loc 1 266 39
 966 01d4 CC319FE5 		ldr	r3, .L57+4
 967 01d8 401193E5 		ldr	r1, [r3, #320]
 968              		.loc 1 266 47
 969 01dc C4319FE5 		ldr	r3, .L57+4
 970 01e0 3C3193E5 		ldr	r3, [r3, #316]
 971              		.loc 1 266 44
 972 01e4 033041E0 		sub	r3, r1, r3
 973              		.loc 1 266 55
 974 01e8 A330A0E1 		lsr	r3, r3, #1
 975              		.loc 1 266 14
 976 01ec 033082E0 		add	r3, r2, r3
 977 01f0 08300BE5 		str	r3, [fp, #-8]
 267:main.c        **** 
 268:main.c        ****     if (h.prev_beat == 0) {
 978              		.loc 1 268 10
 979 01f4 AC319FE5 		ldr	r3, .L57+4
 980 01f8 383193E5 		ldr	r3, [r3, #312]
 981              		.loc 1 268 8
 982 01fc 000053E3 		cmp	r3, #0
 983 0200 0400001A 		bne	.L51
 269:main.c        ****       h.prev_beat = timestamp;
 984              		.loc 1 269 19
 985 0204 9C219FE5 		ldr	r2, .L57+4
 986 0208 08301BE5 		ldr	r3, [fp, #-8]
 987 020c 383182E5 		str	r3, [r2, #312]
 270:main.c        ****       return 0;
 988              		.loc 1 270 14
 989 0210 0030A0E3 		mov	r3, #0
 990 0214 5E0000EA 		b	.L47
 991              	.L51:
 271:main.c        ****     }
 272:main.c        **** 
 273:main.c        ****     // time between beats
 274:main.c        ****     uint32_t t = timestamp - h.prev_beat;
 992              		.loc 1 274 31
 993 0218 88319FE5 		ldr	r3, .L57+4
 994 021c 383193E5 		ldr	r3, [r3, #312]
 995              		.loc 1 274 14
 996 0220 08201BE5 		ldr	r2, [fp, #-8]
 997 0224 033042E0 		sub	r3, r2, r3
 998 0228 0C300BE5 		str	r3, [fp, #-12]
 275:main.c        ****     if (t == 0) {
 999              		.loc 1 275 8
 1000 022c 0C301BE5 		ldr	r3, [fp, #-12]
 1001 0230 000053E3 		cmp	r3, #0
 1002 0234 0400001A 		bne	.L52
 276:main.c        ****       h.prev_beat = timestamp;
 1003              		.loc 1 276 19
 1004 0238 68219FE5 		ldr	r2, .L57+4
 1005 023c 08301BE5 		ldr	r3, [fp, #-8]
 1006 0240 383182E5 		str	r3, [r2, #312]
 277:main.c        ****       return 0;
 1007              		.loc 1 277 14
 1008 0244 0030A0E3 		mov	r3, #0
 1009 0248 510000EA 		b	.L47
 1010              	.L52:
 278:main.c        ****     }
 279:main.c        **** 
 280:main.c        ****     h.prev_beat = timestamp;
 1011              		.loc 1 280 17
 1012 024c 54219FE5 		ldr	r2, .L57+4
 1013 0250 08301BE5 		ldr	r3, [fp, #-8]
 1014 0254 383182E5 		str	r3, [r2, #312]
 281:main.c        **** 
 282:main.c        ****     // 60*1000/t
 283:main.c        ****     int bpm = 60000 / t;
 1015              		.loc 1 283 21
 1016 0258 54319FE5 		ldr	r3, .L57+16
 1017 025c 0C101BE5 		ldr	r1, [fp, #-12]
 1018 0260 50019FE5 		ldr	r0, .L57+20
 1019 0264 0FE0A0E1 		mov	lr, pc
 1020 0268 13FF2FE1 		bx	r3
 1021              	.LVL9:
 1022 026c 0030A0E1 		mov	r3, r0
 1023              		.loc 1 283 9
 1024 0270 10300BE5 		str	r3, [fp, #-16]
 284:main.c        **** 
 285:main.c        ****     if (bpm < MIN_BPM || bpm > MAX_BPM) {
 1025              		.loc 1 285 8
 1026 0274 10301BE5 		ldr	r3, [fp, #-16]
 1027 0278 310053E3 		cmp	r3, #49
 1028 027c 020000DA 		ble	.L53
 1029              		.loc 1 285 23 discriminator 1
 1030 0280 10301BE5 		ldr	r3, [fp, #-16]
 1031 0284 C80053E3 		cmp	r3, #200
 1032 0288 010000DA 		ble	.L54
 1033              	.L53:
 286:main.c        ****       return 0;
 1034              		.loc 1 286 14
 1035 028c 0030A0E3 		mov	r3, #0
 1036 0290 3F0000EA 		b	.L47
 1037              	.L54:
 287:main.c        ****     }
 288:main.c        **** 
 289:main.c        ****     // Ringbuffer bpm
 290:main.c        ****     h.bpm_sum += (bpm - h.prev_bpm[h.bpm_idx]);
 1038              		.loc 1 290 6
 1039 0294 0C319FE5 		ldr	r3, .L57+4
 1040 0298 0C2193E5 		ldr	r2, [r3, #268]
 1041              		.loc 1 290 37
 1042 029c 04319FE5 		ldr	r3, .L57+4
 1043 02a0 043193E5 		ldr	r3, [r3, #260]
 1044              		.loc 1 290 35
 1045 02a4 FC109FE5 		ldr	r1, .L57+4
 1046 02a8 8C3083E2 		add	r3, r3, #140
 1047 02ac 8330A0E1 		lsl	r3, r3, #1
 1048 02b0 033081E0 		add	r3, r1, r3
 1049 02b4 B030D3E1 		ldrh	r3, [r3]
 1050 02b8 0310A0E1 		mov	r1, r3
 1051              		.loc 1 290 23
 1052 02bc 10301BE5 		ldr	r3, [fp, #-16]
 1053 02c0 013043E0 		sub	r3, r3, r1
 1054              		.loc 1 290 15
 1055 02c4 033082E0 		add	r3, r2, r3
 1056 02c8 D8209FE5 		ldr	r2, .L57+4
 1057 02cc 0C3182E5 		str	r3, [r2, #268]
 291:main.c        ****     h.prev_bpm[h.bpm_idx] = (uint16_t)bpm;
 1058              		.loc 1 291 17
 1059 02d0 D0309FE5 		ldr	r3, .L57+4
 1060 02d4 043193E5 		ldr	r3, [r3, #260]
 1061              		.loc 1 291 29
 1062 02d8 10201BE5 		ldr	r2, [fp, #-16]
 1063 02dc 0228A0E1 		lsl	r2, r2, #16
 1064 02e0 2228A0E1 		lsr	r2, r2, #16
 1065              		.loc 1 291 27
 1066 02e4 BC109FE5 		ldr	r1, .L57+4
 1067 02e8 8C3083E2 		add	r3, r3, #140
 1068 02ec 8330A0E1 		lsl	r3, r3, #1
 1069 02f0 033081E0 		add	r3, r1, r3
 1070 02f4 B020C3E1 		strh	r2, [r3]	@ movhi
 292:main.c        ****     h.bpm_idx = (h.bpm_idx + 1) & 15;
 1071              		.loc 1 292 19
 1072 02f8 A8309FE5 		ldr	r3, .L57+4
 1073 02fc 043193E5 		ldr	r3, [r3, #260]
 1074              		.loc 1 292 28
 1075 0300 013083E2 		add	r3, r3, #1
 1076              		.loc 1 292 33
 1077 0304 0F3003E2 		and	r3, r3, #15
 1078              		.loc 1 292 15
 1079 0308 98209FE5 		ldr	r2, .L57+4
 1080 030c 043182E5 		str	r3, [r2, #260]
 293:main.c        **** 
 294:main.c        ****     // floating average bpm
 295:main.c        ****     h.bpm_avg = (h.bpm_sum >> 4);
 1081              		.loc 1 295 19
 1082 0310 90309FE5 		ldr	r3, .L57+4
 1083 0314 0C3193E5 		ldr	r3, [r3, #268]
 1084              		.loc 1 295 28
 1085 0318 4332A0E1 		asr	r3, r3, #4
 1086              		.loc 1 295 15
 1087 031c 84209FE5 		ldr	r2, .L57+4
 1088 0320 143182E5 		str	r3, [r2, #276]
 296:main.c        **** 
 297:main.c        ****     if (bpm > (h.bpm_avg + 10) || bpm < (h.bpm_avg - 10))
 1089              		.loc 1 297 17
 1090 0324 7C309FE5 		ldr	r3, .L57+4
 1091 0328 143193E5 		ldr	r3, [r3, #276]
 1092              		.loc 1 297 26
 1093 032c 0A3083E2 		add	r3, r3, #10
 1094              		.loc 1 297 8
 1095 0330 10201BE5 		ldr	r2, [fp, #-16]
 1096 0334 030052E1 		cmp	r2, r3
 1097 0338 050000CA 		bgt	.L55
 1098              		.loc 1 297 43 discriminator 1
 1099 033c 64309FE5 		ldr	r3, .L57+4
 1100 0340 143193E5 		ldr	r3, [r3, #276]
 1101              		.loc 1 297 52 discriminator 1
 1102 0344 0A3043E2 		sub	r3, r3, #10
 1103              		.loc 1 297 32 discriminator 1
 1104 0348 10201BE5 		ldr	r2, [fp, #-16]
 1105 034c 030052E1 		cmp	r2, r3
 1106 0350 010000AA 		bge	.L56
 1107              	.L55:
 298:main.c        ****       return 0;
 1108              		.loc 1 298 14
 1109 0354 0030A0E3 		mov	r3, #0
 1110 0358 0D0000EA 		b	.L47
 1111              	.L56:
 299:main.c        **** 
 300:main.c        ****     (void)term_int(bpm, 3, ASYNCSYNC_NONBLOCK);
 1112              		.loc 1 300 11
 1113 035c 0020A0E3 		mov	r2, #0
 1114 0360 0310A0E3 		mov	r1, #3
 1115 0364 10001BE5 		ldr	r0, [fp, #-16]
 1116 0368 4C309FE5 		ldr	r3, .L57+24
 1117 036c 0FE0A0E1 		mov	lr, pc
 1118 0370 13FF2FE1 		bx	r3
 1119              	.LVL10:
 301:main.c        ****     (void)term_string("\n\r", ASYNCSYNC_NONBLOCK);
 1120              		.loc 1 301 11
 1121 0374 0010A0E3 		mov	r1, #0
 1122 0378 40009FE5 		ldr	r0, .L57+28
 1123 037c 40309FE5 		ldr	r3, .L57+32
 1124 0380 0FE0A0E1 		mov	lr, pc
 1125 0384 13FF2FE1 		bx	r3
 1126              	.LVL11:
 302:main.c        **** 
 303:main.c        ****     return bpm;
 1127              		.loc 1 303 12
 1128 0388 10301BE5 		ldr	r3, [fp, #-16]
 1129 038c 000000EA 		b	.L47
 1130              	.L50:
 1131              	.LBE7:
 304:main.c        ****   }
 305:main.c        **** 
 306:main.c        ****   return 0;
 1132              		.loc 1 306 10
 1133 0390 0030A0E3 		mov	r3, #0
 1134              	.L47:
 307:main.c        **** }
 1135              		.loc 1 307 1
 1136 0394 0300A0E1 		mov	r0, r3
 1137 0398 04D04BE2 		sub	sp, fp, #4
 1138              		.cfi_def_cfa 13, 8
 1139              		@ sp needed
 1140 039c 0048BDE8 		pop	{fp, lr}
 1141              		.cfi_restore 14
 1142              		.cfi_restore 11
 1143              		.cfi_def_cfa_offset 0
 1144 03a0 1EFF2FE1 		bx	lr
 1145              	.L58:
 1146              		.align	2
 1147              	.L57:
 1148 03a4 00000000 		.word	trace_scope
 1149 03a8 00000000 		.word	h
 1150 03ac 5D010000 		.word	349
 1151 03b0 00000000 		.word	systick_get_ms
 1152 03b4 00000000 		.word	__aeabi_uidiv
 1153 03b8 60EA0000 		.word	60000
 1154 03bc 00000000 		.word	term_int
 1155 03c0 00000000 		.word	.LC0
 1156 03c4 00000000 		.word	term_string
 1157              		.cfi_endproc
 1158              	.LFE17:
 1160              		.section	.text.task_8ms,"ax",%progbits
 1161              		.align	2
 1162              		.global	task_8ms
 1163              		.syntax unified
 1164              		.arm
 1166              	task_8ms:
 1167              	.LFB18:
 308:main.c        **** 
 309:main.c        **** #ifdef NXT
 310:main.c        **** /*****************************************************************************/
 311:main.c        **** /*   Hilfsroutinen                                                           */
 312:main.c        **** /*****************************************************************************/
 313:main.c        **** void task_8ms(void) {
 1168              		.loc 1 313 21
 1169              		.cfi_startproc
 1170              		@ Function supports interworking.
 1171              		@ args = 0, pretend = 0, frame = 0
 1172              		@ frame_needed = 1, uses_anonymous_args = 0
 1173 0000 00482DE9 		push	{fp, lr}
 1174              		.cfi_def_cfa_offset 8
 1175              		.cfi_offset 11, -8
 1176              		.cfi_offset 14, -4
 1177 0004 04B08DE2 		add	fp, sp, #4
 1178              		.cfi_def_cfa 11, 4
 314:main.c        ****   // Keine blockierende Aufrufe
 315:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 316:main.c        **** #ifdef MODE_SIM
 317:main.c        ****   (void)herzschlag_process(simuli[simuli_idx++]);
 318:main.c        ****   simuli_idx = simuli_idx % (sizeof(simuli) / sizeof(simuli[0]));
 319:main.c        **** #else
 320:main.c        ****   (void)herzschlag_process(nxt_avr_get_sensor_adc_raw(HERZSCHLAG_PORT));
 1179              		.loc 1 320 28
 1180 0008 0100A0E3 		mov	r0, #1
 1181 000c 28309FE5 		ldr	r3, .L60
 1182 0010 0FE0A0E1 		mov	lr, pc
 1183 0014 13FF2FE1 		bx	r3
 1184              	.LVL12:
 1185 0018 0030A0E1 		mov	r3, r0
 1186              		.loc 1 320 9 discriminator 1
 1187 001c 0300A0E1 		mov	r0, r3
 1188 0020 18309FE5 		ldr	r3, .L60+4
 1189 0024 0FE0A0E1 		mov	lr, pc
 1190 0028 13FF2FE1 		bx	r3
 1191              	.LVL13:
 321:main.c        **** #endif
 322:main.c        **** }
 1192              		.loc 1 322 1
 1193 002c 0000A0E1 		nop
 1194 0030 04D04BE2 		sub	sp, fp, #4
 1195              		.cfi_def_cfa 13, 8
 1196              		@ sp needed
 1197 0034 0048BDE8 		pop	{fp, lr}
 1198              		.cfi_restore 14
 1199              		.cfi_restore 11
 1200              		.cfi_def_cfa_offset 0
 1201 0038 1EFF2FE1 		bx	lr
 1202              	.L61:
 1203              		.align	2
 1204              	.L60:
 1205 003c 00000000 		.word	nxt_avr_get_sensor_adc_raw
 1206 0040 00000000 		.word	herzschlag_process
 1207              		.cfi_endproc
 1208              	.LFE18:
 1210              		.section	.text.task_16ms,"ax",%progbits
 1211              		.align	2
 1212              		.global	task_16ms
 1213              		.syntax unified
 1214              		.arm
 1216              	task_16ms:
 1217              	.LFB19:
 323:main.c        **** 
 324:main.c        **** void task_16ms(void) {
 1218              		.loc 1 324 22
 1219              		.cfi_startproc
 1220              		@ Function supports interworking.
 1221              		@ args = 0, pretend = 0, frame = 0
 1222              		@ frame_needed = 1, uses_anonymous_args = 0
 1223              		@ link register save eliminated.
 1224 0000 04B02DE5 		str	fp, [sp, #-4]!
 1225              		.cfi_def_cfa_offset 4
 1226              		.cfi_offset 11, -4
 1227 0004 00B08DE2 		add	fp, sp, #0
 1228              		.cfi_def_cfa_register 11
 325:main.c        ****   // Keine blockierende Aufrufe
 326:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 327:main.c        **** }
 1229              		.loc 1 327 1
 1230 0008 0000A0E1 		nop
 1231 000c 00D08BE2 		add	sp, fp, #0
 1232              		.cfi_def_cfa_register 13
 1233              		@ sp needed
 1234 0010 04B09DE4 		ldr	fp, [sp], #4
 1235              		.cfi_restore 11
 1236              		.cfi_def_cfa_offset 0
 1237 0014 1EFF2FE1 		bx	lr
 1238              		.cfi_endproc
 1239              	.LFE19:
 1241              		.section	.text.task_32ms,"ax",%progbits
 1242              		.align	2
 1243              		.global	task_32ms
 1244              		.syntax unified
 1245              		.arm
 1247              	task_32ms:
 1248              	.LFB20:
 328:main.c        **** void task_32ms(void) {
 1249              		.loc 1 328 22
 1250              		.cfi_startproc
 1251              		@ Function supports interworking.
 1252              		@ args = 0, pretend = 0, frame = 0
 1253              		@ frame_needed = 1, uses_anonymous_args = 0
 1254              		@ link register save eliminated.
 1255 0000 04B02DE5 		str	fp, [sp, #-4]!
 1256              		.cfi_def_cfa_offset 4
 1257              		.cfi_offset 11, -4
 1258 0004 00B08DE2 		add	fp, sp, #0
 1259              		.cfi_def_cfa_register 11
 329:main.c        ****   // Keine blockierende Aufrufe
 330:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 331:main.c        **** }
 1260              		.loc 1 331 1
 1261 0008 0000A0E1 		nop
 1262 000c 00D08BE2 		add	sp, fp, #0
 1263              		.cfi_def_cfa_register 13
 1264              		@ sp needed
 1265 0010 04B09DE4 		ldr	fp, [sp], #4
 1266              		.cfi_restore 11
 1267              		.cfi_def_cfa_offset 0
 1268 0014 1EFF2FE1 		bx	lr
 1269              		.cfi_endproc
 1270              	.LFE20:
 1272              		.section	.text.task_64ms,"ax",%progbits
 1273              		.align	2
 1274              		.global	task_64ms
 1275              		.syntax unified
 1276              		.arm
 1278              	task_64ms:
 1279              	.LFB21:
 332:main.c        **** void task_64ms(void) {
 1280              		.loc 1 332 22
 1281              		.cfi_startproc
 1282              		@ Function supports interworking.
 1283              		@ args = 0, pretend = 0, frame = 0
 1284              		@ frame_needed = 1, uses_anonymous_args = 0
 1285              		@ link register save eliminated.
 1286 0000 04B02DE5 		str	fp, [sp, #-4]!
 1287              		.cfi_def_cfa_offset 4
 1288              		.cfi_offset 11, -4
 1289 0004 00B08DE2 		add	fp, sp, #0
 1290              		.cfi_def_cfa_register 11
 333:main.c        ****   // Keine blockierende Aufrufe
 334:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 335:main.c        **** }
 1291              		.loc 1 335 1
 1292 0008 0000A0E1 		nop
 1293 000c 00D08BE2 		add	sp, fp, #0
 1294              		.cfi_def_cfa_register 13
 1295              		@ sp needed
 1296 0010 04B09DE4 		ldr	fp, [sp], #4
 1297              		.cfi_restore 11
 1298              		.cfi_def_cfa_offset 0
 1299 0014 1EFF2FE1 		bx	lr
 1300              		.cfi_endproc
 1301              	.LFE21:
 1303              		.section	.text.task_128ms,"ax",%progbits
 1304              		.align	2
 1305              		.global	task_128ms
 1306              		.syntax unified
 1307              		.arm
 1309              	task_128ms:
 1310              	.LFB22:
 336:main.c        **** 
 337:main.c        **** void task_128ms(void) {
 1311              		.loc 1 337 23
 1312              		.cfi_startproc
 1313              		@ Function supports interworking.
 1314              		@ args = 0, pretend = 0, frame = 0
 1315              		@ frame_needed = 1, uses_anonymous_args = 0
 1316              		@ link register save eliminated.
 1317 0000 04B02DE5 		str	fp, [sp, #-4]!
 1318              		.cfi_def_cfa_offset 4
 1319              		.cfi_offset 11, -4
 1320 0004 00B08DE2 		add	fp, sp, #0
 1321              		.cfi_def_cfa_register 11
 338:main.c        ****   // Keine blockierende Aufrufe
 339:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 340:main.c        **** }
 1322              		.loc 1 340 1
 1323 0008 0000A0E1 		nop
 1324 000c 00D08BE2 		add	sp, fp, #0
 1325              		.cfi_def_cfa_register 13
 1326              		@ sp needed
 1327 0010 04B09DE4 		ldr	fp, [sp], #4
 1328              		.cfi_restore 11
 1329              		.cfi_def_cfa_offset 0
 1330 0014 1EFF2FE1 		bx	lr
 1331              		.cfi_endproc
 1332              	.LFE22:
 1334              		.section	.rodata
 1335 0003 00       		.align	2
 1336              	.LC1:
 1337 0004 53303A00 		.ascii	"S0:\000"
 1338              		.align	2
 1339              	.LC2:
 1340 0008 4261743A 		.ascii	"Bat:\000"
 1340      00
 1341 000d 000000   		.align	2
 1342              	.LC3:
 1343 0010 6D5600   		.ascii	"mV\000"
 1344 0013 00       		.align	2
 1345              	.LC4:
 1346 0014 4275743A 		.ascii	"But: \000"
 1346      2000
 1347 001a 0000     		.align	2
 1348              	.LC5:
 1349 001c 54696D65 		.ascii	"Time: \000"
 1349      3A2000
 1350 0023 00       		.align	2
 1351              	.LC6:
 1352 0024 7300     		.ascii	"s\000"
 1353              		.section	.text.task_256ms,"ax",%progbits
 1354              		.align	2
 1355              		.global	task_256ms
 1356              		.syntax unified
 1357              		.arm
 1359              	task_256ms:
 1360              	.LFB23:
 341:main.c        **** void task_256ms(void) {
 1361              		.loc 1 341 23
 1362              		.cfi_startproc
 1363              		@ Function supports interworking.
 1364              		@ args = 0, pretend = 0, frame = 0
 1365              		@ frame_needed = 1, uses_anonymous_args = 0
 1366 0000 00482DE9 		push	{fp, lr}
 1367              		.cfi_def_cfa_offset 8
 1368              		.cfi_offset 11, -8
 1369              		.cfi_offset 14, -4
 1370 0004 04B08DE2 		add	fp, sp, #4
 1371              		.cfi_def_cfa 11, 4
 342:main.c        ****   // Keine blockierende Aufrufe
 343:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 344:main.c        **** 
 345:main.c        ****   // Beispielanwendung für MotorPos,Sensor,Batterie und NXT-Tasten
 346:main.c        ****   // Im Simulationsmodus kann im 'Per'-Fenster Werte vorgegeben werden
 347:main.c        ****   // Beispiel zur Abfrage des anlogen Eingangs am SensorPort 1
 348:main.c        ****   display_string("S0:");
 1372              		.loc 1 348 3
 1373 0008 2C029FE5 		ldr	r0, .L75
 1374 000c 2C329FE5 		ldr	r3, .L75+4
 1375 0010 0FE0A0E1 		mov	lr, pc
 1376 0014 13FF2FE1 		bx	r3
 1377              	.LVL14:
 349:main.c        ****   display_hex((uint32_t)nxt_avr_get_sensor_adc_raw(SENSOR_1),
 1378              		.loc 1 349 25
 1379 0018 0000A0E3 		mov	r0, #0
 1380 001c 20329FE5 		ldr	r3, .L75+8
 1381 0020 0FE0A0E1 		mov	lr, pc
 1382 0024 13FF2FE1 		bx	r3
 1383              	.LVL15:
 1384 0028 0030A0E1 		mov	r3, r0
 1385              		.loc 1 349 3 discriminator 1
 1386 002c 0310A0E3 		mov	r1, #3
 1387 0030 0300A0E1 		mov	r0, r3
 1388 0034 0C329FE5 		ldr	r3, .L75+12
 1389 0038 0FE0A0E1 		mov	lr, pc
 1390 003c 13FF2FE1 		bx	r3
 1391              	.LVL16:
 350:main.c        ****               3); // PER: NXT_AVR_ADC_1
 351:main.c        ****   // Beispiel zur Abfrage der Batteriespannung
 352:main.c        ****   display_goto_xy(0, 3);
 1392              		.loc 1 352 3
 1393 0040 0310A0E3 		mov	r1, #3
 1394 0044 0000A0E3 		mov	r0, #0
 1395 0048 FC319FE5 		ldr	r3, .L75+16
 1396 004c 0FE0A0E1 		mov	lr, pc
 1397 0050 13FF2FE1 		bx	r3
 1398              	.LVL17:
 353:main.c        ****   display_string("Bat:");
 1399              		.loc 1 353 3
 1400 0054 F4019FE5 		ldr	r0, .L75+20
 1401 0058 E0319FE5 		ldr	r3, .L75+4
 1402 005c 0FE0A0E1 		mov	lr, pc
 1403 0060 13FF2FE1 		bx	r3
 1404              	.LVL18:
 354:main.c        ****   display_unsigned(nxt_avr_get_battery_mv(),
 1405              		.loc 1 354 20
 1406 0064 E8319FE5 		ldr	r3, .L75+24
 1407 0068 0FE0A0E1 		mov	lr, pc
 1408 006c 13FF2FE1 		bx	r3
 1409              	.LVL19:
 1410 0070 0030A0E1 		mov	r3, r0
 1411              		.loc 1 354 3 discriminator 1
 1412 0074 0510A0E3 		mov	r1, #5
 1413 0078 0300A0E1 		mov	r0, r3
 1414 007c D4319FE5 		ldr	r3, .L75+28
 1415 0080 0FE0A0E1 		mov	lr, pc
 1416 0084 13FF2FE1 		bx	r3
 1417              	.LVL20:
 355:main.c        ****                    5); // über AVR-Proz -> PER: NXT_AVR_BATTERY
 356:main.c        ****   //	display_unsigned(adc_get_usb_mv()         ,5);  //über SAM7-Proz
 357:main.c        ****   display_string("mV");
 1418              		.loc 1 357 3
 1419 0088 CC019FE5 		ldr	r0, .L75+32
 1420 008c AC319FE5 		ldr	r3, .L75+4
 1421 0090 0FE0A0E1 		mov	lr, pc
 1422 0094 13FF2FE1 		bx	r3
 1423              	.LVL21:
 358:main.c        ****   // Beispiel zur Abfrage der NXT-Tasten
 359:main.c        ****   display_goto_xy(0, 4);
 1424              		.loc 1 359 3
 1425 0098 0410A0E3 		mov	r1, #4
 1426 009c 0000A0E3 		mov	r0, #0
 1427 00a0 A4319FE5 		ldr	r3, .L75+16
 1428 00a4 0FE0A0E1 		mov	lr, pc
 1429 00a8 13FF2FE1 		bx	r3
 1430              	.LVL22:
 360:main.c        ****   display_string("But: ");
 1431              		.loc 1 360 3
 1432 00ac AC019FE5 		ldr	r0, .L75+36
 1433 00b0 88319FE5 		ldr	r3, .L75+4
 1434 00b4 0FE0A0E1 		mov	lr, pc
 1435 00b8 13FF2FE1 		bx	r3
 1436              	.LVL23:
 361:main.c        ****   display_char(nxt_avr_get_buttons().orange ? 'O' : '-');
 1437              		.loc 1 361 16
 1438 00bc A0319FE5 		ldr	r3, .L75+40
 1439 00c0 0FE0A0E1 		mov	lr, pc
 1440 00c4 13FF2FE1 		bx	r3
 1441              	.LVL24:
 1442 00c8 0030A0E1 		mov	r3, r0
 1443              		.loc 1 361 45 discriminator 1
 1444 00cc FF3003E2 		and	r3, r3, #255
 1445 00d0 013003E2 		and	r3, r3, #1
 1446 00d4 FF3003E2 		and	r3, r3, #255
 1447              		.loc 1 361 3 discriminator 1
 1448 00d8 000053E3 		cmp	r3, #0
 1449 00dc 0100000A 		beq	.L67
 1450 00e0 4F30A0E3 		mov	r3, #79
 1451 00e4 000000EA 		b	.L68
 1452              	.L67:
 1453              		.loc 1 361 3 is_stmt 0 discriminator 2
 1454 00e8 2D30A0E3 		mov	r3, #45
 1455              	.L68:
 1456              		.loc 1 361 3 discriminator 4
 1457 00ec 0300A0E1 		mov	r0, r3
 1458 00f0 70319FE5 		ldr	r3, .L75+44
 1459 00f4 0FE0A0E1 		mov	lr, pc
 1460 00f8 13FF2FE1 		bx	r3
 1461              	.LVL25:
 362:main.c        ****   display_char(nxt_avr_get_buttons().left ? 'L'
 1462              		.loc 1 362 16 is_stmt 1
 1463 00fc 60319FE5 		ldr	r3, .L75+40
 1464 0100 0FE0A0E1 		mov	lr, pc
 1465 0104 13FF2FE1 		bx	r3
 1466              	.LVL26:
 1467 0108 0030A0E1 		mov	r3, r0
 1468              		.loc 1 362 43 discriminator 1
 1469 010c FF3003E2 		and	r3, r3, #255
 1470 0110 023003E2 		and	r3, r3, #2
 1471 0114 FF3003E2 		and	r3, r3, #255
 1472              		.loc 1 362 3 discriminator 1
 1473 0118 000053E3 		cmp	r3, #0
 1474 011c 0100000A 		beq	.L69
 1475 0120 4C30A0E3 		mov	r3, #76
 1476 0124 000000EA 		b	.L70
 1477              	.L69:
 1478              		.loc 1 362 3 is_stmt 0 discriminator 2
 1479 0128 2D30A0E3 		mov	r3, #45
 1480              	.L70:
 1481              		.loc 1 362 3 discriminator 4
 1482 012c 0300A0E1 		mov	r0, r3
 1483 0130 30319FE5 		ldr	r3, .L75+44
 1484 0134 0FE0A0E1 		mov	lr, pc
 1485 0138 13FF2FE1 		bx	r3
 1486              	.LVL27:
 363:main.c        ****                                           : '-'); // Left/Right/Grey generien
 364:main.c        ****   display_char(nxt_avr_get_buttons().right ? 'R'
 1487              		.loc 1 364 16 is_stmt 1
 1488 013c 20319FE5 		ldr	r3, .L75+40
 1489 0140 0FE0A0E1 		mov	lr, pc
 1490 0144 13FF2FE1 		bx	r3
 1491              	.LVL28:
 1492 0148 0030A0E1 		mov	r3, r0
 1493              		.loc 1 364 44 discriminator 1
 1494 014c FF3003E2 		and	r3, r3, #255
 1495 0150 043003E2 		and	r3, r3, #4
 1496 0154 FF3003E2 		and	r3, r3, #255
 1497              		.loc 1 364 3 discriminator 1
 1498 0158 000053E3 		cmp	r3, #0
 1499 015c 0100000A 		beq	.L71
 1500 0160 5230A0E3 		mov	r3, #82
 1501 0164 000000EA 		b	.L72
 1502              	.L71:
 1503              		.loc 1 364 3 is_stmt 0 discriminator 2
 1504 0168 2D30A0E3 		mov	r3, #45
 1505              	.L72:
 1506              		.loc 1 364 3 discriminator 4
 1507 016c 0300A0E1 		mov	r0, r3
 1508 0170 F0309FE5 		ldr	r3, .L75+44
 1509 0174 0FE0A0E1 		mov	lr, pc
 1510 0178 13FF2FE1 		bx	r3
 1511              	.LVL29:
 365:main.c        ****                                            : '-'); // je eine eigenen Spannung
 366:main.c        ****   display_char(nxt_avr_get_buttons().grey
 1512              		.loc 1 366 16 is_stmt 1
 1513 017c E0309FE5 		ldr	r3, .L75+40
 1514 0180 0FE0A0E1 		mov	lr, pc
 1515 0184 13FF2FE1 		bx	r3
 1516              	.LVL30:
 1517 0188 0030A0E1 		mov	r3, r0
 367:main.c        ****                    ? 'G'
 1518              		.loc 1 367 20
 1519 018c FF3003E2 		and	r3, r3, #255
 1520 0190 083003E2 		and	r3, r3, #8
 1521 0194 FF3003E2 		and	r3, r3, #255
 366:main.c        ****                    ? 'G'
 1522              		.loc 1 366 3
 1523 0198 000053E3 		cmp	r3, #0
 1524 019c 0100000A 		beq	.L73
 366:main.c        ****                    ? 'G'
 1525              		.loc 1 366 3 is_stmt 0 discriminator 1
 1526 01a0 4730A0E3 		mov	r3, #71
 1527 01a4 000000EA 		b	.L74
 1528              	.L73:
 366:main.c        ****                    ? 'G'
 1529              		.loc 1 366 3 discriminator 2
 1530 01a8 2D30A0E3 		mov	r3, #45
 1531              	.L74:
 366:main.c        ****                    ? 'G'
 1532              		.loc 1 366 3 discriminator 4
 1533 01ac 0300A0E1 		mov	r0, r3
 1534 01b0 B0309FE5 		ldr	r3, .L75+44
 1535 01b4 0FE0A0E1 		mov	lr, pc
 1536 01b8 13FF2FE1 		bx	r3
 1537              	.LVL31:
 368:main.c        ****                    : '-'); // so dass diese 3 nicht gemeinsam
 369:main.c        ****                            // erkannt werden können
 370:main.c        ****   // Beispiel für Zeitdarstellung
 371:main.c        ****   display_goto_xy(0, 5);
 1538              		.loc 1 371 3 is_stmt 1
 1539 01bc 0510A0E3 		mov	r1, #5
 1540 01c0 0000A0E3 		mov	r0, #0
 1541 01c4 80309FE5 		ldr	r3, .L75+16
 1542 01c8 0FE0A0E1 		mov	lr, pc
 1543 01cc 13FF2FE1 		bx	r3
 1544              	.LVL32:
 372:main.c        ****   display_string("Time: ");
 1545              		.loc 1 372 3
 1546 01d0 94009FE5 		ldr	r0, .L75+48
 1547 01d4 64309FE5 		ldr	r3, .L75+4
 1548 01d8 0FE0A0E1 		mov	lr, pc
 1549 01dc 13FF2FE1 		bx	r3
 1550              	.LVL33:
 373:main.c        ****   display_unsigned(systick_get_ms() / 1000, 4);
 1551              		.loc 1 373 20
 1552 01e0 88309FE5 		ldr	r3, .L75+52
 1553 01e4 0FE0A0E1 		mov	lr, pc
 1554 01e8 13FF2FE1 		bx	r3
 1555              	.LVL34:
 1556 01ec 0030A0E1 		mov	r3, r0
 1557              		.loc 1 373 3 discriminator 1
 1558 01f0 7C209FE5 		ldr	r2, .L75+56
 1559 01f4 921383E0 		umull	r1, r3, r2, r3
 1560 01f8 2333A0E1 		lsr	r3, r3, #6
 1561 01fc 0410A0E3 		mov	r1, #4
 1562 0200 0300A0E1 		mov	r0, r3
 1563 0204 4C309FE5 		ldr	r3, .L75+28
 1564 0208 0FE0A0E1 		mov	lr, pc
 1565 020c 13FF2FE1 		bx	r3
 1566              	.LVL35:
 374:main.c        ****   display_string("s");
 1567              		.loc 1 374 3
 1568 0210 60009FE5 		ldr	r0, .L75+60
 1569 0214 24309FE5 		ldr	r3, .L75+4
 1570 0218 0FE0A0E1 		mov	lr, pc
 1571 021c 13FF2FE1 		bx	r3
 1572              	.LVL36:
 375:main.c        ****   display_update();
 1573              		.loc 1 375 3
 1574 0220 54309FE5 		ldr	r3, .L75+64
 1575 0224 0FE0A0E1 		mov	lr, pc
 1576 0228 13FF2FE1 		bx	r3
 1577              	.LVL37:
 376:main.c        **** }
 1578              		.loc 1 376 1
 1579 022c 0000A0E1 		nop
 1580 0230 04D04BE2 		sub	sp, fp, #4
 1581              		.cfi_def_cfa 13, 8
 1582              		@ sp needed
 1583 0234 0048BDE8 		pop	{fp, lr}
 1584              		.cfi_restore 14
 1585              		.cfi_restore 11
 1586              		.cfi_def_cfa_offset 0
 1587 0238 1EFF2FE1 		bx	lr
 1588              	.L76:
 1589              		.align	2
 1590              	.L75:
 1591 023c 04000000 		.word	.LC1
 1592 0240 00000000 		.word	display_string
 1593 0244 00000000 		.word	nxt_avr_get_sensor_adc_raw
 1594 0248 00000000 		.word	display_hex
 1595 024c 00000000 		.word	display_goto_xy
 1596 0250 08000000 		.word	.LC2
 1597 0254 00000000 		.word	nxt_avr_get_battery_mv
 1598 0258 00000000 		.word	display_unsigned
 1599 025c 10000000 		.word	.LC3
 1600 0260 14000000 		.word	.LC4
 1601 0264 00000000 		.word	nxt_avr_get_buttons
 1602 0268 00000000 		.word	display_char
 1603 026c 1C000000 		.word	.LC5
 1604 0270 00000000 		.word	systick_get_ms
 1605 0274 D34D6210 		.word	274877907
 1606 0278 24000000 		.word	.LC6
 1607 027c 00000000 		.word	display_update
 1608              		.cfi_endproc
 1609              	.LFE23:
 1611              		.section	.text.task_512ms,"ax",%progbits
 1612              		.align	2
 1613              		.global	task_512ms
 1614              		.syntax unified
 1615              		.arm
 1617              	task_512ms:
 1618              	.LFB24:
 377:main.c        **** void task_512ms(void) {
 1619              		.loc 1 377 23
 1620              		.cfi_startproc
 1621              		@ Function supports interworking.
 1622              		@ args = 0, pretend = 0, frame = 0
 1623              		@ frame_needed = 1, uses_anonymous_args = 0
 1624              		@ link register save eliminated.
 1625 0000 04B02DE5 		str	fp, [sp, #-4]!
 1626              		.cfi_def_cfa_offset 4
 1627              		.cfi_offset 11, -4
 1628 0004 00B08DE2 		add	fp, sp, #0
 1629              		.cfi_def_cfa_register 11
 378:main.c        ****   // Keine blockierende Aufrufe
 379:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 380:main.c        **** }
 1630              		.loc 1 380 1
 1631 0008 0000A0E1 		nop
 1632 000c 00D08BE2 		add	sp, fp, #0
 1633              		.cfi_def_cfa_register 13
 1634              		@ sp needed
 1635 0010 04B09DE4 		ldr	fp, [sp], #4
 1636              		.cfi_restore 11
 1637              		.cfi_def_cfa_offset 0
 1638 0014 1EFF2FE1 		bx	lr
 1639              		.cfi_endproc
 1640              	.LFE24:
 1642              		.section	.text.task_1024ms,"ax",%progbits
 1643              		.align	2
 1644              		.global	task_1024ms
 1645              		.syntax unified
 1646              		.arm
 1648              	task_1024ms:
 1649              	.LFB25:
 381:main.c        **** void task_1024ms(void) {
 1650              		.loc 1 381 24
 1651              		.cfi_startproc
 1652              		@ Function supports interworking.
 1653              		@ args = 0, pretend = 0, frame = 0
 1654              		@ frame_needed = 1, uses_anonymous_args = 0
 1655              		@ link register save eliminated.
 1656 0000 04B02DE5 		str	fp, [sp, #-4]!
 1657              		.cfi_def_cfa_offset 4
 1658              		.cfi_offset 11, -4
 1659 0004 00B08DE2 		add	fp, sp, #0
 1660              		.cfi_def_cfa_register 11
 382:main.c        ****   // Keine blockierende Aufrufe
 383:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 384:main.c        **** }
 1661              		.loc 1 384 1
 1662 0008 0000A0E1 		nop
 1663 000c 00D08BE2 		add	sp, fp, #0
 1664              		.cfi_def_cfa_register 13
 1665              		@ sp needed
 1666 0010 04B09DE4 		ldr	fp, [sp], #4
 1667              		.cfi_restore 11
 1668              		.cfi_def_cfa_offset 0
 1669 0014 1EFF2FE1 		bx	lr
 1670              		.cfi_endproc
 1671              	.LFE25:
 1673              		.section	.rodata
 1674 0026 0000     		.align	2
 1675              	.LC7:
 1676 0028 0A0D3D3D 		.ascii	"\012\015==>ENTER gedr\374ckt: '\000"
 1676      3E454E54 
 1676      45522067 
 1676      656472FC 
 1676      636B743A 
 1677 003f 00       		.align	2
 1678              	.LC8:
 1679 0040 270A0D00 		.ascii	"'\012\015\000"
 1680              		.section	.text.task_idle,"ax",%progbits
 1681              		.align	2
 1682              		.global	task_idle
 1683              		.syntax unified
 1684              		.arm
 1686              	task_idle:
 1687              	.LFB26:
 385:main.c        **** void task_idle(void) {
 1688              		.loc 1 385 22
 1689              		.cfi_startproc
 1690              		@ Function supports interworking.
 1691              		@ args = 0, pretend = 0, frame = 8
 1692              		@ frame_needed = 1, uses_anonymous_args = 0
 1693 0000 00482DE9 		push	{fp, lr}
 1694              		.cfi_def_cfa_offset 8
 1695              		.cfi_offset 11, -8
 1696              		.cfi_offset 14, -4
 1697 0004 04B08DE2 		add	fp, sp, #4
 1698              		.cfi_def_cfa 11, 4
 1699 0008 08D04DE2 		sub	sp, sp, #8
 386:main.c        ****   // Keine blockierende Aufrufe
 387:main.c        ****   // Max. Bearbeitungsdauer: IDLE_MS
 388:main.c        **** 
 389:main.c        ****   // Beispielanwendung für Terminal-Schnittstelle
 390:main.c        ****   unsigned char c;
 391:main.c        ****   static unsigned char string[100];
 392:main.c        ****   static uint8_t strpos = 0;
 393:main.c        **** 
 394:main.c        ****   if (term_read(&c, ASYNCSYNC_NONBLOCK) == 0) {
 1700              		.loc 1 394 7
 1701 000c 05304BE2 		sub	r3, fp, #5
 1702 0010 0010A0E3 		mov	r1, #0
 1703 0014 0300A0E1 		mov	r0, r3
 1704 0018 DC319FE5 		ldr	r3, .L82
 1705 001c 0FE0A0E1 		mov	lr, pc
 1706 0020 13FF2FE1 		bx	r3
 1707              	.LVL38:
 1708 0024 0030A0E1 		mov	r3, r0
 1709              		.loc 1 394 6 discriminator 1
 1710 0028 000053E3 		cmp	r3, #0
 1711 002c 6E00001A 		bne	.L81
 395:main.c        ****     main_data.term_status |=
 396:main.c        ****         term_char(c, ASYNCSYNC_NONBLOCK); // Das empfangene Zeichen als Echo an
 1712              		.loc 1 396 9
 1713 0030 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1714 0034 0010A0E3 		mov	r1, #0
 1715 0038 0300A0E1 		mov	r0, r3
 1716 003c BC319FE5 		ldr	r3, .L82+4
 1717 0040 0FE0A0E1 		mov	lr, pc
 1718 0044 13FF2FE1 		bx	r3
 1719              	.LVL39:
 1720 0048 0030A0E1 		mov	r3, r0
 395:main.c        ****     main_data.term_status |=
 1721              		.loc 1 395 14
 1722 004c B0219FE5 		ldr	r2, .L82+8
 1723 0050 D020D2E1 		ldrsb	r2, [r2]
 395:main.c        ****     main_data.term_status |=
 1724              		.loc 1 395 27
 1725 0054 033CA0E1 		lsl	r3, r3, #24
 1726 0058 433CA0E1 		asr	r3, r3, #24
 1727 005c 033082E1 		orr	r3, r2, r3
 1728 0060 033CA0E1 		lsl	r3, r3, #24
 1729 0064 432CA0E1 		asr	r2, r3, #24
 1730 0068 94319FE5 		ldr	r3, .L82+8
 1731 006c 0020C3E5 		strb	r2, [r3]
 397:main.c        ****                                           // das Terminal zurückschicken
 398:main.c        ****     string[strpos] = c;
 1732              		.loc 1 398 11
 1733 0070 90319FE5 		ldr	r3, .L82+12
 1734 0074 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1735 0078 0320A0E1 		mov	r2, r3
 1736              		.loc 1 398 20
 1737 007c 05105BE5 		ldrb	r1, [fp, #-5]	@ zero_extendqisi2
 1738 0080 84319FE5 		ldr	r3, .L82+16
 1739 0084 0210C3E7 		strb	r1, [r3, r2]
 399:main.c        ****     string[++strpos] = 0;
 1740              		.loc 1 399 12
 1741 0088 78319FE5 		ldr	r3, .L82+12
 1742 008c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1743 0090 013083E2 		add	r3, r3, #1
 1744 0094 FF2003E2 		and	r2, r3, #255
 1745              		.loc 1 399 22
 1746 0098 68319FE5 		ldr	r3, .L82+12
 1747 009c 0020C3E5 		strb	r2, [r3]
 1748              		.loc 1 399 12
 1749 00a0 60319FE5 		ldr	r3, .L82+12
 1750 00a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1751 00a8 0320A0E1 		mov	r2, r3
 1752              		.loc 1 399 22
 1753 00ac 58319FE5 		ldr	r3, .L82+16
 1754 00b0 0010A0E3 		mov	r1, #0
 1755 00b4 0210C3E7 		strb	r1, [r3, r2]
 400:main.c        ****     strpos = strpos >= (sizeof(string) - 1) ? (sizeof(string) - 2) : strpos;
 1756              		.loc 1 400 68
 1757 00b8 48319FE5 		ldr	r3, .L82+12
 1758 00bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1759 00c0 620053E3 		cmp	r3, #98
 1760 00c4 0330A031 		movcc	r3, r3
 1761 00c8 6230A023 		movcs	r3, #98
 1762 00cc FF2003E2 		and	r2, r3, #255
 1763              		.loc 1 400 12
 1764 00d0 30319FE5 		ldr	r3, .L82+12
 1765 00d4 0020C3E5 		strb	r2, [r3]
 401:main.c        **** 
 402:main.c        ****     if (c == '\r') {
 1766              		.loc 1 402 11
 1767 00d8 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1768              		.loc 1 402 8
 1769 00dc 0D0053E3 		cmp	r3, #13
 1770 00e0 4100001A 		bne	.L81
 403:main.c        ****       string[--strpos] = 0;
 1771              		.loc 1 403 14
 1772 00e4 1C319FE5 		ldr	r3, .L82+12
 1773 00e8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1774 00ec 013043E2 		sub	r3, r3, #1
 1775 00f0 FF2003E2 		and	r2, r3, #255
 1776              		.loc 1 403 24
 1777 00f4 0C319FE5 		ldr	r3, .L82+12
 1778 00f8 0020C3E5 		strb	r2, [r3]
 1779              		.loc 1 403 14
 1780 00fc 04319FE5 		ldr	r3, .L82+12
 1781 0100 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1782 0104 0320A0E1 		mov	r2, r3
 1783              		.loc 1 403 24
 1784 0108 FC309FE5 		ldr	r3, .L82+16
 1785 010c 0010A0E3 		mov	r1, #0
 1786 0110 0210C3E7 		strb	r1, [r3, r2]
 404:main.c        ****       main_data.term_status |= term_string("\n\r==>ENTER gedr\xFC"
 1787              		.loc 1 404 32
 1788 0114 0010A0E3 		mov	r1, #0
 1789 0118 F0009FE5 		ldr	r0, .L82+20
 1790 011c F0309FE5 		ldr	r3, .L82+24
 1791 0120 0FE0A0E1 		mov	lr, pc
 1792 0124 13FF2FE1 		bx	r3
 1793              	.LVL40:
 1794 0128 0030A0E1 		mov	r3, r0
 1795              		.loc 1 404 16 discriminator 1
 1796 012c D0209FE5 		ldr	r2, .L82+8
 1797 0130 D020D2E1 		ldrsb	r2, [r2]
 1798              		.loc 1 404 29 discriminator 1
 1799 0134 033CA0E1 		lsl	r3, r3, #24
 1800 0138 433CA0E1 		asr	r3, r3, #24
 1801 013c 033082E1 		orr	r3, r2, r3
 1802 0140 033CA0E1 		lsl	r3, r3, #24
 1803 0144 432CA0E1 		asr	r2, r3, #24
 1804 0148 B4309FE5 		ldr	r3, .L82+8
 1805 014c 0020C3E5 		strb	r2, [r3]
 405:main.c        ****                                            "ckt: '",
 406:main.c        ****                                            ASYNCSYNC_NONBLOCK);
 407:main.c        ****       main_data.term_status |= term_string((char *)string, ASYNCSYNC_NONBLOCK);
 1806              		.loc 1 407 32
 1807 0150 0010A0E3 		mov	r1, #0
 1808 0154 B0009FE5 		ldr	r0, .L82+16
 1809 0158 B4309FE5 		ldr	r3, .L82+24
 1810 015c 0FE0A0E1 		mov	lr, pc
 1811 0160 13FF2FE1 		bx	r3
 1812              	.LVL41:
 1813 0164 0030A0E1 		mov	r3, r0
 1814              		.loc 1 407 16 discriminator 1
 1815 0168 94209FE5 		ldr	r2, .L82+8
 1816 016c D020D2E1 		ldrsb	r2, [r2]
 1817              		.loc 1 407 29 discriminator 1
 1818 0170 033CA0E1 		lsl	r3, r3, #24
 1819 0174 433CA0E1 		asr	r3, r3, #24
 1820 0178 033082E1 		orr	r3, r2, r3
 1821 017c 033CA0E1 		lsl	r3, r3, #24
 1822 0180 432CA0E1 		asr	r2, r3, #24
 1823 0184 78309FE5 		ldr	r3, .L82+8
 1824 0188 0020C3E5 		strb	r2, [r3]
 408:main.c        ****       main_data.term_status |= term_string("'\n\r", ASYNCSYNC_NONBLOCK);
 1825              		.loc 1 408 32
 1826 018c 0010A0E3 		mov	r1, #0
 1827 0190 80009FE5 		ldr	r0, .L82+28
 1828 0194 78309FE5 		ldr	r3, .L82+24
 1829 0198 0FE0A0E1 		mov	lr, pc
 1830 019c 13FF2FE1 		bx	r3
 1831              	.LVL42:
 1832 01a0 0030A0E1 		mov	r3, r0
 1833              		.loc 1 408 16 discriminator 1
 1834 01a4 58209FE5 		ldr	r2, .L82+8
 1835 01a8 D020D2E1 		ldrsb	r2, [r2]
 1836              		.loc 1 408 29 discriminator 1
 1837 01ac 033CA0E1 		lsl	r3, r3, #24
 1838 01b0 433CA0E1 		asr	r3, r3, #24
 1839 01b4 033082E1 		orr	r3, r2, r3
 1840 01b8 033CA0E1 		lsl	r3, r3, #24
 1841 01bc 432CA0E1 		asr	r2, r3, #24
 1842 01c0 3C309FE5 		ldr	r3, .L82+8
 1843 01c4 0020C3E5 		strb	r2, [r3]
 409:main.c        ****       // oberen 128 ASCII zeichen des Terminal-Fensters sind wie folgt codiert
 410:main.c        ****       // https://en.wikipedia.org/wiki/VT100_encoding
 411:main.c        **** 
 412:main.c        ****       strpos = 0;
 1844              		.loc 1 412 14
 1845 01c8 38309FE5 		ldr	r3, .L82+12
 1846 01cc 0020A0E3 		mov	r2, #0
 1847 01d0 0020C3E5 		strb	r2, [r3]
 413:main.c        ****       string[strpos] = 0;
 1848              		.loc 1 413 13
 1849 01d4 2C309FE5 		ldr	r3, .L82+12
 1850 01d8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1851 01dc 0320A0E1 		mov	r2, r3
 1852              		.loc 1 413 22
 1853 01e0 24309FE5 		ldr	r3, .L82+16
 1854 01e4 0010A0E3 		mov	r1, #0
 1855 01e8 0210C3E7 		strb	r1, [r3, r2]
 1856              	.L81:
 414:main.c        ****     }
 415:main.c        ****   }
 416:main.c        **** }
 1857              		.loc 1 416 1
 1858 01ec 0000A0E1 		nop
 1859 01f0 04D04BE2 		sub	sp, fp, #4
 1860              		.cfi_def_cfa 13, 8
 1861              		@ sp needed
 1862 01f4 0048BDE8 		pop	{fp, lr}
 1863              		.cfi_restore 14
 1864              		.cfi_restore 11
 1865              		.cfi_def_cfa_offset 0
 1866 01f8 1EFF2FE1 		bx	lr
 1867              	.L83:
 1868              		.align	2
 1869              	.L82:
 1870 01fc 00000000 		.word	term_read
 1871 0200 00000000 		.word	term_char
 1872 0204 00000000 		.word	main_data
 1873 0208 70040000 		.word	strpos.3
 1874 020c 74040000 		.word	string.2
 1875 0210 28000000 		.word	.LC7
 1876 0214 00000000 		.word	term_string
 1877 0218 40000000 		.word	.LC8
 1878              		.cfi_endproc
 1879              	.LFE26:
 1881              		.section	.text.premain_init,"ax",%progbits
 1882              		.align	2
 1883              		.global	premain_init
 1884              		.syntax unified
 1885              		.arm
 1887              	premain_init:
 1888              	.LFB27:
 417:main.c        **** /*****************************************************************************/
 418:main.c        **** /*    Pre-Main-Funktion                                                      */
 419:main.c        **** /*****************************************************************************/
 420:main.c        **** // Zur Vermeidung von malloc(1024) bei der ersten Ausgabe über stdout!
 421:main.c        **** //__attribute__(constructor) stellt sicher, dass premain_init() direkt nach
 422:main.c        **** //__sinit() aufgerufen wird (beides innerhalb von __libc_init_array())
 423:main.c        **** void __attribute__((constructor)) premain_init(void) {
 1889              		.loc 1 423 54
 1890              		.cfi_startproc
 1891              		@ Function supports interworking.
 1892              		@ args = 0, pretend = 0, frame = 0
 1893              		@ frame_needed = 1, uses_anonymous_args = 0
 1894 0000 30482DE9 		push	{r4, r5, fp, lr}
 1895              		.cfi_def_cfa_offset 16
 1896              		.cfi_offset 4, -16
 1897              		.cfi_offset 5, -12
 1898              		.cfi_offset 11, -8
 1899              		.cfi_offset 14, -4
 1900 0004 0CB08DE2 		add	fp, sp, #12
 1901              		.cfi_def_cfa 11, 4
 424:main.c        **** #if 0
 425:main.c        **** 	//No linebuffering, call stdio_write() immediately
 426:main.c        **** 	//-> Langsam, da mit jedem Zeichen __sflush_r()/_write()/stdio_write() aufgerufen wird 
 427:main.c        **** 	setvbuf(stdout,NULL,_IONBF,0);
 428:main.c        **** #else
 429:main.c        ****   static char linebuf[10];
 430:main.c        ****   // LineBuffering into global Varialbe (guter Kompromiss)
 431:main.c        ****   setvbuf(stdout, linebuf, _IOLBF, sizeof(linebuf)); // Linebuffering in
 1902              		.loc 1 431 11
 1903 0008 2C309FE5 		ldr	r3, .L85
 1904 000c 003093E5 		ldr	r3, [r3]
 1905 0010 080093E5 		ldr	r0, [r3, #8]
 1906              		.loc 1 431 3
 1907 0014 0A30A0E3 		mov	r3, #10
 1908 0018 0120A0E3 		mov	r2, #1
 1909 001c 1C109FE5 		ldr	r1, .L85+4
 1910 0020 1C409FE5 		ldr	r4, .L85+8
 1911 0024 0FE0A0E1 		mov	lr, pc
 1912 0028 14FF2FE1 		bx	r4
 1913              	.LVL43:
 432:main.c        **** #endif
 433:main.c        **** }
 1914              		.loc 1 433 1
 1915 002c 0000A0E1 		nop
 1916 0030 0CD04BE2 		sub	sp, fp, #12
 1917              		.cfi_def_cfa 13, 16
 1918              		@ sp needed
 1919 0034 3048BDE8 		pop	{r4, r5, fp, lr}
 1920              		.cfi_restore 14
 1921              		.cfi_restore 11
 1922              		.cfi_restore 5
 1923              		.cfi_restore 4
 1924              		.cfi_def_cfa_offset 0
 1925 0038 1EFF2FE1 		bx	lr
 1926              	.L86:
 1927              		.align	2
 1928              	.L85:
 1929 003c 00000000 		.word	_impure_ptr
 1930 0040 D8040000 		.word	linebuf.1
 1931 0044 00000000 		.word	setvbuf
 1932              		.cfi_endproc
 1933              	.LFE27:
 1935              		.section	.init_array,"aw",%init_array
 1936              		.align	2
 1937 0000 00000000 		.word	premain_init(target1)
 1938              		.section	.rodata
 1939              		.align	2
 1940              	.LC9:
 1941 0044 64656D6F 		.ascii	"demo : 20:39:38\000"
 1941      203A2032 
 1941      303A3339 
 1941      3A333800 
 1942              		.align	2
 1943              	.LC10:
 1944 0054 1B5B324A 		.ascii	"\033[2J\033[H\033[0m\000"
 1944      1B5B481B 
 1944      5B306D00 
 1945              		.align	2
 1946              	.LC11:
 1947 0060 50726F67 		.ascii	"Prog: demo\012\015Version von: Oct  9 2025 20:39:38"
 1947      3A206465 
 1947      6D6F0A0D 
 1947      56657273 
 1947      696F6E20 
 1948 008d 0A0D00   		.ascii	"\012\015\000"
 1949              		.align	2
 1950              	.LC12:
 1951 0090 27762E64 		.ascii	"'v.draw %e trace_buf0 trace_buf1' zum oeffnen eines"
 1951      72617720 
 1951      25652074 
 1951      72616365 
 1951      5F627566 
 1952 00c3 20274F73 		.ascii	" 'Oszilloskop'\012\015\000"
 1952      7A696C6C 
 1952      6F736B6F 
 1952      70270A0D 
 1952      00
 1953              		.align	2
 1954              	.LC13:
 1955 00d4 27646F20 		.ascii	"'do trace_scope' zum oeffnen eines 'Oszilloskop'\012"
 1955      74726163 
 1955      655F7363 
 1955      6F706527 
 1955      207A756D 
 1956 0105 0D00     		.ascii	"\015\000"
 1957 0107 00       		.align	2
 1958              	.LC14:
 1959 0108 4E585420 		.ascii	"NXT Display Fenster am besten schliessen\012\015\000"
 1959      44697370 
 1959      6C617920 
 1959      46656E73 
 1959      74657220 
 1960 0133 00       		.align	2
 1961              	.LC15:
 1962 0134 5669656C 		.ascii	"Viel Erfolg!\012\015\000"
 1962      20457266 
 1962      6F6C6721 
 1962      0A0D00
 1963 0143 00       		.align	2
 1964              	.LC16:
 1965 0144 00       		.ascii	"\000"
 1966 0145 000000   		.align	2
 1967              	.LC17:
 1968 0148 386D7300 		.ascii	"8ms\000"
 1969              		.align	2
 1970              	.LC18:
 1971 014c 31366D73 		.ascii	"16ms\000"
 1971      00
 1972 0151 000000   		.align	2
 1973              	.LC19:
 1974 0154 33326D73 		.ascii	"32ms\000"
 1974      00
 1975 0159 000000   		.align	2
 1976              	.LC20:
 1977 015c 36346D73 		.ascii	"64ms\000"
 1977      00
 1978 0161 000000   		.align	2
 1979              	.LC21:
 1980 0164 3132386D 		.ascii	"128ms\000"
 1980      7300
 1981 016a 0000     		.align	2
 1982              	.LC22:
 1983 016c 3235366D 		.ascii	"256ms\000"
 1983      7300
 1984 0172 0000     		.align	2
 1985              	.LC23:
 1986 0174 3531326D 		.ascii	"512ms\000"
 1986      7300
 1987 017a 0000     		.align	2
 1988              	.LC24:
 1989 017c 31303234 		.ascii	"1024ms\000"
 1989      6D7300
 1990 0183 00       		.align	2
 1991              	.LC25:
 1992 0184 49646C65 		.ascii	"Idle\000"
 1992      00
 1993 0189 000000   		.align	2
 1994              	.LC26:
 1995 018c 1B5B3331 		.ascii	"\033[31mTiming durch '\000"
 1995      6D54696D 
 1995      696E6720 
 1995      64757263 
 1995      68202700 
 1996              		.align	2
 1997              	.LC27:
 1998 01a0 27207665 		.ascii	"' verletzt\012\015\033[39m\000"
 1998      726C6574 
 1998      7A740A0D 
 1998      1B5B3339 
 1998      6D00
 1999 01b2 0000     		.align	2
 2000              	.LC28:
 2001 01b4 1B5B3331 		.ascii	"\033[31mStack overflow durch '\000"
 2001      6D537461 
 2001      636B206F 
 2001      76657266 
 2001      6C6F7720 
 2002              		.align	2
 2003              	.LC29:
 2004 01d0 270A0D1B 		.ascii	"'\012\015\033[39m\000"
 2004      5B33396D 
 2004      00
 2005 01d9 000000   		.align	2
 2006              	.LC30:
 2007 01dc 1B5B3331 		.ascii	"\033[31m\012\015Low Battery\012\015\033[39m\000"
 2007      6D0A0D4C 
 2007      6F772042 
 2007      61747465 
 2007      72790A0D 
 2008 01f6 0000     		.align	2
 2009              	.LC31:
 2010 01f8 1B5B3331 		.ascii	"\033[31m\012\015Terminal Overflow\012\015\033[39m\000"
 2010      6D0A0D54 
 2010      65726D69 
 2010      6E616C20 
 2010      4F766572 
 2011              		.section	.text.main,"ax",%progbits
 2012              		.align	2
 2013              		.global	main
 2014              		.syntax unified
 2015              		.arm
 2017              	main:
 2018              	.LFB28:
 434:main.c        **** /*****************************************************************************/
 435:main.c        **** /*    Main-Funktion                                                          */
 436:main.c        **** /*****************************************************************************/
 437:main.c        **** #if 0
 438:main.c        **** //Variante 1: Deklaration der main() Funktion
 439:main.c        **** //da es keine CLI gibt, über welcher die Anwendung getartet wird
 440:main.c        **** //sondern der start über startup.s erfolgt, macht dies kein Sinn
 441:main.c        **** //und belegt unnötige Speicherplatz auf den Stack
 442:main.c        **** int main(int argc, char *argv[]) 
 443:main.c        **** {
 444:main.c        **** 	(void) argc;
 445:main.c        **** 	(void) argv;
 446:main.c        **** #else
 447:main.c        **** // Variante 2: Deklaration der main() funktion
 448:main.c        **** int main(void) {
 2019              		.loc 1 448 16
 2020              		.cfi_startproc
 2021              		@ Function supports interworking.
 2022              		@ args = 0, pretend = 0, frame = 24
 2023              		@ frame_needed = 1, uses_anonymous_args = 0
 2024 0000 00482DE9 		push	{fp, lr}
 2025              		.cfi_def_cfa_offset 8
 2026              		.cfi_offset 11, -8
 2027              		.cfi_offset 14, -4
 2028 0004 04B08DE2 		add	fp, sp, #4
 2029              		.cfi_def_cfa 11, 4
 2030 0008 18D04DE2 		sub	sp, sp, #24
 449:main.c        **** #endif
 450:main.c        ****   /* Interrupts zu diesem Zeitpunkt disabled !!!! */
 451:main.c        **** 
 452:main.c        ****   /* 'Pflicht' Initialisierung, können nicht ausgelassen werden */
 453:main.c        ****   aic_init();          // Interrupt-Controller initialisieren
 2031              		.loc 1 453 3
 2032 000c E4359FE5 		ldr	r3, .L116
 2033 0010 0FE0A0E1 		mov	lr, pc
 2034 0014 13FF2FE1 		bx	r3
 2035              	.LVL44:
 454:main.c        ****   systick_init();      // System-Timer initialisieren
 2036              		.loc 1 454 3
 2037 0018 DC359FE5 		ldr	r3, .L116+4
 2038 001c 0FE0A0E1 		mov	lr, pc
 2039 0020 13FF2FE1 		bx	r3
 2040              	.LVL45:
 455:main.c        ****   interrupts_enable(); // Ohne Worte
 2041              		.loc 1 455 3
 2042 0024 D4359FE5 		ldr	r3, .L116+8
 2043 0028 0FE0A0E1 		mov	lr, pc
 2044 002c 13FF2FE1 		bx	r3
 2045              	.LVL46:
 456:main.c        ****   nxt_avr_init(8);
 2046              		.loc 1 456 3
 2047 0030 0800A0E3 		mov	r0, #8
 2048 0034 C8359FE5 		ldr	r3, .L116+12
 2049 0038 0FE0A0E1 		mov	lr, pc
 2050 003c 13FF2FE1 		bx	r3
 2051              	.LVL47:
 457:main.c        **** #if defined(MODE_RAM) || defined(MODE_SIM)
 458:main.c        ****   udmon3_init(); // Speicherzugriff durch den Debugger
 2052              		.loc 1 458 3
 2053 0040 C0359FE5 		ldr	r3, .L116+16
 2054 0044 0FE0A0E1 		mov	lr, pc
 2055 0048 13FF2FE1 		bx	r3
 2056              	.LVL48:
 459:main.c        ****                  // zur Programmlaufzeit mittels der
 460:main.c        ****                  // DCC Schnittstelle ermöglichen
 461:main.c        **** #endif
 462:main.c        **** 
 463:main.c        ****   /* 'Wahl' Initialisierung, hängt von den benötigten Komponenten ab */
 464:main.c        ****   term_init();
 2057              		.loc 1 464 3
 2058 004c B8359FE5 		ldr	r3, .L116+20
 2059 0050 0FE0A0E1 		mov	lr, pc
 2060 0054 13FF2FE1 		bx	r3
 2061              	.LVL49:
 465:main.c        ****   display_init();
 2062              		.loc 1 465 3
 2063 0058 B0359FE5 		ldr	r3, .L116+24
 2064 005c 0FE0A0E1 		mov	lr, pc
 2065 0060 13FF2FE1 		bx	r3
 2066              	.LVL50:
 466:main.c        ****   display_clear(0);
 2067              		.loc 1 466 3
 2068 0064 0000A0E3 		mov	r0, #0
 2069 0068 A4359FE5 		ldr	r3, .L116+28
 2070 006c 0FE0A0E1 		mov	lr, pc
 2071 0070 13FF2FE1 		bx	r3
 2072              	.LVL51:
 467:main.c        ****   display_string(APP_NAME " : " __TIME__);
 2073              		.loc 1 467 3
 2074 0074 9C059FE5 		ldr	r0, .L116+32
 2075 0078 9C359FE5 		ldr	r3, .L116+36
 2076 007c 0FE0A0E1 		mov	lr, pc
 2077 0080 13FF2FE1 		bx	r3
 2078              	.LVL52:
 468:main.c        ****   display_update();
 2079              		.loc 1 468 3
 2080 0084 94359FE5 		ldr	r3, .L116+40
 2081 0088 0FE0A0E1 		mov	lr, pc
 2082 008c 13FF2FE1 		bx	r3
 2083              	.LVL53:
 469:main.c        **** 
 470:main.c        ****   // ANSI Escape sequences - VT100 / VT52 (see main.h)
 471:main.c        ****   (void)term_string(
 2084              		.loc 1 471 9
 2085 0090 0110A0E3 		mov	r1, #1
 2086 0094 88059FE5 		ldr	r0, .L116+44
 2087 0098 88359FE5 		ldr	r3, .L116+48
 2088 009c 0FE0A0E1 		mov	lr, pc
 2089 00a0 13FF2FE1 		bx	r3
 2090              	.LVL54:
 472:main.c        ****       "\033[2J" VT100_CURSORHOME // Move Cursor to home position (0,0)
 473:main.c        ****           VT100_DEFAULT,
 474:main.c        ****       ASYNCSYNC_BLOCK);
 475:main.c        ****   (void)term_string("Prog: " APP_NAME "\n\rVersion von: " __DATE__ " " __TIME__
 2091              		.loc 1 475 9
 2092 00a4 0110A0E3 		mov	r1, #1
 2093 00a8 7C059FE5 		ldr	r0, .L116+52
 2094 00ac 74359FE5 		ldr	r3, .L116+48
 2095 00b0 0FE0A0E1 		mov	lr, pc
 2096 00b4 13FF2FE1 		bx	r3
 2097              	.LVL55:
 476:main.c        ****                     "\n\r",
 477:main.c        ****                     ASYNCSYNC_BLOCK);
 478:main.c        ****   (void)term_string(
 2098              		.loc 1 478 9
 2099 00b8 0110A0E3 		mov	r1, #1
 2100 00bc 6C059FE5 		ldr	r0, .L116+56
 2101 00c0 60359FE5 		ldr	r3, .L116+48
 2102 00c4 0FE0A0E1 		mov	lr, pc
 2103 00c8 13FF2FE1 		bx	r3
 2104              	.LVL56:
 479:main.c        ****       "'v.draw %e trace_buf0 trace_buf1' zum oeffnen eines 'Oszilloskop'\n\r",
 480:main.c        ****       ASYNCSYNC_BLOCK);
 481:main.c        ****   (void)term_string("'do trace_scope' zum oeffnen eines 'Oszilloskop'\n\r",
 2105              		.loc 1 481 9
 2106 00cc 0110A0E3 		mov	r1, #1
 2107 00d0 5C059FE5 		ldr	r0, .L116+60
 2108 00d4 4C359FE5 		ldr	r3, .L116+48
 2109 00d8 0FE0A0E1 		mov	lr, pc
 2110 00dc 13FF2FE1 		bx	r3
 2111              	.LVL57:
 482:main.c        ****                     ASYNCSYNC_BLOCK);
 483:main.c        ****   (void)term_string("NXT Display Fenster am besten schliessen\n\r",
 2112              		.loc 1 483 9
 2113 00e0 0110A0E3 		mov	r1, #1
 2114 00e4 4C059FE5 		ldr	r0, .L116+64
 2115 00e8 38359FE5 		ldr	r3, .L116+48
 2116 00ec 0FE0A0E1 		mov	lr, pc
 2117 00f0 13FF2FE1 		bx	r3
 2118              	.LVL58:
 484:main.c        ****                     ASYNCSYNC_BLOCK);
 485:main.c        ****   (void)term_string("Viel Erfolg!\n\r", ASYNCSYNC_BLOCK);
 2119              		.loc 1 485 9
 2120 00f4 0110A0E3 		mov	r1, #1
 2121 00f8 3C059FE5 		ldr	r0, .L116+68
 2122 00fc 24359FE5 		ldr	r3, .L116+48
 2123 0100 0FE0A0E1 		mov	lr, pc
 2124 0104 13FF2FE1 		bx	r3
 2125              	.LVL59:
 486:main.c        **** 
 487:main.c        ****   // Alternativ zu term_xxx() kann auch printf() oder noch besser iprintf
 488:main.c        ****   // genutzt werden beide bedingen jedoch einen großen Speicherbedarf!
 489:main.c        ****   // Alternativ zu term_read() kann auch scanf() genutzt werden. Auch diese
 490:main.c        ****   // Funktion
 491:main.c        ****   //  bedingt einen großen Speicherbedarf
 492:main.c        **** 
 493:main.c        **** #ifndef MODE_ROM
 494:main.c        ****   /* Watchdog Disable */
 495:main.c        ****   /* Mode-Register kann nur einmal beschrieben werden */
 496:main.c        ****   AT91C_BASE_WDTC->WDTC_WDMR = 0xFFF | AT91C_WDTC_WDDIS | /*WD Disable */
 2126              		.loc 1 496 18
 2127 0108 30359FE5 		ldr	r3, .L116+72
 2128              		.loc 1 496 30
 2129 010c 30259FE5 		ldr	r2, .L116+76
 2130 0110 042083E5 		str	r2, [r3, #4]
 2131              	.LBB8:
 2132              	.LBB9:
 2133              		.file 4 "lib/../main.h"
   1:lib/../main.h **** #ifndef main_h
   2:lib/../main.h **** #define main_h
   3:lib/../main.h **** #include <stdint.h>
   4:lib/../main.h **** 
   5:lib/../main.h **** //ASCII-Zeichen
   6:lib/../main.h **** //\a The “alert” character, Ctrl-g, ASCII code 7 (BEL). (This usually makes some sort of audibl
   7:lib/../main.h **** //\b Backspace, Ctrl-h, ASCII code 8 (BS).
   8:lib/../main.h **** //\f Formfeed, Ctrl-l, ASCII code 12 (FF).
   9:lib/../main.h **** //\n Newline, Ctrl-j, ASCII code 10 (LF).
  10:lib/../main.h **** //\r Carriage return, Ctrl-m, ASCII code 13 (CR).
  11:lib/../main.h **** //\t Horizontal TAB, Ctrl-i, ASCII code 9 (HT).
  12:lib/../main.h **** //\v Vertical tab, Ctrl-k, ASCII code 11 (VT).
  13:lib/../main.h **** //\nnn The octal value nnn, where nnn stands for 1 to 3 digits between ‘0’ and ‘7’. For exa
  14:lib/../main.h **** //\xhh...The hexadecimal value hh, where hh stands for a sequence of hexadecimal digits (‘0’–
  15:lib/../main.h **** //       Like the same construct in ISO C, the escape sequence continues until 
  16:lib/../main.h **** //       the first nonhexadecimal digit is seen. (c.e.) However, using more 
  17:lib/../main.h **** //       than two hexadecimal digits produces undefined results. 
  18:lib/../main.h **** //       (The ‘\x’ escape sequence is not allowed in POSIX awk.)
  19:lib/../main.h **** //\/ A literal slash (necessary for regexp constants only). This sequence 
  20:lib/../main.h **** //       is used when you want to write a regexp constant that contains a 
  21:lib/../main.h **** //       slash. Because the regexp is delimited by slashes, you need to 
  22:lib/../main.h **** //       escape the slash that is part of the pattern, in order to tell 
  23:lib/../main.h **** //       awk to keep processing the rest of the regexp.
  24:lib/../main.h **** //\"  A literal double quote (necessary for string constants only). 
  25:lib/../main.h **** //       This sequence is used when you want to write a string constant 
  26:lib/../main.h **** //       that contains a double quote. Because the string is delimited by 
  27:lib/../main.h **** //       double quotes, you need to escape the quote that is part of 
  28:lib/../main.h **** //       the string, in order to tell awk to keep processing the rest
  29:lib/../main.h **** //       of the string.#define ANSI_BLACK   30
  30:lib/../main.h **** 
  31:lib/../main.h **** //https://www-user.tu-chemnitz.de/~heha/hsn/terminal/terminal.htm
  32:lib/../main.h **** //https://gist.github.com/ConnerWill/d4b6c776b509add763e17f9f113fd25b
  33:lib/../main.h **** //Cursor Control
  34:lib/../main.h **** #define VT100_CURSORHOME      "\e[H"
  35:lib/../main.h **** #define VT100_CLEARSCREEN     "\e[2J"
  36:lib/../main.h **** #define VT100_GOTOYX          "\e[%d;%dH"
  37:lib/../main.h **** #define VT100_SAVEPOS         "\e7"
  38:lib/../main.h **** #define VT100_RESTOREPOS      "\e8"
  39:lib/../main.h **** #define VT100_ROLLY1Y2        "\e[%d;%dr"
  40:lib/../main.h **** #define VT100_ROLLOFF         "\e[r"
  41:lib/../main.h **** //Erase Functions
  42:lib/../main.h **** #define VT100_ERASEFROMCURSOR "\e[0J"
  43:lib/../main.h **** #define VT100_ERASETOCURSOR   "\e[1J"
  44:lib/../main.h **** #define VT100_ERASESCREEN     "\e[2J"
  45:lib/../main.h **** #define VT100_DEL_UNTILEOL    "\e[K"
  46:lib/../main.h **** #define VT100_DEL_TOCUR       "\e[1K"
  47:lib/../main.h **** #define VT100_DEL_LINE        "\e[2K"
  48:lib/../main.h **** //Color/Graphics Mode
  49:lib/../main.h **** #define VT100_DEFAULT         "\e[0m"  //stellt hellgraue Schrift auf schwarzem Grund ein
  50:lib/../main.h **** #define VT100_FETT              "\e[1m"
  51:lib/../main.h **** #define VT100_FETT_AUS          "\e[22m"
  52:lib/../main.h **** #define VT100_UNTERSTRICHEN     "\e[4m"
  53:lib/../main.h **** #define VT100_UNTERSTRICHEN_AUS "\e[24m"
  54:lib/../main.h **** #define VT100_BLINKEN           "\e[5m"
  55:lib/../main.h **** #define VT100_BLINKEN_AUS       "\e[25m"
  56:lib/../main.h **** #define VT100_INVERS            "\e[7m"
  57:lib/../main.h **** #define VT100_INVERS_AUS        "\e[27m"
  58:lib/../main.h **** #define VT100_UNSICHTBAR        "\e[8m"
  59:lib/../main.h **** #define VT100_SICHTBAR          "\e[28m"
  60:lib/../main.h **** #define VT100_VORDERGRUND_SCHWARZ "\e[30m"
  61:lib/../main.h **** #define VT100_VORDERGRUND_ROT     "\e[31m"
  62:lib/../main.h **** #define VT100_VORDERGRUND_GRUEN   "\e[32m"
  63:lib/../main.h **** #define VT100_VORDERGRUND_BRAUN   "\e[33m"
  64:lib/../main.h **** #define VT100_VORDERGRUND_BLAU    "\e[34m"
  65:lib/../main.h **** #define VT100_VORDERGRUND_BLAUROT "\e[35m"
  66:lib/../main.h **** #define VT100_VORDERGRUND_ZYAN    "\e[36m"
  67:lib/../main.h **** #define VT100_VORDERGRUND_WEISS   "\e[37m"  //Default
  68:lib/../main.h **** #define VT100_VORDERGRUND_DEFAULT "\e[39m"  //Nicht VT100
  69:lib/../main.h **** #define VT100_HINTERGRUND_SCHWARZ "\e[40m"  //Default
  70:lib/../main.h **** #define VT100_HINTERGRUND_ROT     "\e[41m"  
  71:lib/../main.h **** #define VT100_HINTERGRUND_GRUEN   "\e[42m"  
  72:lib/../main.h **** #define VT100_HINTERGRUND_BRAUN   "\e[43m"  
  73:lib/../main.h **** #define VT100_HINTERGRUND_BLAU    "\e[44m"  
  74:lib/../main.h **** #define VT100_HINTERGRUND_BLAUROT "\e[45m"  
  75:lib/../main.h **** #define VT100_HINTERGRUND_ZYAN    "\e[46m"  
  76:lib/../main.h **** #define VT100_HINTERGRUND_WEISS   "\e[47m"  
  77:lib/../main.h **** #define VT100_HINTERGRUND_DEFAULT "\e[49m"
  78:lib/../main.h **** 
  79:lib/../main.h ****                                                          /* Main Clock [Hz] */
  80:lib/../main.h **** #define MAINCK            18432000
  81:lib/../main.h ****                                      /* Maseter Clock (PLLRC div by 2) [Hz] */
  82:lib/../main.h **** #define MCK               47923200
  83:lib/../main.h ****                                              /* System clock tick rate [Hz] */
  84:lib/../main.h **** #define BSP_TICKS_PER_SEC 1000
  85:lib/../main.h **** 
  86:lib/../main.h **** //#define NODISCARD __attribute__((warn_unused_result))  
  87:lib/../main.h **** #define NODISCARD  [[nodiscard]]
  88:lib/../main.h **** 
  89:lib/../main.h **** typedef enum __attribute__((packed)) {ASYNCSYNC_NONBLOCK,ASYNCSYNC_BLOCK,ASYNCSYNC_ASYNCGET} asyncs
  90:lib/../main.h **** 
  91:lib/../main.h **** typedef enum {SENSOR_1,SENSOR_2,SENSOR_3,SENSOR_4,SENSOR_MAX} sensor_t;
  92:lib/../main.h **** 
  93:lib/../main.h **** typedef enum {MOTOR_A,MOTOR_B,MOTOR_C} motor_t;
  94:lib/../main.h **** 
  95:lib/../main.h **** typedef enum {MOTOR_BREAK, MOTOR_FLOAT} motor_zustand_t;
  96:lib/../main.h **** 
  97:lib/../main.h **** typedef enum {SENSOR_OFF=0x00, SENSOR_9V_PULSED=0x01, SENSOR_9V=0x10 } sensor_power_t;
  98:lib/../main.h **** 
  99:lib/../main.h **** typedef enum {BATTERY_AA, BATTERY_ACCU} battery_t;
 100:lib/../main.h **** 
 101:lib/../main.h **** typedef struct {
 102:lib/../main.h **** 	uint8_t orange : 1;
 103:lib/../main.h **** 	uint8_t left : 1;
 104:lib/../main.h **** 	uint8_t right : 1;
 105:lib/../main.h **** 	uint8_t grey : 1;
 106:lib/../main.h **** 	uint8_t reserved : 4;
 107:lib/../main.h **** } button_t;
 108:lib/../main.h **** 
 109:lib/../main.h **** #define I2C_BAUDRATE 10000  //Orignal 9600
 110:lib/../main.h **** 
 111:lib/../main.h **** extern uint32_t __stack_start__[];   //Definiert in link.ld
 112:lib/../main.h **** extern uint32_t __stack_end__;       //Definiert in link.ld
 113:lib/../main.h **** #define STACK_FILL 0x11111111
 114:lib/../main.h **** 
 115:lib/../main.h **** static __inline__ void stack_fill(void) __attribute__((always_inline));
 116:lib/../main.h **** static __inline__ void stack_fill(void)
 117:lib/../main.h **** {
 118:lib/../main.h **** 	         uint32_t *ptr;
 119:lib/../main.h **** 	register uint32_t *sp asm("r13");
 120:lib/../main.h **** 	for(ptr=&__stack_start__[0];ptr<sp;ptr++)
 2134              		.loc 4 120 9
 2135 0114 2C359FE5 		ldr	r3, .L116+80
 2136 0118 14300BE5 		str	r3, [fp, #-20]
 2137              		.loc 4 120 2
 2138 011c 050000EA 		b	.L88
 2139              	.L89:
 121:lib/../main.h **** 		*ptr=STACK_FILL;
 2140              		.loc 4 121 7
 2141 0120 14301BE5 		ldr	r3, [fp, #-20]
 2142 0124 20259FE5 		ldr	r2, .L116+84
 2143 0128 002083E5 		str	r2, [r3]
 120:lib/../main.h **** 		*ptr=STACK_FILL;
 2144              		.loc 4 120 40 discriminator 3
 2145 012c 14301BE5 		ldr	r3, [fp, #-20]
 2146 0130 043083E2 		add	r3, r3, #4
 2147 0134 14300BE5 		str	r3, [fp, #-20]
 2148              	.L88:
 120:lib/../main.h **** 		*ptr=STACK_FILL;
 2149              		.loc 4 120 33 discriminator 1
 2150 0138 0D20A0E1 		mov	r2, sp
 2151 013c 14301BE5 		ldr	r3, [fp, #-20]
 2152 0140 020053E1 		cmp	r3, r2
 2153 0144 F5FFFF3A 		bcc	.L89
 122:lib/../main.h **** }
 2154              		.loc 4 122 1
 2155 0148 0000A0E1 		nop
 2156              	.L90:
 2157              	.LBE9:
 2158              	.LBE8:
 497:main.c        ****                                AT91C_WDTC_WDDBGHLT |      /*Debug Halt */
 498:main.c        ****                                AT91C_WDTC_WDIDLEHLT;      /*Idle Halt  */
 499:main.c        **** #else
 500:main.c        **** #if 0
 501:main.c        **** 	/* Watchdog Enable */
 502:main.c        **** 	/* Da in dieser Version kein zyklischer Reset des Watchdogs */
 503:main.c        **** 	/* vorhanden ist, wird von einem Watchdog Enable abgesehen  */
 504:main.c        **** 	/* Mit Reset wird der Wachdog aktiviert!                    */
 505:main.c        **** #else
 506:main.c        **** /* Watchdog Disable */
 507:main.c        **** /* Mode-Register kann nur einmal beschrieben werden */
 508:main.c        **** AT91C_BASE_WDTC->WDTC_WDMR = 0xFFF | AT91C_WDTC_WDDIS | /*WD Disable */
 509:main.c        ****                              AT91C_WDTC_WDDBGHLT |      /*Debug Halt */
 510:main.c        ****                              AT91C_WDTC_WDIDLEHLT;      /*Idle Halt  */
 511:main.c        **** #endif
 512:main.c        **** #endif
 513:main.c        ****   // Vorangegangenen Stackaufbau 'löschen'
 514:main.c        ****   stack_fill();
 515:main.c        ****   // Label, so das mit 'go start' hierin gesprungen werden kann
 516:main.c        **** start:
 517:main.c        ****   __attribute__((unused));
 518:main.c        ****   uint32_t start_tick = systick_get_ms();
 2159              		.loc 1 518 25
 2160 014c FC349FE5 		ldr	r3, .L116+88
 2161 0150 0FE0A0E1 		mov	lr, pc
 2162 0154 13FF2FE1 		bx	r3
 2163              	.LVL60:
 2164 0158 08000BE5 		str	r0, [fp, #-8]
 519:main.c        ****   uint32_t zeitscheibe = 0;
 2165              		.loc 1 519 12
 2166 015c 0030A0E3 		mov	r3, #0
 2167 0160 0C300BE5 		str	r3, [fp, #-12]
 520:main.c        ****   char *task_aktiv = "";
 2168              		.loc 1 520 9
 2169 0164 E8349FE5 		ldr	r3, .L116+92
 2170 0168 10300BE5 		str	r3, [fp, #-16]
 2171              	.L115:
 521:main.c        ****   while (1) {
 522:main.c        ****     // Warten bis zum nächsten TimeSlot
 523:main.c        ****     while ((int)(start_tick - systick_get_ms()) > 0)
 2172              		.loc 1 523 11
 2173 016c 0000A0E1 		nop
 2174              	.L91:
 2175              		.loc 1 523 31 discriminator 1
 2176 0170 D8349FE5 		ldr	r3, .L116+88
 2177 0174 0FE0A0E1 		mov	lr, pc
 2178 0178 13FF2FE1 		bx	r3
 2179              	.LVL61:
 2180 017c 0020A0E1 		mov	r2, r0
 2181              		.loc 1 523 29 discriminator 1
 2182 0180 08301BE5 		ldr	r3, [fp, #-8]
 2183 0184 023043E0 		sub	r3, r3, r2
 2184              		.loc 1 523 49 discriminator 1
 2185 0188 000053E3 		cmp	r3, #0
 2186 018c F7FFFFCA 		bgt	.L91
 524:main.c        ****       ;
 525:main.c        ****     start_tick += ZYKLUS_MS;
 2187              		.loc 1 525 16
 2188 0190 08301BE5 		ldr	r3, [fp, #-8]
 2189 0194 043083E2 		add	r3, r3, #4
 2190 0198 08300BE5 		str	r3, [fp, #-8]
 2191              	.L92:
 526:main.c        ****     // Label, so das mit 'go zyklus' hierhin gesprungen werden kann
 527:main.c        ****   zyklus:
 528:main.c        ****     __attribute__((unused)) if ((zeitscheibe & 0b000000001) == 0b000000001) {
 2192              		.loc 1 528 46
 2193 019c 0C301BE5 		ldr	r3, [fp, #-12]
 2194 01a0 013003E2 		and	r3, r3, #1
 2195              		.loc 1 528 32
 2196 01a4 000053E3 		cmp	r3, #0
 2197 01a8 0500000A 		beq	.L93
 529:main.c        ****       task_aktiv = "8ms";
 2198              		.loc 1 529 18
 2199 01ac A4349FE5 		ldr	r3, .L116+96
 2200 01b0 10300BE5 		str	r3, [fp, #-16]
 530:main.c        ****       task_8ms();
 2201              		.loc 1 530 7
 2202 01b4 A0349FE5 		ldr	r3, .L116+100
 2203 01b8 0FE0A0E1 		mov	lr, pc
 2204 01bc 13FF2FE1 		bx	r3
 2205              	.LVL62:
 2206 01c0 440000EA 		b	.L94
 2207              	.L93:
 531:main.c        ****     }
 532:main.c        ****     else if ((zeitscheibe & 0b000000011) == 0b000000010) {
 2208              		.loc 1 532 27
 2209 01c4 0C301BE5 		ldr	r3, [fp, #-12]
 2210 01c8 033003E2 		and	r3, r3, #3
 2211              		.loc 1 532 13
 2212 01cc 020053E3 		cmp	r3, #2
 2213 01d0 0500001A 		bne	.L95
 533:main.c        ****       task_aktiv = "16ms";
 2214              		.loc 1 533 18
 2215 01d4 84349FE5 		ldr	r3, .L116+104
 2216 01d8 10300BE5 		str	r3, [fp, #-16]
 534:main.c        ****       task_16ms();
 2217              		.loc 1 534 7
 2218 01dc 80349FE5 		ldr	r3, .L116+108
 2219 01e0 0FE0A0E1 		mov	lr, pc
 2220 01e4 13FF2FE1 		bx	r3
 2221              	.LVL63:
 2222 01e8 3A0000EA 		b	.L94
 2223              	.L95:
 535:main.c        ****     }
 536:main.c        ****     else if ((zeitscheibe & 0b000000111) == 0b000000100) {
 2224              		.loc 1 536 27
 2225 01ec 0C301BE5 		ldr	r3, [fp, #-12]
 2226 01f0 073003E2 		and	r3, r3, #7
 2227              		.loc 1 536 13
 2228 01f4 040053E3 		cmp	r3, #4
 2229 01f8 0500001A 		bne	.L96
 537:main.c        ****       task_aktiv = "32ms";
 2230              		.loc 1 537 18
 2231 01fc 64349FE5 		ldr	r3, .L116+112
 2232 0200 10300BE5 		str	r3, [fp, #-16]
 538:main.c        ****       task_32ms();
 2233              		.loc 1 538 7
 2234 0204 60349FE5 		ldr	r3, .L116+116
 2235 0208 0FE0A0E1 		mov	lr, pc
 2236 020c 13FF2FE1 		bx	r3
 2237              	.LVL64:
 2238 0210 300000EA 		b	.L94
 2239              	.L96:
 539:main.c        ****     }
 540:main.c        ****     else if ((zeitscheibe & 0b000001111) == 0b000001000) {
 2240              		.loc 1 540 27
 2241 0214 0C301BE5 		ldr	r3, [fp, #-12]
 2242 0218 0F3003E2 		and	r3, r3, #15
 2243              		.loc 1 540 13
 2244 021c 080053E3 		cmp	r3, #8
 2245 0220 0500001A 		bne	.L97
 541:main.c        ****       task_aktiv = "64ms";
 2246              		.loc 1 541 18
 2247 0224 44349FE5 		ldr	r3, .L116+120
 2248 0228 10300BE5 		str	r3, [fp, #-16]
 542:main.c        ****       task_64ms();
 2249              		.loc 1 542 7
 2250 022c 40349FE5 		ldr	r3, .L116+124
 2251 0230 0FE0A0E1 		mov	lr, pc
 2252 0234 13FF2FE1 		bx	r3
 2253              	.LVL65:
 2254 0238 260000EA 		b	.L94
 2255              	.L97:
 543:main.c        ****     }
 544:main.c        ****     else if ((zeitscheibe & 0b000011111) == 0b000010000) {
 2256              		.loc 1 544 27
 2257 023c 0C301BE5 		ldr	r3, [fp, #-12]
 2258 0240 1F3003E2 		and	r3, r3, #31
 2259              		.loc 1 544 13
 2260 0244 100053E3 		cmp	r3, #16
 2261 0248 0500001A 		bne	.L98
 545:main.c        ****       task_aktiv = "128ms";
 2262              		.loc 1 545 18
 2263 024c 24349FE5 		ldr	r3, .L116+128
 2264 0250 10300BE5 		str	r3, [fp, #-16]
 546:main.c        ****       task_128ms();
 2265              		.loc 1 546 7
 2266 0254 20349FE5 		ldr	r3, .L116+132
 2267 0258 0FE0A0E1 		mov	lr, pc
 2268 025c 13FF2FE1 		bx	r3
 2269              	.LVL66:
 2270 0260 1C0000EA 		b	.L94
 2271              	.L98:
 547:main.c        ****     }
 548:main.c        ****     else if ((zeitscheibe & 0b000111111) == 0b000100000) {
 2272              		.loc 1 548 27
 2273 0264 0C301BE5 		ldr	r3, [fp, #-12]
 2274 0268 3F3003E2 		and	r3, r3, #63
 2275              		.loc 1 548 13
 2276 026c 200053E3 		cmp	r3, #32
 2277 0270 0500001A 		bne	.L99
 549:main.c        ****       task_aktiv = "256ms";
 2278              		.loc 1 549 18
 2279 0274 04349FE5 		ldr	r3, .L116+136
 2280 0278 10300BE5 		str	r3, [fp, #-16]
 550:main.c        ****       task_256ms();
 2281              		.loc 1 550 7
 2282 027c 00349FE5 		ldr	r3, .L116+140
 2283 0280 0FE0A0E1 		mov	lr, pc
 2284 0284 13FF2FE1 		bx	r3
 2285              	.LVL67:
 2286 0288 120000EA 		b	.L94
 2287              	.L99:
 551:main.c        ****     }
 552:main.c        ****     else if ((zeitscheibe & 0b001111111) == 0b001000000) {
 2288              		.loc 1 552 27
 2289 028c 0C301BE5 		ldr	r3, [fp, #-12]
 2290 0290 7F3003E2 		and	r3, r3, #127
 2291              		.loc 1 552 13
 2292 0294 400053E3 		cmp	r3, #64
 2293 0298 0500001A 		bne	.L100
 553:main.c        ****       task_aktiv = "512ms";
 2294              		.loc 1 553 18
 2295 029c E4339FE5 		ldr	r3, .L116+144
 2296 02a0 10300BE5 		str	r3, [fp, #-16]
 554:main.c        ****       task_512ms();
 2297              		.loc 1 554 7
 2298 02a4 E0339FE5 		ldr	r3, .L116+148
 2299 02a8 0FE0A0E1 		mov	lr, pc
 2300 02ac 13FF2FE1 		bx	r3
 2301              	.LVL68:
 2302 02b0 080000EA 		b	.L94
 2303              	.L100:
 555:main.c        ****     }
 556:main.c        ****     else if ((zeitscheibe & 0b011111111) == 0b010000000) {
 2304              		.loc 1 556 27
 2305 02b4 0C301BE5 		ldr	r3, [fp, #-12]
 2306 02b8 FF3003E2 		and	r3, r3, #255
 2307              		.loc 1 556 13
 2308 02bc 800053E3 		cmp	r3, #128
 2309 02c0 0400001A 		bne	.L94
 557:main.c        ****       task_aktiv = "1024ms";
 2310              		.loc 1 557 18
 2311 02c4 C4339FE5 		ldr	r3, .L116+152
 2312 02c8 10300BE5 		str	r3, [fp, #-16]
 558:main.c        ****       task_1024ms();
 2313              		.loc 1 558 7
 2314 02cc C0339FE5 		ldr	r3, .L116+156
 2315 02d0 0FE0A0E1 		mov	lr, pc
 2316 02d4 13FF2FE1 		bx	r3
 2317              	.LVL69:
 2318              	.L94:
 559:main.c        ****     }
 560:main.c        ****     // Zeit für IDLE-Task verfügbar
 561:main.c        ****     if ((int)(start_tick - systick_get_ms()) >= IDLE_MS) {
 2319              		.loc 1 561 28
 2320 02d8 70339FE5 		ldr	r3, .L116+88
 2321 02dc 0FE0A0E1 		mov	lr, pc
 2322 02e0 13FF2FE1 		bx	r3
 2323              	.LVL70:
 2324 02e4 0020A0E1 		mov	r2, r0
 2325              		.loc 1 561 26 discriminator 1
 2326 02e8 08301BE5 		ldr	r3, [fp, #-8]
 2327 02ec 023043E0 		sub	r3, r3, r2
 2328              		.loc 1 561 8 discriminator 1
 2329 02f0 010053E3 		cmp	r3, #1
 2330 02f4 040000DA 		ble	.L101
 562:main.c        ****       task_aktiv = "Idle";
 2331              		.loc 1 562 18
 2332 02f8 98339FE5 		ldr	r3, .L116+160
 2333 02fc 10300BE5 		str	r3, [fp, #-16]
 563:main.c        ****       task_idle();
 2334              		.loc 1 563 7
 2335 0300 94339FE5 		ldr	r3, .L116+164
 2336 0304 0FE0A0E1 		mov	lr, pc
 2337 0308 13FF2FE1 		bx	r3
 2338              	.LVL71:
 2339              	.L101:
 564:main.c        ****     }
 565:main.c        ****     // Max. Zeitdauer einer Zeitscheibe überschritten?
 566:main.c        ****     if ((int)(start_tick - systick_get_ms()) <= 0) {
 2340              		.loc 1 566 28
 2341 030c 3C339FE5 		ldr	r3, .L116+88
 2342 0310 0FE0A0E1 		mov	lr, pc
 2343 0314 13FF2FE1 		bx	r3
 2344              	.LVL72:
 2345 0318 0020A0E1 		mov	r2, r0
 2346              		.loc 1 566 26 discriminator 1
 2347 031c 08301BE5 		ldr	r3, [fp, #-8]
 2348 0320 023043E0 		sub	r3, r3, r2
 2349              		.loc 1 566 8 discriminator 1
 2350 0324 000053E3 		cmp	r3, #0
 2351 0328 2C0000CA 		bgt	.L102
 567:main.c        ****       main_data.term_status |= term_string(
 2352              		.loc 1 567 32
 2353 032c 0010A0E3 		mov	r1, #0
 2354 0330 68039FE5 		ldr	r0, .L116+168
 2355 0334 EC329FE5 		ldr	r3, .L116+48
 2356 0338 0FE0A0E1 		mov	lr, pc
 2357 033c 13FF2FE1 		bx	r3
 2358              	.LVL73:
 2359 0340 0030A0E1 		mov	r3, r0
 2360              		.loc 1 567 16 discriminator 1
 2361 0344 58239FE5 		ldr	r2, .L116+172
 2362 0348 D020D2E1 		ldrsb	r2, [r2]
 2363              		.loc 1 567 29 discriminator 1
 2364 034c 033CA0E1 		lsl	r3, r3, #24
 2365 0350 433CA0E1 		asr	r3, r3, #24
 2366 0354 033082E1 		orr	r3, r2, r3
 2367 0358 033CA0E1 		lsl	r3, r3, #24
 2368 035c 432CA0E1 		asr	r2, r3, #24
 2369 0360 3C339FE5 		ldr	r3, .L116+172
 2370 0364 0020C3E5 		strb	r2, [r3]
 568:main.c        ****           VT100_VORDERGRUND_ROT "Timing durch '", ASYNCSYNC_NONBLOCK);
 569:main.c        ****       main_data.term_status |= term_string(task_aktiv, ASYNCSYNC_NONBLOCK);
 2371              		.loc 1 569 32
 2372 0368 0010A0E3 		mov	r1, #0
 2373 036c 10001BE5 		ldr	r0, [fp, #-16]
 2374 0370 B0329FE5 		ldr	r3, .L116+48
 2375 0374 0FE0A0E1 		mov	lr, pc
 2376 0378 13FF2FE1 		bx	r3
 2377              	.LVL74:
 2378 037c 0030A0E1 		mov	r3, r0
 2379              		.loc 1 569 16 discriminator 1
 2380 0380 1C239FE5 		ldr	r2, .L116+172
 2381 0384 D020D2E1 		ldrsb	r2, [r2]
 2382              		.loc 1 569 29 discriminator 1
 2383 0388 033CA0E1 		lsl	r3, r3, #24
 2384 038c 433CA0E1 		asr	r3, r3, #24
 2385 0390 033082E1 		orr	r3, r2, r3
 2386 0394 033CA0E1 		lsl	r3, r3, #24
 2387 0398 432CA0E1 		asr	r2, r3, #24
 2388 039c 00339FE5 		ldr	r3, .L116+172
 2389 03a0 0020C3E5 		strb	r2, [r3]
 570:main.c        ****       main_data.term_status |= term_string(
 2390              		.loc 1 570 32
 2391 03a4 0010A0E3 		mov	r1, #0
 2392 03a8 F8029FE5 		ldr	r0, .L116+176
 2393 03ac 74329FE5 		ldr	r3, .L116+48
 2394 03b0 0FE0A0E1 		mov	lr, pc
 2395 03b4 13FF2FE1 		bx	r3
 2396              	.LVL75:
 2397 03b8 0030A0E1 		mov	r3, r0
 2398              		.loc 1 570 16 discriminator 1
 2399 03bc E0229FE5 		ldr	r2, .L116+172
 2400 03c0 D020D2E1 		ldrsb	r2, [r2]
 2401              		.loc 1 570 29 discriminator 1
 2402 03c4 033CA0E1 		lsl	r3, r3, #24
 2403 03c8 433CA0E1 		asr	r3, r3, #24
 2404 03cc 033082E1 		orr	r3, r2, r3
 2405 03d0 033CA0E1 		lsl	r3, r3, #24
 2406 03d4 432CA0E1 		asr	r2, r3, #24
 2407 03d8 C4329FE5 		ldr	r3, .L116+172
 2408 03dc 0020C3E5 		strb	r2, [r3]
 2409              	.L102:
 571:main.c        ****           "' verletzt\n\r" VT100_VORDERGRUND_DEFAULT, ASYNCSYNC_NONBLOCK);
 572:main.c        ****     }
 573:main.c        ****     // Zeitscheibe erhöhen
 574:main.c        ****     zeitscheibe++;
 2410              		.loc 1 574 16
 2411 03e0 0C301BE5 		ldr	r3, [fp, #-12]
 2412 03e4 013083E2 		add	r3, r3, #1
 2413 03e8 0C300BE5 		str	r3, [fp, #-12]
 2414              	.LBB10:
 2415              	.LBB11:
 123:lib/../main.h **** 
 124:lib/../main.h **** static __inline__ int32_t stack_check(void) __attribute__((always_inline));
 125:lib/../main.h **** static __inline__ int32_t stack_check(void)
 126:lib/../main.h **** {
 127:lib/../main.h **** 	         uint32_t *ptr;
 128:lib/../main.h **** //	register uint32_t *sp asm("r13");
 129:lib/../main.h **** 	for(ptr=&__stack_start__[0];*ptr==STACK_FILL;++ptr);
 2416              		.loc 4 129 9
 2417 03ec 54329FE5 		ldr	r3, .L116+80
 2418 03f0 18300BE5 		str	r3, [fp, #-24]
 2419              		.loc 4 129 2
 2420 03f4 020000EA 		b	.L103
 2421              	.L104:
 2422              		.loc 4 129 47 discriminator 3
 2423 03f8 18301BE5 		ldr	r3, [fp, #-24]
 2424 03fc 043083E2 		add	r3, r3, #4
 2425 0400 18300BE5 		str	r3, [fp, #-24]
 2426              	.L103:
 2427              		.loc 4 129 30 discriminator 1
 2428 0404 18301BE5 		ldr	r3, [fp, #-24]
 2429 0408 003093E5 		ldr	r3, [r3]
 2430              		.loc 4 129 34 discriminator 1
 2431 040c 38229FE5 		ldr	r2, .L116+84
 2432 0410 020053E1 		cmp	r3, r2
 2433 0414 F7FFFF0A 		beq	.L104
 130:lib/../main.h **** 	return (int32_t)(ptr-&__stack_start__[0]);
 2434              		.loc 4 130 22
 2435 0418 18301BE5 		ldr	r3, [fp, #-24]
 2436 041c 24229FE5 		ldr	r2, .L116+80
 2437 0420 023043E0 		sub	r3, r3, r2
 2438              		.loc 4 130 9
 2439 0424 4331A0E1 		asr	r3, r3, #2
 2440              	.LBE11:
 2441              	.LBE10:
 575:main.c        **** 
 576:main.c        ****     // Stack Testen
 577:main.c        ****     if (stack_check() < (1 * 4)) {
 2442              		.loc 1 577 8 discriminator 1
 2443 0428 030053E3 		cmp	r3, #3
 2444 042c 350000CA 		bgt	.L106
 2445              	.LBB12:
 578:main.c        ****       static uint8_t stack_cnt = 0;
 579:main.c        ****       if (stack_cnt == 0) {
 2446              		.loc 1 579 21
 2447 0430 74329FE5 		ldr	r3, .L116+180
 2448 0434 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2449              		.loc 1 579 10
 2450 0438 000053E3 		cmp	r3, #0
 2451 043c 3100001A 		bne	.L106
 580:main.c        ****         stack_cnt = 1;
 2452              		.loc 1 580 19
 2453 0440 64329FE5 		ldr	r3, .L116+180
 2454 0444 0120A0E3 		mov	r2, #1
 2455 0448 0020C3E5 		strb	r2, [r3]
 581:main.c        ****         main_data.term_status |= term_string(
 2456              		.loc 1 581 34
 2457 044c 0010A0E3 		mov	r1, #0
 2458 0450 58029FE5 		ldr	r0, .L116+184
 2459 0454 CC319FE5 		ldr	r3, .L116+48
 2460 0458 0FE0A0E1 		mov	lr, pc
 2461 045c 13FF2FE1 		bx	r3
 2462              	.LVL76:
 2463 0460 0030A0E1 		mov	r3, r0
 2464              		.loc 1 581 18 discriminator 1
 2465 0464 38229FE5 		ldr	r2, .L116+172
 2466 0468 D020D2E1 		ldrsb	r2, [r2]
 2467              		.loc 1 581 31 discriminator 1
 2468 046c 033CA0E1 		lsl	r3, r3, #24
 2469 0470 433CA0E1 		asr	r3, r3, #24
 2470 0474 033082E1 		orr	r3, r2, r3
 2471 0478 033CA0E1 		lsl	r3, r3, #24
 2472 047c 432CA0E1 		asr	r2, r3, #24
 2473 0480 1C329FE5 		ldr	r3, .L116+172
 2474 0484 0020C3E5 		strb	r2, [r3]
 582:main.c        ****             VT100_VORDERGRUND_ROT "Stack overflow durch '", ASYNCSYNC_NONBLOCK);
 583:main.c        ****         main_data.term_status |= term_string(task_aktiv, ASYNCSYNC_NONBLOCK);
 2475              		.loc 1 583 34
 2476 0488 0010A0E3 		mov	r1, #0
 2477 048c 10001BE5 		ldr	r0, [fp, #-16]
 2478 0490 90319FE5 		ldr	r3, .L116+48
 2479 0494 0FE0A0E1 		mov	lr, pc
 2480 0498 13FF2FE1 		bx	r3
 2481              	.LVL77:
 2482 049c 0030A0E1 		mov	r3, r0
 2483              		.loc 1 583 18 discriminator 1
 2484 04a0 FC219FE5 		ldr	r2, .L116+172
 2485 04a4 D020D2E1 		ldrsb	r2, [r2]
 2486              		.loc 1 583 31 discriminator 1
 2487 04a8 033CA0E1 		lsl	r3, r3, #24
 2488 04ac 433CA0E1 		asr	r3, r3, #24
 2489 04b0 033082E1 		orr	r3, r2, r3
 2490 04b4 033CA0E1 		lsl	r3, r3, #24
 2491 04b8 432CA0E1 		asr	r2, r3, #24
 2492 04bc E0319FE5 		ldr	r3, .L116+172
 2493 04c0 0020C3E5 		strb	r2, [r3]
 584:main.c        ****         main_data.term_status |=
 585:main.c        ****             term_string("'\n\r" VT100_VORDERGRUND_DEFAULT, ASYNCSYNC_NONBLOCK);
 2494              		.loc 1 585 13
 2495 04c4 0010A0E3 		mov	r1, #0
 2496 04c8 E4019FE5 		ldr	r0, .L116+188
 2497 04cc 54319FE5 		ldr	r3, .L116+48
 2498 04d0 0FE0A0E1 		mov	lr, pc
 2499 04d4 13FF2FE1 		bx	r3
 2500              	.LVL78:
 2501 04d8 0030A0E1 		mov	r3, r0
 584:main.c        ****         main_data.term_status |=
 2502              		.loc 1 584 18
 2503 04dc C0219FE5 		ldr	r2, .L116+172
 2504 04e0 D020D2E1 		ldrsb	r2, [r2]
 584:main.c        ****         main_data.term_status |=
 2505              		.loc 1 584 31
 2506 04e4 033CA0E1 		lsl	r3, r3, #24
 2507 04e8 433CA0E1 		asr	r3, r3, #24
 2508 04ec 033082E1 		orr	r3, r2, r3
 2509 04f0 033CA0E1 		lsl	r3, r3, #24
 2510 04f4 432CA0E1 		asr	r2, r3, #24
 2511 04f8 A4319FE5 		ldr	r3, .L116+172
 2512 04fc 0020C3E5 		strb	r2, [r3]
 2513              	.L107:
 586:main.c        ****         while (1)
 2514              		.loc 1 586 15
 2515 0500 0000A0E1 		nop
 2516 0504 FDFFFFEA 		b	.L107
 2517              	.L106:
 2518              	.LBE12:
 587:main.c        ****           ;
 588:main.c        ****       }
 589:main.c        ****     }
 590:main.c        **** 
 591:main.c        ****     // Batteriespannung überprüfen
 592:main.c        ****     // Ggf. schlägt die Unterspannungsprüfung im Akku zuvor ein!
 593:main.c        ****     if (nxt_avr_get_battery_raw() < ((2 * 3000 /*mV*/) << 10) / 14180) {
 2519              		.loc 1 593 9
 2520 0508 A8319FE5 		ldr	r3, .L116+192
 2521 050c 0FE0A0E1 		mov	lr, pc
 2522 0510 13FF2FE1 		bx	r3
 2523              	.LVL79:
 2524 0514 0030A0E1 		mov	r3, r0
 2525              		.loc 1 593 8 discriminator 1
 2526 0518 1B0E53E3 		cmp	r3, #432
 2527 051c 1D00008A 		bhi	.L108
 594:main.c        ****       if (main_data.lowbat_cnt++ > 100)
 2528              		.loc 1 594 20
 2529 0520 7C319FE5 		ldr	r3, .L116+172
 2530 0524 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2531              		.loc 1 594 31
 2532 0528 012083E2 		add	r2, r3, #1
 2533 052c FF1002E2 		and	r1, r2, #255
 2534 0530 6C219FE5 		ldr	r2, .L116+172
 2535 0534 0210C2E5 		strb	r1, [r2, #2]
 2536              		.loc 1 594 10
 2537 0538 640053E3 		cmp	r3, #100
 2538 053c 0100009A 		bls	.L109
 2539              	.L110:
 595:main.c        ****         while (1)
 2540              		.loc 1 595 15
 2541 0540 0000A0E1 		nop
 2542 0544 FDFFFFEA 		b	.L110
 2543              	.L109:
 596:main.c        ****           ;
 597:main.c        ****       else if (main_data.lowbat_cnt == 10)
 2544              		.loc 1 597 25
 2545 0548 54319FE5 		ldr	r3, .L116+172
 2546 054c 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2547              		.loc 1 597 15
 2548 0550 0A0053E3 		cmp	r3, #10
 2549 0554 1200001A 		bne	.L111
 598:main.c        ****         main_data.term_status |=
 599:main.c        ****             term_string(VT100_VORDERGRUND_ROT
 2550              		.loc 1 599 13
 2551 0558 0010A0E3 		mov	r1, #0
 2552 055c 58019FE5 		ldr	r0, .L116+196
 2553 0560 C0309FE5 		ldr	r3, .L116+48
 2554 0564 0FE0A0E1 		mov	lr, pc
 2555 0568 13FF2FE1 		bx	r3
 2556              	.LVL80:
 2557 056c 0030A0E1 		mov	r3, r0
 598:main.c        ****         main_data.term_status |=
 2558              		.loc 1 598 18
 2559 0570 2C219FE5 		ldr	r2, .L116+172
 2560 0574 D020D2E1 		ldrsb	r2, [r2]
 598:main.c        ****         main_data.term_status |=
 2561              		.loc 1 598 31
 2562 0578 033CA0E1 		lsl	r3, r3, #24
 2563 057c 433CA0E1 		asr	r3, r3, #24
 2564 0580 033082E1 		orr	r3, r2, r3
 2565 0584 033CA0E1 		lsl	r3, r3, #24
 2566 0588 432CA0E1 		asr	r2, r3, #24
 2567 058c 10319FE5 		ldr	r3, .L116+172
 2568 0590 0020C3E5 		strb	r2, [r3]
 2569 0594 020000EA 		b	.L111
 2570              	.L108:
 600:main.c        ****                         "\n\rLow Battery\n\r" VT100_VORDERGRUND_DEFAULT,
 601:main.c        ****                         ASYNCSYNC_NONBLOCK);
 602:main.c        ****     } else {
 603:main.c        ****       main_data.lowbat_cnt = 0;
 2571              		.loc 1 603 28
 2572 0598 04319FE5 		ldr	r3, .L116+172
 2573 059c 0020A0E3 		mov	r2, #0
 2574 05a0 0220C3E5 		strb	r2, [r3, #2]
 2575              	.L111:
 604:main.c        ****     }
 605:main.c        **** 
 606:main.c        ****     // Termstatus ueberpruefen
 607:main.c        ****     if (main_data.term_cnt == 0 && main_data.term_status != 0) {
 2576              		.loc 1 607 18
 2577 05a4 F8309FE5 		ldr	r3, .L116+172
 2578 05a8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2579              		.loc 1 607 8
 2580 05ac 000053E3 		cmp	r3, #0
 2581 05b0 EDFEFF1A 		bne	.L115
 2582              		.loc 1 607 45 discriminator 1
 2583 05b4 E8309FE5 		ldr	r3, .L116+172
 2584 05b8 D030D3E1 		ldrsb	r3, [r3]
 2585              		.loc 1 607 33 discriminator 1
 2586 05bc 000053E3 		cmp	r3, #0
 2587 05c0 E9FEFF0A 		beq	.L115
 608:main.c        ****       main_data.term_cnt++;
 2588              		.loc 1 608 16
 2589 05c4 D8309FE5 		ldr	r3, .L116+172
 2590 05c8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2591              		.loc 1 608 25
 2592 05cc 013083E2 		add	r3, r3, #1
 2593 05d0 FF2003E2 		and	r2, r3, #255
 2594 05d4 C8309FE5 		ldr	r3, .L116+172
 2595 05d8 0120C3E5 		strb	r2, [r3, #1]
 2596              	.L113:
 609:main.c        ****     overflow:
 610:main.c        ****       __attribute__((unused));
 611:main.c        **** 
 612:main.c        ****       (void)term_string(VT100_VORDERGRUND_ROT
 2597              		.loc 1 612 13
 2598 05dc 0110A0E3 		mov	r1, #1
 2599 05e0 D8009FE5 		ldr	r0, .L116+200
 2600 05e4 3C309FE5 		ldr	r3, .L116+48
 2601 05e8 0FE0A0E1 		mov	lr, pc
 2602 05ec 13FF2FE1 		bx	r3
 2603              	.LVL81:
 2604              	.L114:
 613:main.c        ****                         "\n\rTerminal Overflow\n\r" VT100_VORDERGRUND_DEFAULT,
 614:main.c        ****                         ASYNCSYNC_BLOCK);
 615:main.c        ****       while (1)
 2605              		.loc 1 615 13
 2606 05f0 0000A0E1 		nop
 2607 05f4 FDFFFFEA 		b	.L114
 2608              	.L117:
 2609              		.align	2
 2610              	.L116:
 2611 05f8 00000000 		.word	aic_init
 2612 05fc 00000000 		.word	systick_init
 2613 0600 00000000 		.word	interrupts_enable
 2614 0604 00000000 		.word	nxt_avr_init
 2615 0608 00000000 		.word	udmon3_init
 2616 060c 00000000 		.word	term_init
 2617 0610 00000000 		.word	display_init
 2618 0614 00000000 		.word	display_clear
 2619 0618 44000000 		.word	.LC9
 2620 061c 00000000 		.word	display_string
 2621 0620 00000000 		.word	display_update
 2622 0624 54000000 		.word	.LC10
 2623 0628 00000000 		.word	term_string
 2624 062c 60000000 		.word	.LC11
 2625 0630 90000000 		.word	.LC12
 2626 0634 D4000000 		.word	.LC13
 2627 0638 08010000 		.word	.LC14
 2628 063c 34010000 		.word	.LC15
 2629 0640 40FDFFFF 		.word	-704
 2630 0644 FF8F0030 		.word	805343231
 2631 0648 00000000 		.word	__stack_start__
 2632 064c 11111111 		.word	286331153
 2633 0650 00000000 		.word	systick_get_ms
 2634 0654 44010000 		.word	.LC16
 2635 0658 48010000 		.word	.LC17
 2636 065c 00000000 		.word	task_8ms
 2637 0660 4C010000 		.word	.LC18
 2638 0664 00000000 		.word	task_16ms
 2639 0668 54010000 		.word	.LC19
 2640 066c 00000000 		.word	task_32ms
 2641 0670 5C010000 		.word	.LC20
 2642 0674 00000000 		.word	task_64ms
 2643 0678 64010000 		.word	.LC21
 2644 067c 00000000 		.word	task_128ms
 2645 0680 6C010000 		.word	.LC22
 2646 0684 00000000 		.word	task_256ms
 2647 0688 74010000 		.word	.LC23
 2648 068c 00000000 		.word	task_512ms
 2649 0690 7C010000 		.word	.LC24
 2650 0694 00000000 		.word	task_1024ms
 2651 0698 84010000 		.word	.LC25
 2652 069c 00000000 		.word	task_idle
 2653 06a0 8C010000 		.word	.LC26
 2654 06a4 00000000 		.word	main_data
 2655 06a8 A0010000 		.word	.LC27
 2656 06ac E2040000 		.word	stack_cnt.0
 2657 06b0 B4010000 		.word	.LC28
 2658 06b4 D0010000 		.word	.LC29
 2659 06b8 00000000 		.word	nxt_avr_get_battery_raw
 2660 06bc DC010000 		.word	.LC30
 2661 06c0 F8010000 		.word	.LC31
 2662              		.cfi_endproc
 2663              	.LFE28:
 2665              		.bss
 2666              		.align	2
 2667              	trace_index.4:
 2668 046c 00000000 		.space	4
 2670              	strpos.3:
 2671 0470 00       		.space	1
 2673 0471 000000   		.align	2
 2674              	string.2:
 2675 0474 00000000 		.space	100
 2675      00000000 
 2675      00000000 
 2675      00000000 
 2675      00000000 
 2677              		.align	2
 2678              	linebuf.1:
 2679 04d8 00000000 		.space	10
 2679      00000000 
 2679      0000
 2681              	stack_cnt.0:
 2682 04e2 00       		.space	1
 2684              		.text
 2685              	.Letext0:
 2686              		.file 5 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/machi
 2687              		.file 6 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/_
 2688              		.file 7 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/lib/gcc/arm-none-eabi/14.3.
 2689              		.file 8 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/_
 2690              		.file 9 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/r
 2691              		.file 10 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/
 2692              		.file 11 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/stdi
 2693              		.file 12 "AT91SAM7S64.h"
 2694              		.file 13 "lib/display.h"
 2695              		.file 14 "lib/term.h"
 2696              		.file 15 "trace32/udmon3.h"
 2697              		.file 16 "lib/nxt_avr.h"
 2698              		.file 17 "lib/isr.h"
 2699              		.file 18 "lib/systick.h"
 2700              		.file 19 "lib/aic.h"
 2701              		.file 20 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cc7TSauM.s:19     .text.byte_fifo_put_possible:00000000 $a
     /tmp/cc7TSauM.s:23     .text.byte_fifo_put_possible:00000000 byte_fifo_put_possible
     /tmp/cc7TSauM.s:75     .text.byte_fifo_remain:00000000 $a
     /tmp/cc7TSauM.s:79     .text.byte_fifo_remain:00000000 byte_fifo_remain
     /tmp/cc7TSauM.s:133    .text.byte_fifo_used:00000000 $a
     /tmp/cc7TSauM.s:137    .text.byte_fifo_used:00000000 byte_fifo_used
     /tmp/cc7TSauM.s:188    .text.byte_fifo_put:00000000 $a
     /tmp/cc7TSauM.s:192    .text.byte_fifo_put:00000000 byte_fifo_put
     /tmp/cc7TSauM.s:277    .text.byte_fifo_get_possible:00000000 $a
     /tmp/cc7TSauM.s:281    .text.byte_fifo_get_possible:00000000 byte_fifo_get_possible
     /tmp/cc7TSauM.s:325    .text.byte_fifo_get:00000000 $a
     /tmp/cc7TSauM.s:329    .text.byte_fifo_get:00000000 byte_fifo_get
     /tmp/cc7TSauM.s:408    .text.byte_fifo_cb_put_possible:00000000 $a
     /tmp/cc7TSauM.s:412    .text.byte_fifo_cb_put_possible:00000000 byte_fifo_cb_put_possible
     /tmp/cc7TSauM.s:450    .text.byte_fifo_cb_put_possible:0000003c $d
     /tmp/cc7TSauM.s:455    .text.byte_fifo_cb_put:00000000 $a
     /tmp/cc7TSauM.s:459    .text.byte_fifo_cb_put:00000000 byte_fifo_cb_put
     /tmp/cc7TSauM.s:520    .text.byte_fifo_cb_put:0000007c $d
     /tmp/cc7TSauM.s:525    .text.byte_fifo_cb_get_possible:00000000 $a
     /tmp/cc7TSauM.s:529    .text.byte_fifo_cb_get_possible:00000000 byte_fifo_cb_get_possible
     /tmp/cc7TSauM.s:566    .text.byte_fifo_cb_get_possible:0000003c $d
     /tmp/cc7TSauM.s:571    .text.byte_fifo_cb_get:00000000 $a
     /tmp/cc7TSauM.s:575    .text.byte_fifo_cb_get:00000000 byte_fifo_cb_get
     /tmp/cc7TSauM.s:614    .text.byte_fifo_cb_get:00000044 $d
     /tmp/cc7TSauM.s:623    .bss:00000000 main_data
     /tmp/cc7TSauM.s:620    .bss:00000000 $d
     /tmp/cc7TSauM.s:626    .text._exit:00000000 $a
     /tmp/cc7TSauM.s:631    .text._exit:00000000 _exit
     /tmp/cc7TSauM.s:658    .bss:00000004 trace_buf0
     /tmp/cc7TSauM.s:664    .bss:00000194 trace_buf1
     /tmp/cc7TSauM.s:667    .text.trace_scope:00000000 $a
     /tmp/cc7TSauM.s:672    .text.trace_scope:00000000 trace_scope
     /tmp/cc7TSauM.s:760    .text.trace_scope:000000c8 $d
     /tmp/cc7TSauM.s:2667   .bss:0000046c trace_index.4
     /tmp/cc7TSauM.s:771    .bss:00000324 h
     /tmp/cc7TSauM.s:774    .rodata:00000000 $d
     /tmp/cc7TSauM.s:778    .text.herzschlag_process:00000000 $a
     /tmp/cc7TSauM.s:783    .text.herzschlag_process:00000000 herzschlag_process
     /tmp/cc7TSauM.s:1148   .text.herzschlag_process:000003a4 $d
     /tmp/cc7TSauM.s:1161   .text.task_8ms:00000000 $a
     /tmp/cc7TSauM.s:1166   .text.task_8ms:00000000 task_8ms
     /tmp/cc7TSauM.s:1205   .text.task_8ms:0000003c $d
     /tmp/cc7TSauM.s:1211   .text.task_16ms:00000000 $a
     /tmp/cc7TSauM.s:1216   .text.task_16ms:00000000 task_16ms
     /tmp/cc7TSauM.s:1242   .text.task_32ms:00000000 $a
     /tmp/cc7TSauM.s:1247   .text.task_32ms:00000000 task_32ms
     /tmp/cc7TSauM.s:1273   .text.task_64ms:00000000 $a
     /tmp/cc7TSauM.s:1278   .text.task_64ms:00000000 task_64ms
     /tmp/cc7TSauM.s:1304   .text.task_128ms:00000000 $a
     /tmp/cc7TSauM.s:1309   .text.task_128ms:00000000 task_128ms
     /tmp/cc7TSauM.s:1354   .text.task_256ms:00000000 $a
     /tmp/cc7TSauM.s:1359   .text.task_256ms:00000000 task_256ms
     /tmp/cc7TSauM.s:1591   .text.task_256ms:0000023c $d
     /tmp/cc7TSauM.s:1612   .text.task_512ms:00000000 $a
     /tmp/cc7TSauM.s:1617   .text.task_512ms:00000000 task_512ms
     /tmp/cc7TSauM.s:1643   .text.task_1024ms:00000000 $a
     /tmp/cc7TSauM.s:1648   .text.task_1024ms:00000000 task_1024ms
     /tmp/cc7TSauM.s:1681   .text.task_idle:00000000 $a
     /tmp/cc7TSauM.s:1686   .text.task_idle:00000000 task_idle
     /tmp/cc7TSauM.s:1870   .text.task_idle:000001fc $d
     /tmp/cc7TSauM.s:2670   .bss:00000470 strpos.3
     /tmp/cc7TSauM.s:2674   .bss:00000474 string.2
     /tmp/cc7TSauM.s:1882   .text.premain_init:00000000 $a
     /tmp/cc7TSauM.s:1887   .text.premain_init:00000000 premain_init
     /tmp/cc7TSauM.s:1929   .text.premain_init:0000003c $d
     /tmp/cc7TSauM.s:2678   .bss:000004d8 linebuf.1
     /tmp/cc7TSauM.s:1936   .init_array:00000000 $d
     /tmp/cc7TSauM.s:2012   .text.main:00000000 $a
     /tmp/cc7TSauM.s:2017   .text.main:00000000 main
     /tmp/cc7TSauM.s:2611   .text.main:000005f8 $d
     /tmp/cc7TSauM.s:2681   .bss:000004e2 stack_cnt.0

UNDEFINED SYMBOLS
systick_get_ms
__aeabi_uidiv
term_int
term_string
nxt_avr_get_sensor_adc_raw
display_string
display_hex
display_goto_xy
nxt_avr_get_battery_mv
display_unsigned
nxt_avr_get_buttons
display_char
display_update
term_read
term_char
_impure_ptr
setvbuf
aic_init
systick_init
interrupts_enable
nxt_avr_init
udmon3_init
term_init
display_init
display_clear
__stack_start__
nxt_avr_get_battery_raw
