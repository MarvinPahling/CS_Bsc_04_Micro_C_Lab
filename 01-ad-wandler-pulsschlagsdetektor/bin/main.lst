   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "main.c"
  18              		.section	.text.byte_fifo_put_possible,"ax",%progbits
  19              		.align	2
  20              		.syntax unified
  21              		.arm
  23              	byte_fifo_put_possible:
  24              	.LFB5:
  25              		.file 2 "trace32/../lib/byte_fifo.h"
   1:trace32/../lib/byte_fifo.h **** /* Byte FIFO queue implementation.
   2:trace32/../lib/byte_fifo.h ****  *
   3:trace32/../lib/byte_fifo.h ****  * Implements a simple reader/write save byte FIFO on top of a data buffer, that lets
   4:trace32/../lib/byte_fifo.h ****  * you enqueue and dequeue single bytes.
   5:trace32/../lib/byte_fifo.h ****  */
   6:trace32/../lib/byte_fifo.h **** 
   7:trace32/../lib/byte_fifo.h **** #ifndef __BYTE_FIFO_H__
   8:trace32/../lib/byte_fifo.h **** #define __BYTE_FIFO_H__
   9:trace32/../lib/byte_fifo.h **** 
  10:trace32/../lib/byte_fifo.h **** 
  11:trace32/../lib/byte_fifo.h **** typedef struct
  12:trace32/../lib/byte_fifo.h **** {
  13:trace32/../lib/byte_fifo.h **** 	unsigned short rd;
  14:trace32/../lib/byte_fifo.h **** 	unsigned short wr;
  15:trace32/../lib/byte_fifo.h ****     unsigned short mask;
  16:trace32/../lib/byte_fifo.h **** 	unsigned char  buf[];
  17:trace32/../lib/byte_fifo.h **** } byte_fifo_t;
  18:trace32/../lib/byte_fifo.h **** 
  19:trace32/../lib/byte_fifo.h **** #define TEST_2erPOTENZ(x) (((x) & ((x) - 1))?0:(x))
  20:trace32/../lib/byte_fifo.h **** #define TEST_64k(x)       ((x)>0x10000?0:(x))
  21:trace32/../lib/byte_fifo.h **** #define TEST_SIZE(x)      (TEST_64k(TEST_2erPOTENZ(x)))
  22:trace32/../lib/byte_fifo.h **** 
  23:trace32/../lib/byte_fifo.h **** //size muss einer 2er Potenzzahl sein, andernfalls gibt der Compiler
  24:trace32/../lib/byte_fifo.h **** //die Fehlermeldung aus, dass die Array-Größe (hier -1) ungültit ist
  25:trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_INIT(size)  (byte_fifo_t) {.rd=0,\
  26:trace32/../lib/byte_fifo.h ****                                              .wr=0,\
  27:trace32/../lib/byte_fifo.h **** 						        	         .mask=TEST_SIZE(size)-1,\
  28:trace32/../lib/byte_fifo.h **** 								    		 .buf={[TEST_SIZE(size)-1]=0}\
  29:trace32/../lib/byte_fifo.h **** 									    	}
  30:trace32/../lib/byte_fifo.h **** 
  31:trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_TYPEOF_RDWR typeof (((byte_fifo_t *)0)->rd)
  32:trace32/../lib/byte_fifo.h **** 
  33:trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic push
  34:trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  35:trace32/../lib/byte_fifo.h **** 
  36:trace32/../lib/byte_fifo.h **** static int byte_fifo_put_possible(byte_fifo_t *fifo)
  37:trace32/../lib/byte_fifo.h **** {
  26              		.loc 2 37 1
  27              		.cfi_startproc
  28              		@ Function supports interworking.
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 04B02DE5 		str	fp, [sp, #-4]!
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 11, -4
  35 0004 00B08DE2 		add	fp, sp, #0
  36              		.cfi_def_cfa_register 11
  37 0008 0CD04DE2 		sub	sp, sp, #12
  38 000c 08000BE5 		str	r0, [fp, #-8]
  38:trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
  39              		.loc 2 38 11
  40 0010 08301BE5 		ldr	r3, [fp, #-8]
  41 0014 B230D3E1 		ldrh	r3, [r3, #2]
  42              		.loc 2 38 15
  43 0018 013083E2 		add	r3, r3, #1
  44              		.loc 2 38 24
  45 001c 08201BE5 		ldr	r2, [fp, #-8]
  46 0020 B420D2E1 		ldrh	r2, [r2, #4]
  47              		.loc 2 38 18
  48 0024 023003E0 		and	r3, r3, r2
  49              		.loc 2 38 40
  50 0028 08201BE5 		ldr	r2, [fp, #-8]
  51 002c B020D2E1 		ldrh	r2, [r2]
  52              		.loc 2 38 4
  53 0030 020053E1 		cmp	r3, r2
  54 0034 0100001A 		bne	.L2
  39:trace32/../lib/byte_fifo.h **** 		return -1;
  55              		.loc 2 39 10
  56 0038 0030E0E3 		mvn	r3, #0
  57 003c 000000EA 		b	.L3
  58              	.L2:
  40:trace32/../lib/byte_fifo.h **** 	
  41:trace32/../lib/byte_fifo.h **** 	return 0;
  59              		.loc 2 41 9
  60 0040 0030A0E3 		mov	r3, #0
  61              	.L3:
  42:trace32/../lib/byte_fifo.h **** }
  62              		.loc 2 42 1
  63 0044 0300A0E1 		mov	r0, r3
  64 0048 00D08BE2 		add	sp, fp, #0
  65              		.cfi_def_cfa_register 13
  66              		@ sp needed
  67 004c 04B09DE4 		ldr	fp, [sp], #4
  68              		.cfi_restore 11
  69              		.cfi_def_cfa_offset 0
  70 0050 1EFF2FE1 		bx	lr
  71              		.cfi_endproc
  72              	.LFE5:
  74              		.section	.text.byte_fifo_remain,"ax",%progbits
  75              		.align	2
  76              		.syntax unified
  77              		.arm
  79              	byte_fifo_remain:
  80              	.LFB6:
  43:trace32/../lib/byte_fifo.h **** 
  44:trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_remain(byte_fifo_t *fifo)
  45:trace32/../lib/byte_fifo.h **** {
  81              		.loc 2 45 1
  82              		.cfi_startproc
  83              		@ Function supports interworking.
  84              		@ args = 0, pretend = 0, frame = 8
  85              		@ frame_needed = 1, uses_anonymous_args = 0
  86              		@ link register save eliminated.
  87 0000 04B02DE5 		str	fp, [sp, #-4]!
  88              		.cfi_def_cfa_offset 4
  89              		.cfi_offset 11, -4
  90 0004 00B08DE2 		add	fp, sp, #0
  91              		.cfi_def_cfa_register 11
  92 0008 0CD04DE2 		sub	sp, sp, #12
  93 000c 08000BE5 		str	r0, [fp, #-8]
  46:trace32/../lib/byte_fifo.h **** 	return fifo->mask - ((fifo->wr-fifo->rd)&fifo->mask);
  94              		.loc 2 46 37
  95 0010 08301BE5 		ldr	r3, [fp, #-8]
  96 0014 B020D3E1 		ldrh	r2, [r3]
  97              		.loc 2 46 28
  98 0018 08301BE5 		ldr	r3, [fp, #-8]
  99 001c B230D3E1 		ldrh	r3, [r3, #2]
 100              		.loc 2 46 20
 101 0020 033042E0 		sub	r3, r2, r3
 102 0024 0338A0E1 		lsl	r3, r3, #16
 103 0028 2338A0E1 		lsr	r3, r3, #16
 104 002c 013043E2 		sub	r3, r3, #1
 105 0030 0338A0E1 		lsl	r3, r3, #16
 106 0034 2338A0E1 		lsr	r3, r3, #16
 107 0038 0338A0E1 		lsl	r3, r3, #16
 108 003c 4328A0E1 		asr	r2, r3, #16
 109              		.loc 2 46 47
 110 0040 08301BE5 		ldr	r3, [fp, #-8]
 111 0044 B430D3E1 		ldrh	r3, [r3, #4]
 112 0048 0338A0E1 		lsl	r3, r3, #16
 113 004c 4338A0E1 		asr	r3, r3, #16
 114              		.loc 2 46 20
 115 0050 023003E0 		and	r3, r3, r2
 116 0054 0338A0E1 		lsl	r3, r3, #16
 117 0058 4338A0E1 		asr	r3, r3, #16
 118 005c 0338A0E1 		lsl	r3, r3, #16
 119 0060 2338A0E1 		lsr	r3, r3, #16
  47:trace32/../lib/byte_fifo.h **** }
 120              		.loc 2 47 1
 121 0064 0300A0E1 		mov	r0, r3
 122 0068 00D08BE2 		add	sp, fp, #0
 123              		.cfi_def_cfa_register 13
 124              		@ sp needed
 125 006c 04B09DE4 		ldr	fp, [sp], #4
 126              		.cfi_restore 11
 127              		.cfi_def_cfa_offset 0
 128 0070 1EFF2FE1 		bx	lr
 129              		.cfi_endproc
 130              	.LFE6:
 132              		.section	.text.byte_fifo_used,"ax",%progbits
 133              		.align	2
 134              		.syntax unified
 135              		.arm
 137              	byte_fifo_used:
 138              	.LFB7:
  48:trace32/../lib/byte_fifo.h **** 	
  49:trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_used(byte_fifo_t *fifo)
  50:trace32/../lib/byte_fifo.h **** {
 139              		.loc 2 50 1
 140              		.cfi_startproc
 141              		@ Function supports interworking.
 142              		@ args = 0, pretend = 0, frame = 8
 143              		@ frame_needed = 1, uses_anonymous_args = 0
 144              		@ link register save eliminated.
 145 0000 04B02DE5 		str	fp, [sp, #-4]!
 146              		.cfi_def_cfa_offset 4
 147              		.cfi_offset 11, -4
 148 0004 00B08DE2 		add	fp, sp, #0
 149              		.cfi_def_cfa_register 11
 150 0008 0CD04DE2 		sub	sp, sp, #12
 151 000c 08000BE5 		str	r0, [fp, #-8]
  51:trace32/../lib/byte_fifo.h **** 	return (fifo->wr-fifo->rd)&fifo->mask;
 152              		.loc 2 51 14
 153 0010 08301BE5 		ldr	r3, [fp, #-8]
 154 0014 B220D3E1 		ldrh	r2, [r3, #2]
 155              		.loc 2 51 23
 156 0018 08301BE5 		ldr	r3, [fp, #-8]
 157 001c B030D3E1 		ldrh	r3, [r3]
 158              		.loc 2 51 18
 159 0020 033042E0 		sub	r3, r2, r3
 160 0024 0338A0E1 		lsl	r3, r3, #16
 161 0028 2338A0E1 		lsr	r3, r3, #16
 162 002c 0338A0E1 		lsl	r3, r3, #16
 163 0030 4328A0E1 		asr	r2, r3, #16
 164              		.loc 2 51 33
 165 0034 08301BE5 		ldr	r3, [fp, #-8]
 166 0038 B430D3E1 		ldrh	r3, [r3, #4]
 167 003c 0338A0E1 		lsl	r3, r3, #16
 168 0040 4338A0E1 		asr	r3, r3, #16
 169              		.loc 2 51 28
 170 0044 023003E0 		and	r3, r3, r2
 171 0048 0338A0E1 		lsl	r3, r3, #16
 172 004c 4338A0E1 		asr	r3, r3, #16
 173 0050 0338A0E1 		lsl	r3, r3, #16
 174 0054 2338A0E1 		lsr	r3, r3, #16
  52:trace32/../lib/byte_fifo.h **** }
 175              		.loc 2 52 1
 176 0058 0300A0E1 		mov	r0, r3
 177 005c 00D08BE2 		add	sp, fp, #0
 178              		.cfi_def_cfa_register 13
 179              		@ sp needed
 180 0060 04B09DE4 		ldr	fp, [sp], #4
 181              		.cfi_restore 11
 182              		.cfi_def_cfa_offset 0
 183 0064 1EFF2FE1 		bx	lr
 184              		.cfi_endproc
 185              	.LFE7:
 187              		.section	.text.byte_fifo_put,"ax",%progbits
 188              		.align	2
 189              		.syntax unified
 190              		.arm
 192              	byte_fifo_put:
 193              	.LFB8:
  53:trace32/../lib/byte_fifo.h **** 	
  54:trace32/../lib/byte_fifo.h **** static int byte_fifo_put(byte_fifo_t *fifo,unsigned char val)
  55:trace32/../lib/byte_fifo.h **** {
 194              		.loc 2 55 1
 195              		.cfi_startproc
 196              		@ Function supports interworking.
 197              		@ args = 0, pretend = 0, frame = 8
 198              		@ frame_needed = 1, uses_anonymous_args = 0
 199              		@ link register save eliminated.
 200 0000 04B02DE5 		str	fp, [sp, #-4]!
 201              		.cfi_def_cfa_offset 4
 202              		.cfi_offset 11, -4
 203 0004 00B08DE2 		add	fp, sp, #0
 204              		.cfi_def_cfa_register 11
 205 0008 0CD04DE2 		sub	sp, sp, #12
 206 000c 08000BE5 		str	r0, [fp, #-8]
 207 0010 0130A0E1 		mov	r3, r1
 208 0014 09304BE5 		strb	r3, [fp, #-9]
  56:trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
 209              		.loc 2 56 11
 210 0018 08301BE5 		ldr	r3, [fp, #-8]
 211 001c B230D3E1 		ldrh	r3, [r3, #2]
 212              		.loc 2 56 15
 213 0020 013083E2 		add	r3, r3, #1
 214              		.loc 2 56 24
 215 0024 08201BE5 		ldr	r2, [fp, #-8]
 216 0028 B420D2E1 		ldrh	r2, [r2, #4]
 217              		.loc 2 56 18
 218 002c 023003E0 		and	r3, r3, r2
 219              		.loc 2 56 40
 220 0030 08201BE5 		ldr	r2, [fp, #-8]
 221 0034 B020D2E1 		ldrh	r2, [r2]
 222              		.loc 2 56 4
 223 0038 020053E1 		cmp	r3, r2
 224 003c 0100001A 		bne	.L9
  57:trace32/../lib/byte_fifo.h **** 		return -1;
 225              		.loc 2 57 10
 226 0040 0030E0E3 		mvn	r3, #0
 227 0044 190000EA 		b	.L10
 228              	.L9:
  58:trace32/../lib/byte_fifo.h **** 	
  59:trace32/../lib/byte_fifo.h **** 	fifo->buf[fifo->wr]=val;
 229              		.loc 2 59 16
 230 0048 08301BE5 		ldr	r3, [fp, #-8]
 231 004c B230D3E1 		ldrh	r3, [r3, #2]
 232 0050 0320A0E1 		mov	r2, r3
 233              		.loc 2 59 21
 234 0054 08301BE5 		ldr	r3, [fp, #-8]
 235 0058 023083E0 		add	r3, r3, r2
 236 005c 09205BE5 		ldrb	r2, [fp, #-9]
 237 0060 0620C3E5 		strb	r2, [r3, #6]
  60:trace32/../lib/byte_fifo.h **** 	fifo->wr=(fifo->wr+1)&(fifo->mask);
 238              		.loc 2 60 16
 239 0064 08301BE5 		ldr	r3, [fp, #-8]
 240 0068 B230D3E1 		ldrh	r3, [r3, #2]
 241              		.loc 2 60 20
 242 006c 013083E2 		add	r3, r3, #1
 243 0070 0338A0E1 		lsl	r3, r3, #16
 244 0074 2338A0E1 		lsr	r3, r3, #16
 245 0078 0338A0E1 		lsl	r3, r3, #16
 246 007c 4328A0E1 		asr	r2, r3, #16
 247              		.loc 2 60 29
 248 0080 08301BE5 		ldr	r3, [fp, #-8]
 249 0084 B430D3E1 		ldrh	r3, [r3, #4]
 250 0088 0338A0E1 		lsl	r3, r3, #16
 251 008c 4338A0E1 		asr	r3, r3, #16
 252              		.loc 2 60 23
 253 0090 023003E0 		and	r3, r3, r2
 254 0094 0338A0E1 		lsl	r3, r3, #16
 255 0098 4338A0E1 		asr	r3, r3, #16
 256 009c 0338A0E1 		lsl	r3, r3, #16
 257 00a0 2328A0E1 		lsr	r2, r3, #16
 258              		.loc 2 60 10
 259 00a4 08301BE5 		ldr	r3, [fp, #-8]
 260 00a8 B220C3E1 		strh	r2, [r3, #2]	@ movhi
  61:trace32/../lib/byte_fifo.h **** 	return 0;
 261              		.loc 2 61 9
 262 00ac 0030A0E3 		mov	r3, #0
 263              	.L10:
  62:trace32/../lib/byte_fifo.h **** }
 264              		.loc 2 62 1
 265 00b0 0300A0E1 		mov	r0, r3
 266 00b4 00D08BE2 		add	sp, fp, #0
 267              		.cfi_def_cfa_register 13
 268              		@ sp needed
 269 00b8 04B09DE4 		ldr	fp, [sp], #4
 270              		.cfi_restore 11
 271              		.cfi_def_cfa_offset 0
 272 00bc 1EFF2FE1 		bx	lr
 273              		.cfi_endproc
 274              	.LFE8:
 276              		.section	.text.byte_fifo_get_possible,"ax",%progbits
 277              		.align	2
 278              		.syntax unified
 279              		.arm
 281              	byte_fifo_get_possible:
 282              	.LFB9:
  63:trace32/../lib/byte_fifo.h **** 
  64:trace32/../lib/byte_fifo.h **** static int byte_fifo_get_possible(byte_fifo_t *fifo)
  65:trace32/../lib/byte_fifo.h **** {
 283              		.loc 2 65 1
 284              		.cfi_startproc
 285              		@ Function supports interworking.
 286              		@ args = 0, pretend = 0, frame = 8
 287              		@ frame_needed = 1, uses_anonymous_args = 0
 288              		@ link register save eliminated.
 289 0000 04B02DE5 		str	fp, [sp, #-4]!
 290              		.cfi_def_cfa_offset 4
 291              		.cfi_offset 11, -4
 292 0004 00B08DE2 		add	fp, sp, #0
 293              		.cfi_def_cfa_register 11
 294 0008 0CD04DE2 		sub	sp, sp, #12
 295 000c 08000BE5 		str	r0, [fp, #-8]
  66:trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 296              		.loc 2 66 9
 297 0010 08301BE5 		ldr	r3, [fp, #-8]
 298 0014 B020D3E1 		ldrh	r2, [r3]
 299              		.loc 2 66 21
 300 0018 08301BE5 		ldr	r3, [fp, #-8]
 301 001c B230D3E1 		ldrh	r3, [r3, #2]
 302              		.loc 2 66 4
 303 0020 030052E1 		cmp	r2, r3
 304 0024 0100001A 		bne	.L12
  67:trace32/../lib/byte_fifo.h **** 		return -1;
 305              		.loc 2 67 10
 306 0028 0030E0E3 		mvn	r3, #0
 307 002c 000000EA 		b	.L13
 308              	.L12:
  68:trace32/../lib/byte_fifo.h **** 		
  69:trace32/../lib/byte_fifo.h **** 	return 0;
 309              		.loc 2 69 9
 310 0030 0030A0E3 		mov	r3, #0
 311              	.L13:
  70:trace32/../lib/byte_fifo.h **** }
 312              		.loc 2 70 1
 313 0034 0300A0E1 		mov	r0, r3
 314 0038 00D08BE2 		add	sp, fp, #0
 315              		.cfi_def_cfa_register 13
 316              		@ sp needed
 317 003c 04B09DE4 		ldr	fp, [sp], #4
 318              		.cfi_restore 11
 319              		.cfi_def_cfa_offset 0
 320 0040 1EFF2FE1 		bx	lr
 321              		.cfi_endproc
 322              	.LFE9:
 324              		.section	.text.byte_fifo_get,"ax",%progbits
 325              		.align	2
 326              		.syntax unified
 327              		.arm
 329              	byte_fifo_get:
 330              	.LFB10:
  71:trace32/../lib/byte_fifo.h **** 
  72:trace32/../lib/byte_fifo.h **** static int byte_fifo_get(byte_fifo_t *fifo,unsigned char *val)
  73:trace32/../lib/byte_fifo.h **** {
 331              		.loc 2 73 1
 332              		.cfi_startproc
 333              		@ Function supports interworking.
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 1, uses_anonymous_args = 0
 336              		@ link register save eliminated.
 337 0000 04B02DE5 		str	fp, [sp, #-4]!
 338              		.cfi_def_cfa_offset 4
 339              		.cfi_offset 11, -4
 340 0004 00B08DE2 		add	fp, sp, #0
 341              		.cfi_def_cfa_register 11
 342 0008 0CD04DE2 		sub	sp, sp, #12
 343 000c 08000BE5 		str	r0, [fp, #-8]
 344 0010 0C100BE5 		str	r1, [fp, #-12]
  74:trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 345              		.loc 2 74 9
 346 0014 08301BE5 		ldr	r3, [fp, #-8]
 347 0018 B020D3E1 		ldrh	r2, [r3]
 348              		.loc 2 74 21
 349 001c 08301BE5 		ldr	r3, [fp, #-8]
 350 0020 B230D3E1 		ldrh	r3, [r3, #2]
 351              		.loc 2 74 4
 352 0024 030052E1 		cmp	r2, r3
 353 0028 0100001A 		bne	.L15
  75:trace32/../lib/byte_fifo.h **** 		return -1;
 354              		.loc 2 75 10
 355 002c 0030E0E3 		mvn	r3, #0
 356 0030 1A0000EA 		b	.L16
 357              	.L15:
  76:trace32/../lib/byte_fifo.h **** 		
  77:trace32/../lib/byte_fifo.h **** 	*val=fifo->buf[fifo->rd];
 358              		.loc 2 77 21
 359 0034 08301BE5 		ldr	r3, [fp, #-8]
 360 0038 B030D3E1 		ldrh	r3, [r3]
 361 003c 0320A0E1 		mov	r2, r3
 362              		.loc 2 77 16
 363 0040 08301BE5 		ldr	r3, [fp, #-8]
 364 0044 023083E0 		add	r3, r3, r2
 365 0048 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 366              		.loc 2 77 6
 367 004c 0C301BE5 		ldr	r3, [fp, #-12]
 368 0050 0020C3E5 		strb	r2, [r3]
  78:trace32/../lib/byte_fifo.h **** 	fifo->rd=(fifo->rd+1)&(fifo->mask);
 369              		.loc 2 78 16
 370 0054 08301BE5 		ldr	r3, [fp, #-8]
 371 0058 B030D3E1 		ldrh	r3, [r3]
 372              		.loc 2 78 20
 373 005c 013083E2 		add	r3, r3, #1
 374 0060 0338A0E1 		lsl	r3, r3, #16
 375 0064 2338A0E1 		lsr	r3, r3, #16
 376 0068 0338A0E1 		lsl	r3, r3, #16
 377 006c 4328A0E1 		asr	r2, r3, #16
 378              		.loc 2 78 29
 379 0070 08301BE5 		ldr	r3, [fp, #-8]
 380 0074 B430D3E1 		ldrh	r3, [r3, #4]
 381 0078 0338A0E1 		lsl	r3, r3, #16
 382 007c 4338A0E1 		asr	r3, r3, #16
 383              		.loc 2 78 23
 384 0080 023003E0 		and	r3, r3, r2
 385 0084 0338A0E1 		lsl	r3, r3, #16
 386 0088 4338A0E1 		asr	r3, r3, #16
 387 008c 0338A0E1 		lsl	r3, r3, #16
 388 0090 2328A0E1 		lsr	r2, r3, #16
 389              		.loc 2 78 10
 390 0094 08301BE5 		ldr	r3, [fp, #-8]
 391 0098 B020C3E1 		strh	r2, [r3]	@ movhi
  79:trace32/../lib/byte_fifo.h **** 	return 0;
 392              		.loc 2 79 9
 393 009c 0030A0E3 		mov	r3, #0
 394              	.L16:
  80:trace32/../lib/byte_fifo.h **** }
 395              		.loc 2 80 1
 396 00a0 0300A0E1 		mov	r0, r3
 397 00a4 00D08BE2 		add	sp, fp, #0
 398              		.cfi_def_cfa_register 13
 399              		@ sp needed
 400 00a8 04B09DE4 		ldr	fp, [sp], #4
 401              		.cfi_restore 11
 402              		.cfi_def_cfa_offset 0
 403 00ac 1EFF2FE1 		bx	lr
 404              		.cfi_endproc
 405              	.LFE10:
 407              		.section	.text.byte_fifo_cb_put_possible,"ax",%progbits
 408              		.align	2
 409              		.syntax unified
 410              		.arm
 412              	byte_fifo_cb_put_possible:
 413              	.LFB11:
 414              		.file 3 "trace32/../lib/byte_fifo_cb.h"
   1:trace32/../lib/byte_fifo_cb.h **** /* Byte FIFO with CallBack
   2:trace32/../lib/byte_fifo_cb.h ****  *
   3:trace32/../lib/byte_fifo_cb.h ****  * Appends the Byte_Fifo with a callback function, which is called
   4:trace32/../lib/byte_fifo_cb.h ****  * when putting some stuff into the fifo (e.g. Enable transmitting interrupt)
   5:trace32/../lib/byte_fifo_cb.h ****  */
   6:trace32/../lib/byte_fifo_cb.h **** 
   7:trace32/../lib/byte_fifo_cb.h **** #ifndef __BYTE_FIFO_CB_H__
   8:trace32/../lib/byte_fifo_cb.h **** #define __BYTE_FIFO_CB_H__
   9:trace32/../lib/byte_fifo_cb.h **** 
  10:trace32/../lib/byte_fifo_cb.h **** #include "byte_fifo.h"
  11:trace32/../lib/byte_fifo_cb.h **** 
  12:trace32/../lib/byte_fifo_cb.h **** typedef void (*byte_fifo_cb)(void);
  13:trace32/../lib/byte_fifo_cb.h **** 
  14:trace32/../lib/byte_fifo_cb.h **** typedef struct {
  15:trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_cb cb;
  16:trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_t  byte_fifo; //Aufgrund des Flexible Array Member hier hinter keine weiteren Strukturel
  17:trace32/../lib/byte_fifo_cb.h **** } byte_fifo_cb_t;
  18:trace32/../lib/byte_fifo_cb.h **** 
  19:trace32/../lib/byte_fifo_cb.h **** #define BYTE_FIFO_CB_INIT(size,func)  (byte_fifo_cb_t) {.cb=func, \
  20:trace32/../lib/byte_fifo_cb.h ****                                                         .byte_fifo=BYTE_FIFO_INIT(size) \
  21:trace32/../lib/byte_fifo_cb.h **** 									    			   }
  22:trace32/../lib/byte_fifo_cb.h **** 
  23:trace32/../lib/byte_fifo_cb.h **** size_t byte_fifo_cb_putsize(byte_fifo_cb_t *fifo,const unsigned char *start,size_t len);
  24:trace32/../lib/byte_fifo_cb.h **** 
  25:trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic push
  26:trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  27:trace32/../lib/byte_fifo_cb.h **** 
  28:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put_possible(byte_fifo_cb_t *fifo)
  29:trace32/../lib/byte_fifo_cb.h **** {
 415              		.loc 3 29 1
 416              		.cfi_startproc
 417              		@ Function supports interworking.
 418              		@ args = 0, pretend = 0, frame = 8
 419              		@ frame_needed = 1, uses_anonymous_args = 0
 420 0000 00482DE9 		push	{fp, lr}
 421              		.cfi_def_cfa_offset 8
 422              		.cfi_offset 11, -8
 423              		.cfi_offset 14, -4
 424 0004 04B08DE2 		add	fp, sp, #4
 425              		.cfi_def_cfa 11, 4
 426 0008 08D04DE2 		sub	sp, sp, #8
 427 000c 08000BE5 		str	r0, [fp, #-8]
  30:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_put_possible(&fifo->byte_fifo);
 428              		.loc 3 30 9
 429 0010 08301BE5 		ldr	r3, [fp, #-8]
 430 0014 043083E2 		add	r3, r3, #4
 431 0018 0300A0E1 		mov	r0, r3
 432 001c 18309FE5 		ldr	r3, .L19
 433 0020 0FE0A0E1 		mov	lr, pc
 434 0024 13FF2FE1 		bx	r3
 435              	.LVL0:
 436 0028 0030A0E1 		mov	r3, r0
  31:trace32/../lib/byte_fifo_cb.h **** }
 437              		.loc 3 31 1
 438 002c 0300A0E1 		mov	r0, r3
 439 0030 04D04BE2 		sub	sp, fp, #4
 440              		.cfi_def_cfa 13, 8
 441              		@ sp needed
 442 0034 0048BDE8 		pop	{fp, lr}
 443              		.cfi_restore 14
 444              		.cfi_restore 11
 445              		.cfi_def_cfa_offset 0
 446 0038 1EFF2FE1 		bx	lr
 447              	.L20:
 448              		.align	2
 449              	.L19:
 450 003c 00000000 		.word	byte_fifo_put_possible
 451              		.cfi_endproc
 452              	.LFE11:
 454              		.section	.text.byte_fifo_cb_put,"ax",%progbits
 455              		.align	2
 456              		.syntax unified
 457              		.arm
 459              	byte_fifo_cb_put:
 460              	.LFB12:
  32:trace32/../lib/byte_fifo_cb.h **** 	
  33:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put(byte_fifo_cb_t *fifo,unsigned char val)
  34:trace32/../lib/byte_fifo_cb.h **** {
 461              		.loc 3 34 1
 462              		.cfi_startproc
 463              		@ Function supports interworking.
 464              		@ args = 0, pretend = 0, frame = 16
 465              		@ frame_needed = 1, uses_anonymous_args = 0
 466 0000 00482DE9 		push	{fp, lr}
 467              		.cfi_def_cfa_offset 8
 468              		.cfi_offset 11, -8
 469              		.cfi_offset 14, -4
 470 0004 04B08DE2 		add	fp, sp, #4
 471              		.cfi_def_cfa 11, 4
 472 0008 10D04DE2 		sub	sp, sp, #16
 473 000c 10000BE5 		str	r0, [fp, #-16]
 474 0010 0130A0E1 		mov	r3, r1
 475 0014 11304BE5 		strb	r3, [fp, #-17]
  35:trace32/../lib/byte_fifo_cb.h **** 	int ret=byte_fifo_put(&fifo->byte_fifo,val);
 476              		.loc 3 35 10
 477 0018 10301BE5 		ldr	r3, [fp, #-16]
 478 001c 043083E2 		add	r3, r3, #4
 479 0020 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 480 0024 0210A0E1 		mov	r1, r2
 481 0028 0300A0E1 		mov	r0, r3
 482 002c 48309FE5 		ldr	r3, .L24
 483 0030 0FE0A0E1 		mov	lr, pc
 484 0034 13FF2FE1 		bx	r3
 485              	.LVL1:
 486 0038 08000BE5 		str	r0, [fp, #-8]
  36:trace32/../lib/byte_fifo_cb.h **** 	if( !ret && fifo->cb)
 487              		.loc 3 36 4
 488 003c 08301BE5 		ldr	r3, [fp, #-8]
 489 0040 000053E3 		cmp	r3, #0
 490 0044 0700001A 		bne	.L22
 491              		.loc 3 36 18 discriminator 1
 492 0048 10301BE5 		ldr	r3, [fp, #-16]
 493 004c 003093E5 		ldr	r3, [r3]
 494              		.loc 3 36 11 discriminator 1
 495 0050 000053E3 		cmp	r3, #0
 496 0054 0300000A 		beq	.L22
  37:trace32/../lib/byte_fifo_cb.h **** 		fifo->cb();
 497              		.loc 3 37 7
 498 0058 10301BE5 		ldr	r3, [fp, #-16]
 499 005c 003093E5 		ldr	r3, [r3]
 500              		.loc 3 37 3
 501 0060 0FE0A0E1 		mov	lr, pc
 502 0064 13FF2FE1 		bx	r3
 503              	.LVL2:
 504              	.L22:
  38:trace32/../lib/byte_fifo_cb.h **** 	return ret;
 505              		.loc 3 38 9
 506 0068 08301BE5 		ldr	r3, [fp, #-8]
  39:trace32/../lib/byte_fifo_cb.h **** }
 507              		.loc 3 39 1
 508 006c 0300A0E1 		mov	r0, r3
 509 0070 04D04BE2 		sub	sp, fp, #4
 510              		.cfi_def_cfa 13, 8
 511              		@ sp needed
 512 0074 0048BDE8 		pop	{fp, lr}
 513              		.cfi_restore 14
 514              		.cfi_restore 11
 515              		.cfi_def_cfa_offset 0
 516 0078 1EFF2FE1 		bx	lr
 517              	.L25:
 518              		.align	2
 519              	.L24:
 520 007c 00000000 		.word	byte_fifo_put
 521              		.cfi_endproc
 522              	.LFE12:
 524              		.section	.text.byte_fifo_cb_get_possible,"ax",%progbits
 525              		.align	2
 526              		.syntax unified
 527              		.arm
 529              	byte_fifo_cb_get_possible:
 530              	.LFB13:
  40:trace32/../lib/byte_fifo_cb.h **** 
  41:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get_possible(byte_fifo_cb_t *fifo)
  42:trace32/../lib/byte_fifo_cb.h **** {
 531              		.loc 3 42 1
 532              		.cfi_startproc
 533              		@ Function supports interworking.
 534              		@ args = 0, pretend = 0, frame = 8
 535              		@ frame_needed = 1, uses_anonymous_args = 0
 536 0000 00482DE9 		push	{fp, lr}
 537              		.cfi_def_cfa_offset 8
 538              		.cfi_offset 11, -8
 539              		.cfi_offset 14, -4
 540 0004 04B08DE2 		add	fp, sp, #4
 541              		.cfi_def_cfa 11, 4
 542 0008 08D04DE2 		sub	sp, sp, #8
 543 000c 08000BE5 		str	r0, [fp, #-8]
  43:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get_possible(&fifo->byte_fifo);
 544              		.loc 3 43 9
 545 0010 08301BE5 		ldr	r3, [fp, #-8]
 546 0014 043083E2 		add	r3, r3, #4
 547 0018 0300A0E1 		mov	r0, r3
 548 001c 18309FE5 		ldr	r3, .L28
 549 0020 0FE0A0E1 		mov	lr, pc
 550 0024 13FF2FE1 		bx	r3
 551              	.LVL3:
 552 0028 0030A0E1 		mov	r3, r0
  44:trace32/../lib/byte_fifo_cb.h **** }
 553              		.loc 3 44 1
 554 002c 0300A0E1 		mov	r0, r3
 555 0030 04D04BE2 		sub	sp, fp, #4
 556              		.cfi_def_cfa 13, 8
 557              		@ sp needed
 558 0034 0048BDE8 		pop	{fp, lr}
 559              		.cfi_restore 14
 560              		.cfi_restore 11
 561              		.cfi_def_cfa_offset 0
 562 0038 1EFF2FE1 		bx	lr
 563              	.L29:
 564              		.align	2
 565              	.L28:
 566 003c 00000000 		.word	byte_fifo_get_possible
 567              		.cfi_endproc
 568              	.LFE13:
 570              		.section	.text.byte_fifo_cb_get,"ax",%progbits
 571              		.align	2
 572              		.syntax unified
 573              		.arm
 575              	byte_fifo_cb_get:
 576              	.LFB14:
  45:trace32/../lib/byte_fifo_cb.h **** 
  46:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get(byte_fifo_cb_t *fifo,unsigned char *val)
  47:trace32/../lib/byte_fifo_cb.h **** {
 577              		.loc 3 47 1
 578              		.cfi_startproc
 579              		@ Function supports interworking.
 580              		@ args = 0, pretend = 0, frame = 8
 581              		@ frame_needed = 1, uses_anonymous_args = 0
 582 0000 00482DE9 		push	{fp, lr}
 583              		.cfi_def_cfa_offset 8
 584              		.cfi_offset 11, -8
 585              		.cfi_offset 14, -4
 586 0004 04B08DE2 		add	fp, sp, #4
 587              		.cfi_def_cfa 11, 4
 588 0008 08D04DE2 		sub	sp, sp, #8
 589 000c 08000BE5 		str	r0, [fp, #-8]
 590 0010 0C100BE5 		str	r1, [fp, #-12]
  48:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get(&fifo->byte_fifo,val);
 591              		.loc 3 48 9
 592 0014 08301BE5 		ldr	r3, [fp, #-8]
 593 0018 043083E2 		add	r3, r3, #4
 594 001c 0C101BE5 		ldr	r1, [fp, #-12]
 595 0020 0300A0E1 		mov	r0, r3
 596 0024 18309FE5 		ldr	r3, .L32
 597 0028 0FE0A0E1 		mov	lr, pc
 598 002c 13FF2FE1 		bx	r3
 599              	.LVL4:
 600 0030 0030A0E1 		mov	r3, r0
  49:trace32/../lib/byte_fifo_cb.h **** }
 601              		.loc 3 49 1
 602 0034 0300A0E1 		mov	r0, r3
 603 0038 04D04BE2 		sub	sp, fp, #4
 604              		.cfi_def_cfa 13, 8
 605              		@ sp needed
 606 003c 0048BDE8 		pop	{fp, lr}
 607              		.cfi_restore 14
 608              		.cfi_restore 11
 609              		.cfi_def_cfa_offset 0
 610 0040 1EFF2FE1 		bx	lr
 611              	.L33:
 612              		.align	2
 613              	.L32:
 614 0044 00000000 		.word	byte_fifo_get
 615              		.cfi_endproc
 616              	.LFE14:
 618              		.global	main_data
 619              		.bss
 620              		.align	2
 623              	main_data:
 624 0000 000000   		.space	3
 625              		.section	.text._exit,"ax",%progbits
 626              		.align	2
 627              		.global	_exit
 628              		.syntax unified
 629              		.arm
 631              	_exit:
 632              	.LFB15:
   1:main.c        **** #include <stdint.h>
   2:main.c        **** #include <stdio.h>
   3:main.c        **** #include <string.h>
   4:main.c        **** #include <unistd.h> //fuer _exit() usleep()
   5:main.c        **** 
   6:main.c        **** // Ausführungsumgebung 'automatisch' erkennen
   7:main.c        **** #if defined(MODE_RAM) || defined(MODE_ROM) || defined(MODE_SIM)
   8:main.c        **** #define NXT
   9:main.c        **** #else
  10:main.c        **** #define COMPILER_EXPLORER
  11:main.c        **** #endif
  12:main.c        **** 
  13:main.c        **** #ifdef NXT
  14:main.c        **** #include "AT91SAM7S64.h"
  15:main.c        **** #include "lib/aic.h"
  16:main.c        **** #include "lib/display.h"
  17:main.c        **** #include "lib/nxt_avr.h"
  18:main.c        **** #include "lib/systick.h"
  19:main.c        **** #include "lib/term.h"
  20:main.c        **** #include "main.h"
  21:main.c        **** // #include "lib/adc.h"
  22:main.c        **** #if defined(MODE_RAM) || defined(MODE_SIM)
  23:main.c        **** #include "trace32/udmon3.h"
  24:main.c        **** #endif
  25:main.c        **** 
  26:main.c        **** #define ZYKLUS_MS 4
  27:main.c        **** #define IDLE_MS 2
  28:main.c        **** #define HERZSCHLAG_PORT SENSOR_2 // SENSOR_1...4
  29:main.c        **** #if IDLE_MS >= ZYKLUS_MS
  30:main.c        **** #error "Idle_ms muss kleiner als zyklus_ms sein"
  31:main.c        **** #endif
  32:main.c        **** #endif
  33:main.c        **** #ifdef COMPILER_EXPLORER
  34:main.c        **** uint32_t systick_get_ms(void);
  35:main.c        **** #endif
  36:main.c        **** 
  37:main.c        **** /*****************************************************************************/
  38:main.c        **** /*   Globale Variablen                                                       */
  39:main.c        **** /*****************************************************************************/
  40:main.c        **** #ifdef NXT
  41:main.c        **** struct {
  42:main.c        ****   signed char term_status; // 0->false->Alles Bestens   -1->true->Overflow
  43:main.c        ****   unsigned char term_cnt;
  44:main.c        ****   unsigned char lowbat_cnt;
  45:main.c        **** } main_data = {
  46:main.c        ****     .term_status = 0,
  47:main.c        ****     .term_cnt = 0,
  48:main.c        ****     .lowbat_cnt = 0,
  49:main.c        **** };
  50:main.c        **** #endif
  51:main.c        **** 
  52:main.c        **** /*****************************************************************************/
  53:main.c        **** /*   Hilfsroutinen                                                           */
  54:main.c        **** /*   Standard-C-Library (weitere befinden sich in newlib_syscalls.c)         */
  55:main.c        **** /*****************************************************************************/
  56:main.c        **** // Routine wird von C-Lib aufgerufen (bspw. printf() abort())
  57:main.c        **** #ifdef NXT
  58:main.c        **** void _exit(int status) {
 633              		.loc 1 58 24
 634              		.cfi_startproc
 635              		@ Function supports interworking.
 636              		@ args = 0, pretend = 0, frame = 8
 637              		@ frame_needed = 1, uses_anonymous_args = 0
 638              		@ link register save eliminated.
 639 0000 04B02DE5 		str	fp, [sp, #-4]!
 640              		.cfi_def_cfa_offset 4
 641              		.cfi_offset 11, -4
 642 0004 00B08DE2 		add	fp, sp, #0
 643              		.cfi_def_cfa_register 11
 644 0008 0CD04DE2 		sub	sp, sp, #12
 645 000c 08000BE5 		str	r0, [fp, #-8]
 646              	.L35:
  59:main.c        ****   (void)status;
  60:main.c        ****   // LED-Blinken lassen
  61:main.c        ****   // Breakpoint setzen
  62:main.c        ****   while (1)
 647              		.loc 1 62 9
 648 0010 0000A0E1 		nop
 649 0014 FDFFFFEA 		b	.L35
 650              		.cfi_endproc
 651              	.LFE15:
 653              		.global	trace_buf0
 654              		.bss
 655 0003 00       		.align	2
 658              	trace_buf0:
 659 0004 00000000 		.space	400
 659      00000000 
 659      00000000 
 659      00000000 
 659      00000000 
 660              		.global	trace_buf1
 661              		.align	2
 664              	trace_buf1:
 665 0194 00000000 		.space	400
 665      00000000 
 665      00000000 
 665      00000000 
 665      00000000 
 666              		.section	.text.trace_scope,"ax",%progbits
 667              		.align	2
 668              		.global	trace_scope
 669              		.syntax unified
 670              		.arm
 672              	trace_scope:
 673              	.LFB16:
  63:main.c        ****     ;
  64:main.c        **** }
  65:main.c        **** #endif
  66:main.c        **** /************************************************************************/
  67:main.c        **** /*   Hilfsroutine zur Darstellung eines analogen Verlaufes entsprechend */
  68:main.c        **** /*   einem Oszillosop                                                   */
  69:main.c        **** /************************************************************************/
  70:main.c        **** #ifdef NXT
  71:main.c        **** #define TRACE_SIZE 200
  72:main.c        **** int16_t trace_buf0[TRACE_SIZE];
  73:main.c        **** int16_t trace_buf1[TRACE_SIZE];
  74:main.c        **** // Darstellung des Puffers über 'v.draw %e trace_buf0 trace_buf1'
  75:main.c        **** void trace_scope(int channel, int16_t value) {
 674              		.loc 1 75 46
 675              		.cfi_startproc
 676              		@ Function supports interworking.
 677              		@ args = 0, pretend = 0, frame = 8
 678              		@ frame_needed = 1, uses_anonymous_args = 0
 679              		@ link register save eliminated.
 680 0000 04B02DE5 		str	fp, [sp, #-4]!
 681              		.cfi_def_cfa_offset 4
 682              		.cfi_offset 11, -4
 683 0004 00B08DE2 		add	fp, sp, #0
 684              		.cfi_def_cfa_register 11
 685 0008 0CD04DE2 		sub	sp, sp, #12
 686 000c 08000BE5 		str	r0, [fp, #-8]
 687 0010 0130A0E1 		mov	r3, r1
 688 0014 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
  76:main.c        ****   // #define TRACE_ROLL
  77:main.c        **** #ifdef TRACE_ROLL
  78:main.c        ****   if (channel == 0) {
  79:main.c        ****     for (int lauf = 0; lauf < (TRACE_SIZE - 1); lauf++)
  80:main.c        ****       trace_buf0[lauf] = trace_buf0[lauf + 1];
  81:main.c        ****     trace_buf0[TRACE_SIZE - 1] = value;
  82:main.c        ****   } else {
  83:main.c        ****     for (int lauf = 0; lauf < (TRACE_SIZE - 1); lauf++)
  84:main.c        ****       trace_buf1[lauf] = trace_buf1[lauf + 1];
  85:main.c        ****     trace_buf1[TRACE_SIZE - 1] = value;
  86:main.c        ****   }
  87:main.c        **** #else
  88:main.c        ****   static int trace_index = 0;
  89:main.c        ****   if (trace_index < TRACE_SIZE) {
 689              		.loc 1 89 19
 690 0018 A8309FE5 		ldr	r3, .L43
 691 001c 003093E5 		ldr	r3, [r3]
 692              		.loc 1 89 6
 693 0020 C70053E3 		cmp	r3, #199
 694 0024 110000CA 		bgt	.L37
  90:main.c        ****     if (channel == 0)
 695              		.loc 1 90 8
 696 0028 08301BE5 		ldr	r3, [fp, #-8]
 697 002c 000053E3 		cmp	r3, #0
 698 0030 0700001A 		bne	.L38
  91:main.c        ****       trace_buf0[trace_index] = value;
 699              		.loc 1 91 17
 700 0034 8C309FE5 		ldr	r3, .L43
 701 0038 003093E5 		ldr	r3, [r3]
 702              		.loc 1 91 31
 703 003c 88209FE5 		ldr	r2, .L43+4
 704 0040 8330A0E1 		lsl	r3, r3, #1
 705 0044 033082E0 		add	r3, r2, r3
 706 0048 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 707 004c B020C3E1 		strh	r2, [r3]	@ movhi
 708 0050 060000EA 		b	.L37
 709              	.L38:
  92:main.c        ****     else
  93:main.c        ****       trace_buf1[trace_index] = value;
 710              		.loc 1 93 17
 711 0054 6C309FE5 		ldr	r3, .L43
 712 0058 003093E5 		ldr	r3, [r3]
 713              		.loc 1 93 31
 714 005c 6C209FE5 		ldr	r2, .L43+8
 715 0060 8330A0E1 		lsl	r3, r3, #1
 716 0064 033082E0 		add	r3, r2, r3
 717 0068 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 718 006c B020C3E1 		strh	r2, [r3]	@ movhi
 719              	.L37:
  94:main.c        ****   } else {
  95:main.c        ****     // Pause, damit der Debugger in 'Ruhe' den gesamten Speicher auslesen kann
  96:main.c        ****   }
  97:main.c        ****   if (channel == 1) {
 720              		.loc 1 97 6
 721 0070 08301BE5 		ldr	r3, [fp, #-8]
 722 0074 010053E3 		cmp	r3, #1
 723 0078 0E00001A 		bne	.L42
  98:main.c        ****     trace_index++;
 724              		.loc 1 98 16
 725 007c 44309FE5 		ldr	r3, .L43
 726 0080 003093E5 		ldr	r3, [r3]
 727 0084 013083E2 		add	r3, r3, #1
 728 0088 38209FE5 		ldr	r2, .L43
 729 008c 003082E5 		str	r3, [r2]
  99:main.c        ****     trace_index = trace_index >= (3 * TRACE_SIZE) ? 0 : trace_index;
 730              		.loc 1 99 31
 731 0090 30309FE5 		ldr	r3, .L43
 732 0094 003093E5 		ldr	r3, [r3]
 733              		.loc 1 99 55
 734 0098 960F53E3 		cmp	r3, #600
 735 009c 020000AA 		bge	.L40
 736              		.loc 1 99 55 is_stmt 0 discriminator 1
 737 00a0 20309FE5 		ldr	r3, .L43
 738 00a4 003093E5 		ldr	r3, [r3]
 739 00a8 000000EA 		b	.L41
 740              	.L40:
 741              		.loc 1 99 55 discriminator 2
 742 00ac 0030A0E3 		mov	r3, #0
 743              	.L41:
 744              		.loc 1 99 17 is_stmt 1 discriminator 4
 745 00b0 10209FE5 		ldr	r2, .L43
 746 00b4 003082E5 		str	r3, [r2]
 747              	.L42:
 100:main.c        ****   }
 101:main.c        **** #endif
 102:main.c        **** }
 748              		.loc 1 102 1
 749 00b8 0000A0E1 		nop
 750 00bc 00D08BE2 		add	sp, fp, #0
 751              		.cfi_def_cfa_register 13
 752              		@ sp needed
 753 00c0 04B09DE4 		ldr	fp, [sp], #4
 754              		.cfi_restore 11
 755              		.cfi_def_cfa_offset 0
 756 00c4 1EFF2FE1 		bx	lr
 757              	.L44:
 758              		.align	2
 759              	.L43:
 760 00c8 24030000 		.word	trace_index.4
 761 00cc 00000000 		.word	trace_buf0
 762 00d0 00000000 		.word	trace_buf1
 763              		.cfi_endproc
 764              	.LFE16:
 766              		.global	h
 767              		.data
 768              		.align	2
 771              	h:
 772 0000 0000     		.short	0
 773 0002 00000000 		.space	254
 773      00000000 
 773      00000000 
 773      00000000 
 773      00000000 
 774 0100 00000000 		.word	0
 775 0104 00000000 		.word	0
 776 0108 00000000 		.word	0
 777 010c 32000000 		.word	50
 778 0110 00000000 		.word	0
 779 0114 00000000 		.word	0
 780 0118 00000000 		.word	0
 781 011c 00       		.byte	0
 782 011d 000000   		.space	3
 783              		.section	.rodata
 784              		.align	2
 785              	.LC0:
 786 0000 42504D3A 		.ascii	"BPM: %d\012\000"
 786      2025640A 
 786      00
 787              		.section	.text.herzschlag_process,"ax",%progbits
 788              		.align	2
 789              		.global	herzschlag_process
 790              		.syntax unified
 791              		.arm
 793              	herzschlag_process:
 794              	.LFB17:
 103:main.c        **** #endif
 104:main.c        **** #ifdef COMPILER_EXPLORER
 105:main.c        **** void trace_scope(int mode, uint16_t value) {
 106:main.c        ****   static int pos0 = 0;
 107:main.c        ****   static int pos1 = 0;
 108:main.c        ****   int val = (value - 450) / 4;
 109:main.c        ****   val = val > 80 ? 80 : (val < 0 ? 0 : val);
 110:main.c        ****   if (mode == 0) {
 111:main.c        ****     pos0 = val;
 112:main.c        ****   } else {
 113:main.c        ****     pos1 = val;
 114:main.c        ****     if (pos1 == pos0) {
 115:main.c        ****       printf("%*c\n", pos0, '+');
 116:main.c        ****     } else if (pos1 > pos0) {
 117:main.c        ****       printf("%*c%*c\n", pos0, '*', pos1 - pos0, '-');
 118:main.c        ****     } else {
 119:main.c        ****       printf("%*c%*c\n", pos1, '-', pos0 - pos1, '*');
 120:main.c        ****     }
 121:main.c        ****   }
 122:main.c        **** }
 123:main.c        **** #endif
 124:main.c        **** #if defined MODE_SIM || defined COMPILER_EXPLORER
 125:main.c        **** // Nachfolgendes Const-Array enthält Rohdaten und 'ersetzt' den AD-Wanderl
 126:main.c        **** uint16_t simuli_idx = 0;
 127:main.c        **** const uint16_t simuli[] = {
 128:main.c        ****     595, 596, 594, 586, 578, 568, 555, 545, 532, 524, 516, 507, 499, 493, 487,
 129:main.c        ****     481, 476, 473, 471, 471, 473, 481, 487, 503, 513, 517, 518, 516, 515, 511,
 130:main.c        ****     507, 502, 497, 492, 489, 484, 479, 476, 473, 470, 468, 467, 467, 466, 467,
 131:main.c        ****     466, 465, 465, 465, 465, 465, 466, 466, 446, 440, 439, 440, 442, 447, 452,
 132:main.c        ****     455, 460, 463, 467, 470, 471, 472, 474, 474, 474, 473, 472, 471, 469, 468,
 133:main.c        ****     468, 467, 466, 465, 465, 465, 464, 465, 466, 466, 488, 495, 497, 499, 500,
 134:main.c        ****     505, 510, 518, 531, 543, 560, 572, 582, 591, 596, 598, 595, 591, 582, 572,
 135:main.c        ****     563, 550, 540, 527, 518, 512, 503, 497, 490, 484, 476, 469, 448, 436, 435,
 136:main.c        ****     437, 441, 447, 455, 462, 469, 475, 480, 485, 485, 485, 484, 481, 479, 476,
 137:main.c        ****     471, 467, 465, 461, 459, 457, 455, 455, 453, 454, 455, 456, 457, 461, 467,
 138:main.c        ****     468, 486, 490, 491, 489, 486, 483, 478, 474, 471, 466, 464, 462, 461, 460,
 139:main.c        ****     459, 459, 460, 461, 462, 463, 464, 465, 467, 467, 467, 467, 467, 467, 467,
 140:main.c        ****     462, 445, 440, 439, 440, 443, 446, 449, 456, 462, 471, 480, 490, 508, 524,
 141:main.c        ****     543, 558, 577, 586, 593, 597, 597, 592, 585, 575, 562, 552, 539, 530, 521,
 142:main.c        ****     511, 506, 501, 514, 515, 512, 507, 499, 492, 486, 480, 477, 475, 475, 477,
 143:main.c        ****     480, 482, 483, 484, 486, 485, 484, 483, 480, 478, 474, 471, 469, 467, 464,
 144:main.c        ****     461, 462, 462, 462, 463, 441, 436, 436, 439, 443, 447, 451, 455, 459, 461,
 145:main.c        ****     464, 465, 465, 467, 467, 466, 466, 465, 465, 466, 466, 466, 466, 466, 467,
 146:main.c        ****     467, 466, 467, 467, 466, 466, 467, 473, 477, 488, 493, 493, 492, 489, 486,
 147:main.c        ****     483, 481, 481, 480, 482, 486, 491, 501, 513, 525, 544, 556, 575, 587, 597,
 148:main.c        ****     605, 608, 606, 601, 595, 587, 578, 570, 555, 532, 516, 509, 505, 501, 499,
 149:main.c        ****     496, 493, 492, 490, 490, 490, 493, 494, 498, 501, 504, 507, 508, 508, 506,
 150:main.c        ****     503, 500, 497, 493, 490, 486, 482, 480, 477, 475, 476, 491, 498, 498, 496,
 151:main.c        ****     493, 489, 484, 482, 479, 474, 472, 470, 468, 468, 468, 468, 469, 470, 472,
 152:main.c        ****     472, 472, 473, 474, 473, 475, 474, 475, 475, 475, 475, 474, 469, 451, 443,
 153:main.c        ****     442, 442, 445, 447, 451, 455, 459, 463, 466, 470, 472, 475, 477, 480, 484,
 154:main.c        ****     488, 496, 508, 519, 531, 549, 561, 574, 581, 586, 587, 583, 576, 567, 558,
 155:main.c        ****     552, 544, 549, 544, 536, 529, 520, 510, 502, 492, 486, 481, 475, 473, 474,
 156:main.c        ****     475, 477, 482, 485, 490, 493, 496, 497, 498, 497, 496, 494, 491, 487, 483,
 157:main.c        ****     480, 470, 451, 443, 438, 438, 440, 443, 446, 451, 456, 461, 464, 469, 472,
 158:main.c        ****     474, 476, 477, 478, 478, 478, 478, 478, 478, 479, 479, 478, 479, 479, 478,
 159:main.c        ****     479, 478, 477, 479, 495, 501, 500, 498, 494, 490, 485, 480, 476, 472, 469,
 160:main.c        ****     466, 463, 463, 462, 462, 463, 465, 466, 471, 476, 483, 494, 506, 525, 540,
 161:main.c        ****     554, 571, 580, 588, 590, 588, 559, 547, 533, 523, 516, 507, 504, 499, 494,
 162:main.c        ****     492, 490, 488, 485, 480, 476, 472, 467, 463, 461, 461, 461, 465, 468, 472,
 163:main.c        ****     474, 478, 479, 480, 480, 479, 477, 475, 478, 478, 488, 489, 487, 485, 480,
 164:main.c        ****     477, 472, 469, 465, 460, 457, 456, 454, 453, 452, 452, 451, 451, 453, 452,
 165:main.c        ****     453, 454, 455, 455, 455, 455, 454, 454, 454, 450, 433, 426, 426, 427, 430,
 166:main.c        ****     433, 438, 442, 447, 450, 453, 456, 459, 461, 461, 462, 462, 463, 462, 462,
 167:main.c        ****     463, 463, 465, 467, 472, 477, 490, 501, 520, 536, 556, 572, 601, 622, 628,
 168:main.c        ****     629, 624, 615, 600, 586, 567, 555, 543, 527, 519, 509, 502, 496, 489, 483,
 169:main.c        ****     475, 470, 466, 463, 462, 463, 463, 465, 470, 472, 474, 476, 477, 474, 457,
 170:main.c        ****     449, 445, 444, 445, 447, 448, 449, 451, 452, 454, 456, 457, 459, 461, 461,
 171:main.c        ****     462, 461, 459, 459, 459, 457, 457, 455, 455, 456, 455, 456, 455, 456, 457,
 172:main.c        ****     460, 464, 471, 482, 486, 488, 486, 484, 482, 478, 474, 470, 467, 465, 461,
 173:main.c        ****     459, 456, 453, 452, 451, 449, 449, 449, 449, 451, 454, 455, 459, 461, 465,
 174:main.c        ****     472, 479, 486, 483, 493, 511, 527, 546, 558, 569, 576, 579, 577, 572, 565,
 175:main.c        ****     555, 546, 534, 527, 519, 511, 502, 497, 493, 487, 480, 475, 471, 467, 465,
 176:main.c        ****     464, 466, 467, 472, 475, 500, 508, 512, 512, 509, 504, 499, 494, 487, 483,
 177:main.c        ****     479, 473, 470, 467, 465, 464, 464, 464, 465, 466, 468, 470, 473, 472, 474,
 178:main.c        ****     475, 474, 474, 474, 472, 471, 467, 444, 439, 436, 436, 438, 441, 445, 449,
 179:main.c        ****     454, 458, 463, 466, 468, 470, 471, 472, 472, 471, 470, 469, 468, 467, 465,
 180:main.c        ****     464, 464, 463, 462, 463, 463, 464, 466, 471, 481, 493, 513, 534, 548, 561,
 181:main.c        ****     576, 587, 595, 598, 598, 594, 587, 577, 567, 553, 543, 532, 521, 514, 510,
 182:main.c        ****     504, 500, 494, 491, 487, 482, 478, 474, 470, 469, 466, 450, 445, 447, 452,
 183:main.c        ****     457, 462, 468, 473, 478, 480, 482, 483, 482, 480, 479, 476, 474, 473, 471,
 184:main.c        ****     470, 468, 466, 466, 466, 466, 467, 466, 467, 467, 469, 469, 470, 491, 496,
 185:main.c        ****     497, 494, 491, 486, 482, 478, 472, 469, 465, 463, 461, 459, 458, 458, 458,
 186:main.c        ****     457, 458, 458, 459, 459, 459, 459, 460, 460, 460, 460, 460, 460, 459, 455,
 187:main.c        ****     440, 433, 434, 440, 445, 455, 472, 487, 504, 527, 545, 566, 579, 588, 595,
 188:main.c        ****     596};
 189:main.c        **** #endif
 190:main.c        **** /*****************************************************************************/
 191:main.c        **** /*   Ihr Programm                                                            */
 192:main.c        **** /*****************************************************************************/
 193:main.c        **** #define true 1
 194:main.c        **** #define false 0
 195:main.c        **** 
 196:main.c        **** struct {
 197:main.c        ****   uint16_t ad_buf[128];
 198:main.c        ****   int ad_idx;
 199:main.c        ****   int sum;
 200:main.c        ****   int avg;
 201:main.c        ****   int offset;
 202:main.c        ****   uint32_t lastBeat;
 203:main.c        ****   uint32_t begin;
 204:main.c        ****   uint32_t end;
 205:main.c        ****   _Bool onBeat;
 206:main.c        **** } h = {
 207:main.c        ****     .ad_buf = {0},
 208:main.c        ****     .ad_idx = 0,
 209:main.c        ****     .sum = 0,
 210:main.c        ****     .avg = 0,
 211:main.c        ****     .offset = 50,
 212:main.c        ****     .lastBeat = 0,
 213:main.c        ****     .begin = 0,
 214:main.c        ****     .end = 0,
 215:main.c        ****     .onBeat = false,
 216:main.c        **** };
 217:main.c        **** 
 218:main.c        **** //>0 ermittelter Herzschlag =0 kein neuer Herzschlag <0 Fehler
 219:main.c        **** int herzschlag_process(int32_t ad) {
 795              		.loc 1 219 36
 796              		.cfi_startproc
 797              		@ Function supports interworking.
 798              		@ args = 0, pretend = 0, frame = 24
 799              		@ frame_needed = 1, uses_anonymous_args = 0
 800 0000 00482DE9 		push	{fp, lr}
 801              		.cfi_def_cfa_offset 8
 802              		.cfi_offset 11, -8
 803              		.cfi_offset 14, -4
 804 0004 04B08DE2 		add	fp, sp, #4
 805              		.cfi_def_cfa 11, 4
 806 0008 18D04DE2 		sub	sp, sp, #24
 807 000c 18000BE5 		str	r0, [fp, #-24]
 220:main.c        ****   trace_scope(0, ad);
 808              		.loc 1 220 3
 809 0010 18301BE5 		ldr	r3, [fp, #-24]
 810 0014 0338A0E1 		lsl	r3, r3, #16
 811 0018 4338A0E1 		asr	r3, r3, #16
 812 001c 0310A0E1 		mov	r1, r3
 813 0020 0000A0E3 		mov	r0, #0
 814 0024 F8329FE5 		ldr	r3, .L55
 815 0028 0FE0A0E1 		mov	lr, pc
 816 002c 13FF2FE1 		bx	r3
 817              	.LVL5:
 221:main.c        **** 
 222:main.c        ****   // Ringbuffer
 223:main.c        ****   h.sum += (ad - h.ad_buf[h.ad_idx]);
 818              		.loc 1 223 4
 819 0030 F0329FE5 		ldr	r3, .L55+4
 820 0034 042193E5 		ldr	r2, [r3, #260]
 821              		.loc 1 223 28
 822 0038 E8329FE5 		ldr	r3, .L55+4
 823 003c 003193E5 		ldr	r3, [r3, #256]
 824              		.loc 1 223 26
 825 0040 E0129FE5 		ldr	r1, .L55+4
 826 0044 8330A0E1 		lsl	r3, r3, #1
 827 0048 033081E0 		add	r3, r1, r3
 828 004c B030D3E1 		ldrh	r3, [r3]
 829 0050 0310A0E1 		mov	r1, r3
 830              		.loc 1 223 16
 831 0054 18301BE5 		ldr	r3, [fp, #-24]
 832 0058 013043E0 		sub	r3, r3, r1
 833              		.loc 1 223 9
 834 005c 033082E0 		add	r3, r2, r3
 835 0060 C0229FE5 		ldr	r2, .L55+4
 836 0064 043182E5 		str	r3, [r2, #260]
 224:main.c        ****   h.ad_buf[h.ad_idx] = (uint16_t)ad;
 837              		.loc 1 224 13
 838 0068 B8329FE5 		ldr	r3, .L55+4
 839 006c 003193E5 		ldr	r3, [r3, #256]
 840              		.loc 1 224 24
 841 0070 18201BE5 		ldr	r2, [fp, #-24]
 842 0074 0228A0E1 		lsl	r2, r2, #16
 843 0078 2228A0E1 		lsr	r2, r2, #16
 844              		.loc 1 224 22
 845 007c A4129FE5 		ldr	r1, .L55+4
 846 0080 8330A0E1 		lsl	r3, r3, #1
 847 0084 033081E0 		add	r3, r1, r3
 848 0088 B020C3E1 		strh	r2, [r3]	@ movhi
 225:main.c        ****   h.ad_idx = (h.ad_idx + 1) & 127;
 849              		.loc 1 225 16
 850 008c 94329FE5 		ldr	r3, .L55+4
 851 0090 003193E5 		ldr	r3, [r3, #256]
 852              		.loc 1 225 24
 853 0094 013083E2 		add	r3, r3, #1
 854              		.loc 1 225 29
 855 0098 7F3003E2 		and	r3, r3, #127
 856              		.loc 1 225 12
 857 009c 84229FE5 		ldr	r2, .L55+4
 858 00a0 003182E5 		str	r3, [r2, #256]
 226:main.c        **** 
 227:main.c        ****   // floating average
 228:main.c        ****   h.avg = (h.sum >> 7) + (h.avg >> 3);
 859              		.loc 1 228 13
 860 00a4 7C329FE5 		ldr	r3, .L55+4
 861 00a8 043193E5 		ldr	r3, [r3, #260]
 862              		.loc 1 228 18
 863 00ac C323A0E1 		asr	r2, r3, #7
 864              		.loc 1 228 28
 865 00b0 70329FE5 		ldr	r3, .L55+4
 866 00b4 083193E5 		ldr	r3, [r3, #264]
 867              		.loc 1 228 33
 868 00b8 C331A0E1 		asr	r3, r3, #3
 869              		.loc 1 228 24
 870 00bc 033082E0 		add	r3, r2, r3
 871              		.loc 1 228 9
 872 00c0 60229FE5 		ldr	r2, .L55+4
 873 00c4 083182E5 		str	r3, [r2, #264]
 229:main.c        ****   trace_scope(1, h.avg);
 874              		.loc 1 229 19
 875 00c8 58329FE5 		ldr	r3, .L55+4
 876 00cc 083193E5 		ldr	r3, [r3, #264]
 877              		.loc 1 229 3
 878 00d0 0338A0E1 		lsl	r3, r3, #16
 879 00d4 4338A0E1 		asr	r3, r3, #16
 880 00d8 0310A0E1 		mov	r1, r3
 881 00dc 0100A0E3 		mov	r0, #1
 882 00e0 3C329FE5 		ldr	r3, .L55
 883 00e4 0FE0A0E1 		mov	lr, pc
 884 00e8 13FF2FE1 		bx	r3
 885              	.LVL6:
 230:main.c        **** 
 231:main.c        ****   // Average not set
 232:main.c        ****   if (h.avg < 350) {
 886              		.loc 1 232 8
 887 00ec 34329FE5 		ldr	r3, .L55+4
 888 00f0 083193E5 		ldr	r3, [r3, #264]
 889              		.loc 1 232 6
 890 00f4 30229FE5 		ldr	r2, .L55+8
 891 00f8 020053E1 		cmp	r3, r2
 892 00fc 010000CA 		bgt	.L46
 233:main.c        ****     return 0;
 893              		.loc 1 233 12
 894 0100 0030A0E3 		mov	r3, #0
 895 0104 820000EA 		b	.L47
 896              	.L46:
 234:main.c        ****   }
 235:main.c        ****   // AGC error
 236:main.c        ****   if (ad > (h.avg << 1)) {
 897              		.loc 1 236 14
 898 0108 18329FE5 		ldr	r3, .L55+4
 899 010c 083193E5 		ldr	r3, [r3, #264]
 900              		.loc 1 236 19
 901 0110 8330A0E1 		lsl	r3, r3, #1
 902              		.loc 1 236 6
 903 0114 18201BE5 		ldr	r2, [fp, #-24]
 904 0118 030052E1 		cmp	r2, r3
 905 011c 010000DA 		ble	.L48
 237:main.c        ****     return 0;
 906              		.loc 1 237 12
 907 0120 0030A0E3 		mov	r3, #0
 908 0124 7A0000EA 		b	.L47
 909              	.L48:
 238:main.c        ****   }
 239:main.c        **** 
 240:main.c        ****   // start of beat
 241:main.c        ****   if (ad > h.avg && !h.onBeat) {
 910              		.loc 1 241 13
 911 0128 F8319FE5 		ldr	r3, .L55+4
 912 012c 083193E5 		ldr	r3, [r3, #264]
 913              		.loc 1 241 6
 914 0130 18201BE5 		ldr	r2, [fp, #-24]
 915 0134 030052E1 		cmp	r2, r3
 916 0138 100000DA 		ble	.L49
 917              		.loc 1 241 23 discriminator 1
 918 013c E4319FE5 		ldr	r3, .L55+4
 919 0140 1C31D3E5 		ldrb	r3, [r3, #284]	@ zero_extendqisi2
 920              		.loc 1 241 21 discriminator 1
 921 0144 013023E2 		eor	r3, r3, #1
 922 0148 FF3003E2 		and	r3, r3, #255
 923              		.loc 1 241 18 discriminator 1
 924 014c 000053E3 		cmp	r3, #0
 925 0150 0A00000A 		beq	.L49
 242:main.c        ****     h.begin = systick_get_ms();
 926              		.loc 1 242 15
 927 0154 D4319FE5 		ldr	r3, .L55+12
 928 0158 0FE0A0E1 		mov	lr, pc
 929 015c 13FF2FE1 		bx	r3
 930              	.LVL7:
 931 0160 0030A0E1 		mov	r3, r0
 932              		.loc 1 242 13 discriminator 1
 933 0164 BC219FE5 		ldr	r2, .L55+4
 934 0168 143182E5 		str	r3, [r2, #276]
 243:main.c        ****     h.onBeat = true;
 935              		.loc 1 243 14
 936 016c B4319FE5 		ldr	r3, .L55+4
 937 0170 0120A0E3 		mov	r2, #1
 938 0174 1C21C3E5 		strb	r2, [r3, #284]
 244:main.c        ****     return 0;
 939              		.loc 1 244 12
 940 0178 0030A0E3 		mov	r3, #0
 941 017c 640000EA 		b	.L47
 942              	.L49:
 245:main.c        ****   }
 246:main.c        **** 
 247:main.c        ****   // end of beat
 248:main.c        ****   if (ad < h.avg && h.onBeat) {
 943              		.loc 1 248 13
 944 0180 A0319FE5 		ldr	r3, .L55+4
 945 0184 083193E5 		ldr	r3, [r3, #264]
 946              		.loc 1 248 6
 947 0188 18201BE5 		ldr	r2, [fp, #-24]
 948 018c 030052E1 		cmp	r2, r3
 949 0190 5E0000AA 		bge	.L50
 950              		.loc 1 248 22 discriminator 1
 951 0194 8C319FE5 		ldr	r3, .L55+4
 952 0198 1C31D3E5 		ldrb	r3, [r3, #284]	@ zero_extendqisi2
 953              		.loc 1 248 18 discriminator 1
 954 019c 000053E3 		cmp	r3, #0
 955 01a0 5A00000A 		beq	.L50
 956              	.LBB7:
 249:main.c        ****     h.end = systick_get_ms();
 957              		.loc 1 249 13
 958 01a4 84319FE5 		ldr	r3, .L55+12
 959 01a8 0FE0A0E1 		mov	lr, pc
 960 01ac 13FF2FE1 		bx	r3
 961              	.LVL8:
 962 01b0 0030A0E1 		mov	r3, r0
 963              		.loc 1 249 11 discriminator 1
 964 01b4 6C219FE5 		ldr	r2, .L55+4
 965 01b8 183182E5 		str	r3, [r2, #280]
 250:main.c        ****     h.onBeat = false;
 966              		.loc 1 250 14
 967 01bc 64319FE5 		ldr	r3, .L55+4
 968 01c0 0020A0E3 		mov	r2, #0
 969 01c4 1C21C3E5 		strb	r2, [r3, #284]
 251:main.c        **** 
 252:main.c        ****     // timestamp of beat
 253:main.c        ****     uint32_t timestamp = h.begin + ((h.end - h.begin) >> 1);
 970              		.loc 1 253 27
 971 01c8 58319FE5 		ldr	r3, .L55+4
 972 01cc 142193E5 		ldr	r2, [r3, #276]
 973              		.loc 1 253 39
 974 01d0 50319FE5 		ldr	r3, .L55+4
 975 01d4 181193E5 		ldr	r1, [r3, #280]
 976              		.loc 1 253 47
 977 01d8 48319FE5 		ldr	r3, .L55+4
 978 01dc 143193E5 		ldr	r3, [r3, #276]
 979              		.loc 1 253 44
 980 01e0 033041E0 		sub	r3, r1, r3
 981              		.loc 1 253 55
 982 01e4 A330A0E1 		lsr	r3, r3, #1
 983              		.loc 1 253 14
 984 01e8 033082E0 		add	r3, r2, r3
 985 01ec 08300BE5 		str	r3, [fp, #-8]
 254:main.c        **** 
 255:main.c        ****     // Wenn lastBeat == 0 --> erster gefundener Schlag: initialisiere und gib 0
 256:main.c        ****     // zurück
 257:main.c        ****     if (h.lastBeat == 0) {
 986              		.loc 1 257 10
 987 01f0 30319FE5 		ldr	r3, .L55+4
 988 01f4 103193E5 		ldr	r3, [r3, #272]
 989              		.loc 1 257 8
 990 01f8 000053E3 		cmp	r3, #0
 991 01fc 0400001A 		bne	.L51
 258:main.c        ****       h.lastBeat = timestamp;
 992              		.loc 1 258 18
 993 0200 20219FE5 		ldr	r2, .L55+4
 994 0204 08301BE5 		ldr	r3, [fp, #-8]
 995 0208 103182E5 		str	r3, [r2, #272]
 259:main.c        ****       return 0;
 996              		.loc 1 259 14
 997 020c 0030A0E3 		mov	r3, #0
 998 0210 3F0000EA 		b	.L47
 999              	.L51:
 260:main.c        ****     }
 261:main.c        **** 
 262:main.c        ****     // time between beats
 263:main.c        ****     uint32_t t = timestamp - h.lastBeat;
 1000              		.loc 1 263 31
 1001 0214 0C319FE5 		ldr	r3, .L55+4
 1002 0218 103193E5 		ldr	r3, [r3, #272]
 1003              		.loc 1 263 14
 1004 021c 08201BE5 		ldr	r2, [fp, #-8]
 1005 0220 033042E0 		sub	r3, r2, r3
 1006 0224 0C300BE5 		str	r3, [fp, #-12]
 264:main.c        ****     if (t == 0) {
 1007              		.loc 1 264 8
 1008 0228 0C301BE5 		ldr	r3, [fp, #-12]
 1009 022c 000053E3 		cmp	r3, #0
 1010 0230 0400001A 		bne	.L52
 265:main.c        ****       h.lastBeat = timestamp;
 1011              		.loc 1 265 18
 1012 0234 EC209FE5 		ldr	r2, .L55+4
 1013 0238 08301BE5 		ldr	r3, [fp, #-8]
 1014 023c 103182E5 		str	r3, [r2, #272]
 266:main.c        ****       return 0;
 1015              		.loc 1 266 14
 1016 0240 0030A0E3 		mov	r3, #0
 1017 0244 320000EA 		b	.L47
 1018              	.L52:
 267:main.c        ****     }
 268:main.c        **** 
 269:main.c        ****     h.lastBeat = timestamp;
 1019              		.loc 1 269 16
 1020 0248 D8209FE5 		ldr	r2, .L55+4
 1021 024c 08301BE5 		ldr	r3, [fp, #-8]
 1022 0250 103182E5 		str	r3, [r2, #272]
 270:main.c        **** 
 271:main.c        ****     /* BPM: 1000 ms / t (ms per beat) * 60 */
 272:main.c        ****     //((120000/t) +1) >>1
 273:main.c        ****     float bpm_f = (1000.0f / (float)t) * 60.0f;
 1023              		.loc 1 273 30
 1024 0254 D8309FE5 		ldr	r3, .L55+16
 1025 0258 0C001BE5 		ldr	r0, [fp, #-12]
 1026 025c 0FE0A0E1 		mov	lr, pc
 1027 0260 13FF2FE1 		bx	r3
 1028              	.LVL9:
 1029 0264 0030A0E1 		mov	r3, r0
 1030              		.loc 1 273 28
 1031 0268 C8209FE5 		ldr	r2, .L55+20
 1032 026c 0310A0E1 		mov	r1, r3
 1033 0270 C4009FE5 		ldr	r0, .L55+24
 1034 0274 0FE0A0E1 		mov	lr, pc
 1035 0278 12FF2FE1 		bx	r2
 1036              	.LVL10:
 1037 027c 0030A0E1 		mov	r3, r0
 1038 0280 0320A0E1 		mov	r2, r3
 1039              		.loc 1 273 11
 1040 0284 B4309FE5 		ldr	r3, .L55+28
 1041 0288 B4109FE5 		ldr	r1, .L55+32
 1042 028c 0200A0E1 		mov	r0, r2
 1043 0290 0FE0A0E1 		mov	lr, pc
 1044 0294 13FF2FE1 		bx	r3
 1045              	.LVL11:
 1046 0298 0030A0E1 		mov	r3, r0
 1047 029c 10300BE5 		str	r3, [fp, #-16]	@ float
 274:main.c        ****     int bpm = (int)(bpm_f + 0.5f);
 1048              		.loc 1 274 27
 1049 02a0 A0309FE5 		ldr	r3, .L55+36
 1050 02a4 3F14A0E3 		mov	r1, #1056964608
 1051 02a8 10001BE5 		ldr	r0, [fp, #-16]	@ float
 1052 02ac 0FE0A0E1 		mov	lr, pc
 1053 02b0 13FF2FE1 		bx	r3
 1054              	.LVL12:
 1055 02b4 0030A0E1 		mov	r3, r0
 1056 02b8 0320A0E1 		mov	r2, r3
 1057              		.loc 1 274 9
 1058 02bc 88309FE5 		ldr	r3, .L55+40
 1059 02c0 0200A0E1 		mov	r0, r2
 1060 02c4 0FE0A0E1 		mov	lr, pc
 1061 02c8 13FF2FE1 		bx	r3
 1062              	.LVL13:
 1063 02cc 0030A0E1 		mov	r3, r0
 1064 02d0 14300BE5 		str	r3, [fp, #-20]
 275:main.c        **** 
 276:main.c        ****     if (bpm < 50 || bpm > 200) {
 1065              		.loc 1 276 8
 1066 02d4 14301BE5 		ldr	r3, [fp, #-20]
 1067 02d8 310053E3 		cmp	r3, #49
 1068 02dc 020000DA 		ble	.L53
 1069              		.loc 1 276 18 discriminator 1
 1070 02e0 14301BE5 		ldr	r3, [fp, #-20]
 1071 02e4 C80053E3 		cmp	r3, #200
 1072 02e8 010000DA 		ble	.L54
 1073              	.L53:
 277:main.c        ****       return 0;
 1074              		.loc 1 277 14
 1075 02ec 0030A0E3 		mov	r3, #0
 1076 02f0 070000EA 		b	.L47
 1077              	.L54:
 278:main.c        ****     }
 279:main.c        **** 
 280:main.c        ****     printf("BPM: %d\n", bpm);
 1078              		.loc 1 280 5
 1079 02f4 14101BE5 		ldr	r1, [fp, #-20]
 1080 02f8 50009FE5 		ldr	r0, .L55+44
 1081 02fc 50309FE5 		ldr	r3, .L55+48
 1082 0300 0FE0A0E1 		mov	lr, pc
 1083 0304 13FF2FE1 		bx	r3
 1084              	.LVL14:
 281:main.c        **** 
 282:main.c        ****     return bpm;
 1085              		.loc 1 282 12
 1086 0308 14301BE5 		ldr	r3, [fp, #-20]
 1087 030c 000000EA 		b	.L47
 1088              	.L50:
 1089              	.LBE7:
 283:main.c        ****   }
 284:main.c        **** 
 285:main.c        ****   return 0;
 1090              		.loc 1 285 10
 1091 0310 0030A0E3 		mov	r3, #0
 1092              	.L47:
 286:main.c        **** }
 1093              		.loc 1 286 1
 1094 0314 0300A0E1 		mov	r0, r3
 1095 0318 04D04BE2 		sub	sp, fp, #4
 1096              		.cfi_def_cfa 13, 8
 1097              		@ sp needed
 1098 031c 0048BDE8 		pop	{fp, lr}
 1099              		.cfi_restore 14
 1100              		.cfi_restore 11
 1101              		.cfi_def_cfa_offset 0
 1102 0320 1EFF2FE1 		bx	lr
 1103              	.L56:
 1104              		.align	2
 1105              	.L55:
 1106 0324 00000000 		.word	trace_scope
 1107 0328 00000000 		.word	h
 1108 032c 5D010000 		.word	349
 1109 0330 00000000 		.word	systick_get_ms
 1110 0334 00000000 		.word	__aeabi_ui2f
 1111 0338 00000000 		.word	__aeabi_fdiv
 1112 033c 00007A44 		.word	1148846080
 1113 0340 00000000 		.word	__aeabi_fmul
 1114 0344 00007042 		.word	1114636288
 1115 0348 00000000 		.word	__aeabi_fadd
 1116 034c 00000000 		.word	__aeabi_f2iz
 1117 0350 00000000 		.word	.LC0
 1118 0354 00000000 		.word	printf
 1119              		.cfi_endproc
 1120              	.LFE17:
 1122              		.section	.text.task_8ms,"ax",%progbits
 1123              		.align	2
 1124              		.global	task_8ms
 1125              		.syntax unified
 1126              		.arm
 1128              	task_8ms:
 1129              	.LFB18:
 287:main.c        **** 
 288:main.c        **** #ifdef NXT
 289:main.c        **** /*****************************************************************************/
 290:main.c        **** /*   Hilfsroutinen                                                           */
 291:main.c        **** /*****************************************************************************/
 292:main.c        **** void task_8ms(void) {
 1130              		.loc 1 292 21
 1131              		.cfi_startproc
 1132              		@ Function supports interworking.
 1133              		@ args = 0, pretend = 0, frame = 0
 1134              		@ frame_needed = 1, uses_anonymous_args = 0
 1135 0000 00482DE9 		push	{fp, lr}
 1136              		.cfi_def_cfa_offset 8
 1137              		.cfi_offset 11, -8
 1138              		.cfi_offset 14, -4
 1139 0004 04B08DE2 		add	fp, sp, #4
 1140              		.cfi_def_cfa 11, 4
 293:main.c        ****   // Keine blockierende Aufrufe
 294:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 295:main.c        **** #ifdef MODE_SIM
 296:main.c        ****   (void)herzschlag_process(simuli[simuli_idx++]);
 297:main.c        ****   simuli_idx = simuli_idx % (sizeof(simuli) / sizeof(simuli[0]));
 298:main.c        **** #else
 299:main.c        ****   (void)herzschlag_process(nxt_avr_get_sensor_adc_raw(HERZSCHLAG_PORT));
 1141              		.loc 1 299 28
 1142 0008 0100A0E3 		mov	r0, #1
 1143 000c 28309FE5 		ldr	r3, .L58
 1144 0010 0FE0A0E1 		mov	lr, pc
 1145 0014 13FF2FE1 		bx	r3
 1146              	.LVL15:
 1147 0018 0030A0E1 		mov	r3, r0
 1148              		.loc 1 299 9 discriminator 1
 1149 001c 0300A0E1 		mov	r0, r3
 1150 0020 18309FE5 		ldr	r3, .L58+4
 1151 0024 0FE0A0E1 		mov	lr, pc
 1152 0028 13FF2FE1 		bx	r3
 1153              	.LVL16:
 300:main.c        **** #endif
 301:main.c        **** }
 1154              		.loc 1 301 1
 1155 002c 0000A0E1 		nop
 1156 0030 04D04BE2 		sub	sp, fp, #4
 1157              		.cfi_def_cfa 13, 8
 1158              		@ sp needed
 1159 0034 0048BDE8 		pop	{fp, lr}
 1160              		.cfi_restore 14
 1161              		.cfi_restore 11
 1162              		.cfi_def_cfa_offset 0
 1163 0038 1EFF2FE1 		bx	lr
 1164              	.L59:
 1165              		.align	2
 1166              	.L58:
 1167 003c 00000000 		.word	nxt_avr_get_sensor_adc_raw
 1168 0040 00000000 		.word	herzschlag_process
 1169              		.cfi_endproc
 1170              	.LFE18:
 1172              		.section	.text.task_16ms,"ax",%progbits
 1173              		.align	2
 1174              		.global	task_16ms
 1175              		.syntax unified
 1176              		.arm
 1178              	task_16ms:
 1179              	.LFB19:
 302:main.c        **** 
 303:main.c        **** void task_16ms(void) {
 1180              		.loc 1 303 22
 1181              		.cfi_startproc
 1182              		@ Function supports interworking.
 1183              		@ args = 0, pretend = 0, frame = 0
 1184              		@ frame_needed = 1, uses_anonymous_args = 0
 1185              		@ link register save eliminated.
 1186 0000 04B02DE5 		str	fp, [sp, #-4]!
 1187              		.cfi_def_cfa_offset 4
 1188              		.cfi_offset 11, -4
 1189 0004 00B08DE2 		add	fp, sp, #0
 1190              		.cfi_def_cfa_register 11
 304:main.c        ****   // Keine blockierende Aufrufe
 305:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 306:main.c        **** }
 1191              		.loc 1 306 1
 1192 0008 0000A0E1 		nop
 1193 000c 00D08BE2 		add	sp, fp, #0
 1194              		.cfi_def_cfa_register 13
 1195              		@ sp needed
 1196 0010 04B09DE4 		ldr	fp, [sp], #4
 1197              		.cfi_restore 11
 1198              		.cfi_def_cfa_offset 0
 1199 0014 1EFF2FE1 		bx	lr
 1200              		.cfi_endproc
 1201              	.LFE19:
 1203              		.section	.text.task_32ms,"ax",%progbits
 1204              		.align	2
 1205              		.global	task_32ms
 1206              		.syntax unified
 1207              		.arm
 1209              	task_32ms:
 1210              	.LFB20:
 307:main.c        **** void task_32ms(void) {
 1211              		.loc 1 307 22
 1212              		.cfi_startproc
 1213              		@ Function supports interworking.
 1214              		@ args = 0, pretend = 0, frame = 0
 1215              		@ frame_needed = 1, uses_anonymous_args = 0
 1216              		@ link register save eliminated.
 1217 0000 04B02DE5 		str	fp, [sp, #-4]!
 1218              		.cfi_def_cfa_offset 4
 1219              		.cfi_offset 11, -4
 1220 0004 00B08DE2 		add	fp, sp, #0
 1221              		.cfi_def_cfa_register 11
 308:main.c        ****   // Keine blockierende Aufrufe
 309:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 310:main.c        **** }
 1222              		.loc 1 310 1
 1223 0008 0000A0E1 		nop
 1224 000c 00D08BE2 		add	sp, fp, #0
 1225              		.cfi_def_cfa_register 13
 1226              		@ sp needed
 1227 0010 04B09DE4 		ldr	fp, [sp], #4
 1228              		.cfi_restore 11
 1229              		.cfi_def_cfa_offset 0
 1230 0014 1EFF2FE1 		bx	lr
 1231              		.cfi_endproc
 1232              	.LFE20:
 1234              		.section	.text.task_64ms,"ax",%progbits
 1235              		.align	2
 1236              		.global	task_64ms
 1237              		.syntax unified
 1238              		.arm
 1240              	task_64ms:
 1241              	.LFB21:
 311:main.c        **** void task_64ms(void) {
 1242              		.loc 1 311 22
 1243              		.cfi_startproc
 1244              		@ Function supports interworking.
 1245              		@ args = 0, pretend = 0, frame = 0
 1246              		@ frame_needed = 1, uses_anonymous_args = 0
 1247              		@ link register save eliminated.
 1248 0000 04B02DE5 		str	fp, [sp, #-4]!
 1249              		.cfi_def_cfa_offset 4
 1250              		.cfi_offset 11, -4
 1251 0004 00B08DE2 		add	fp, sp, #0
 1252              		.cfi_def_cfa_register 11
 312:main.c        ****   // Keine blockierende Aufrufe
 313:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 314:main.c        **** }
 1253              		.loc 1 314 1
 1254 0008 0000A0E1 		nop
 1255 000c 00D08BE2 		add	sp, fp, #0
 1256              		.cfi_def_cfa_register 13
 1257              		@ sp needed
 1258 0010 04B09DE4 		ldr	fp, [sp], #4
 1259              		.cfi_restore 11
 1260              		.cfi_def_cfa_offset 0
 1261 0014 1EFF2FE1 		bx	lr
 1262              		.cfi_endproc
 1263              	.LFE21:
 1265              		.section	.text.task_128ms,"ax",%progbits
 1266              		.align	2
 1267              		.global	task_128ms
 1268              		.syntax unified
 1269              		.arm
 1271              	task_128ms:
 1272              	.LFB22:
 315:main.c        **** 
 316:main.c        **** void task_128ms(void) {
 1273              		.loc 1 316 23
 1274              		.cfi_startproc
 1275              		@ Function supports interworking.
 1276              		@ args = 0, pretend = 0, frame = 0
 1277              		@ frame_needed = 1, uses_anonymous_args = 0
 1278              		@ link register save eliminated.
 1279 0000 04B02DE5 		str	fp, [sp, #-4]!
 1280              		.cfi_def_cfa_offset 4
 1281              		.cfi_offset 11, -4
 1282 0004 00B08DE2 		add	fp, sp, #0
 1283              		.cfi_def_cfa_register 11
 317:main.c        ****   // Keine blockierende Aufrufe
 318:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 319:main.c        **** }
 1284              		.loc 1 319 1
 1285 0008 0000A0E1 		nop
 1286 000c 00D08BE2 		add	sp, fp, #0
 1287              		.cfi_def_cfa_register 13
 1288              		@ sp needed
 1289 0010 04B09DE4 		ldr	fp, [sp], #4
 1290              		.cfi_restore 11
 1291              		.cfi_def_cfa_offset 0
 1292 0014 1EFF2FE1 		bx	lr
 1293              		.cfi_endproc
 1294              	.LFE22:
 1296              		.section	.rodata
 1297 0009 000000   		.align	2
 1298              	.LC1:
 1299 000c 53303A00 		.ascii	"S0:\000"
 1300              		.align	2
 1301              	.LC2:
 1302 0010 4261743A 		.ascii	"Bat:\000"
 1302      00
 1303 0015 000000   		.align	2
 1304              	.LC3:
 1305 0018 6D5600   		.ascii	"mV\000"
 1306 001b 00       		.align	2
 1307              	.LC4:
 1308 001c 4275743A 		.ascii	"But: \000"
 1308      2000
 1309 0022 0000     		.align	2
 1310              	.LC5:
 1311 0024 54696D65 		.ascii	"Time: \000"
 1311      3A2000
 1312 002b 00       		.align	2
 1313              	.LC6:
 1314 002c 7300     		.ascii	"s\000"
 1315              		.section	.text.task_256ms,"ax",%progbits
 1316              		.align	2
 1317              		.global	task_256ms
 1318              		.syntax unified
 1319              		.arm
 1321              	task_256ms:
 1322              	.LFB23:
 320:main.c        **** void task_256ms(void) {
 1323              		.loc 1 320 23
 1324              		.cfi_startproc
 1325              		@ Function supports interworking.
 1326              		@ args = 0, pretend = 0, frame = 0
 1327              		@ frame_needed = 1, uses_anonymous_args = 0
 1328 0000 00482DE9 		push	{fp, lr}
 1329              		.cfi_def_cfa_offset 8
 1330              		.cfi_offset 11, -8
 1331              		.cfi_offset 14, -4
 1332 0004 04B08DE2 		add	fp, sp, #4
 1333              		.cfi_def_cfa 11, 4
 321:main.c        ****   // Keine blockierende Aufrufe
 322:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 323:main.c        **** 
 324:main.c        ****   // Beispielanwendung für MotorPos,Sensor,Batterie und NXT-Tasten
 325:main.c        ****   // Im Simulationsmodus kann im 'Per'-Fenster Werte vorgegeben werden
 326:main.c        ****   // Beispiel zur Abfrage des anlogen Eingangs am SensorPort 1
 327:main.c        ****   display_string("S0:");
 1334              		.loc 1 327 3
 1335 0008 2C029FE5 		ldr	r0, .L73
 1336 000c 2C329FE5 		ldr	r3, .L73+4
 1337 0010 0FE0A0E1 		mov	lr, pc
 1338 0014 13FF2FE1 		bx	r3
 1339              	.LVL17:
 328:main.c        ****   display_hex((uint32_t)nxt_avr_get_sensor_adc_raw(SENSOR_1),
 1340              		.loc 1 328 25
 1341 0018 0000A0E3 		mov	r0, #0
 1342 001c 20329FE5 		ldr	r3, .L73+8
 1343 0020 0FE0A0E1 		mov	lr, pc
 1344 0024 13FF2FE1 		bx	r3
 1345              	.LVL18:
 1346 0028 0030A0E1 		mov	r3, r0
 1347              		.loc 1 328 3 discriminator 1
 1348 002c 0310A0E3 		mov	r1, #3
 1349 0030 0300A0E1 		mov	r0, r3
 1350 0034 0C329FE5 		ldr	r3, .L73+12
 1351 0038 0FE0A0E1 		mov	lr, pc
 1352 003c 13FF2FE1 		bx	r3
 1353              	.LVL19:
 329:main.c        ****               3); // PER: NXT_AVR_ADC_1
 330:main.c        ****   // Beispiel zur Abfrage der Batteriespannung
 331:main.c        ****   display_goto_xy(0, 3);
 1354              		.loc 1 331 3
 1355 0040 0310A0E3 		mov	r1, #3
 1356 0044 0000A0E3 		mov	r0, #0
 1357 0048 FC319FE5 		ldr	r3, .L73+16
 1358 004c 0FE0A0E1 		mov	lr, pc
 1359 0050 13FF2FE1 		bx	r3
 1360              	.LVL20:
 332:main.c        ****   display_string("Bat:");
 1361              		.loc 1 332 3
 1362 0054 F4019FE5 		ldr	r0, .L73+20
 1363 0058 E0319FE5 		ldr	r3, .L73+4
 1364 005c 0FE0A0E1 		mov	lr, pc
 1365 0060 13FF2FE1 		bx	r3
 1366              	.LVL21:
 333:main.c        ****   display_unsigned(nxt_avr_get_battery_mv(),
 1367              		.loc 1 333 20
 1368 0064 E8319FE5 		ldr	r3, .L73+24
 1369 0068 0FE0A0E1 		mov	lr, pc
 1370 006c 13FF2FE1 		bx	r3
 1371              	.LVL22:
 1372 0070 0030A0E1 		mov	r3, r0
 1373              		.loc 1 333 3 discriminator 1
 1374 0074 0510A0E3 		mov	r1, #5
 1375 0078 0300A0E1 		mov	r0, r3
 1376 007c D4319FE5 		ldr	r3, .L73+28
 1377 0080 0FE0A0E1 		mov	lr, pc
 1378 0084 13FF2FE1 		bx	r3
 1379              	.LVL23:
 334:main.c        ****                    5); // über AVR-Proz -> PER: NXT_AVR_BATTERY
 335:main.c        ****   //	display_unsigned(adc_get_usb_mv()         ,5);  //über SAM7-Proz
 336:main.c        ****   display_string("mV");
 1380              		.loc 1 336 3
 1381 0088 CC019FE5 		ldr	r0, .L73+32
 1382 008c AC319FE5 		ldr	r3, .L73+4
 1383 0090 0FE0A0E1 		mov	lr, pc
 1384 0094 13FF2FE1 		bx	r3
 1385              	.LVL24:
 337:main.c        ****   // Beispiel zur Abfrage der NXT-Tasten
 338:main.c        ****   display_goto_xy(0, 4);
 1386              		.loc 1 338 3
 1387 0098 0410A0E3 		mov	r1, #4
 1388 009c 0000A0E3 		mov	r0, #0
 1389 00a0 A4319FE5 		ldr	r3, .L73+16
 1390 00a4 0FE0A0E1 		mov	lr, pc
 1391 00a8 13FF2FE1 		bx	r3
 1392              	.LVL25:
 339:main.c        ****   display_string("But: ");
 1393              		.loc 1 339 3
 1394 00ac AC019FE5 		ldr	r0, .L73+36
 1395 00b0 88319FE5 		ldr	r3, .L73+4
 1396 00b4 0FE0A0E1 		mov	lr, pc
 1397 00b8 13FF2FE1 		bx	r3
 1398              	.LVL26:
 340:main.c        ****   display_char(nxt_avr_get_buttons().orange ? 'O' : '-');
 1399              		.loc 1 340 16
 1400 00bc A0319FE5 		ldr	r3, .L73+40
 1401 00c0 0FE0A0E1 		mov	lr, pc
 1402 00c4 13FF2FE1 		bx	r3
 1403              	.LVL27:
 1404 00c8 0030A0E1 		mov	r3, r0
 1405              		.loc 1 340 45 discriminator 1
 1406 00cc FF3003E2 		and	r3, r3, #255
 1407 00d0 013003E2 		and	r3, r3, #1
 1408 00d4 FF3003E2 		and	r3, r3, #255
 1409              		.loc 1 340 3 discriminator 1
 1410 00d8 000053E3 		cmp	r3, #0
 1411 00dc 0100000A 		beq	.L65
 1412 00e0 4F30A0E3 		mov	r3, #79
 1413 00e4 000000EA 		b	.L66
 1414              	.L65:
 1415              		.loc 1 340 3 is_stmt 0 discriminator 2
 1416 00e8 2D30A0E3 		mov	r3, #45
 1417              	.L66:
 1418              		.loc 1 340 3 discriminator 4
 1419 00ec 0300A0E1 		mov	r0, r3
 1420 00f0 70319FE5 		ldr	r3, .L73+44
 1421 00f4 0FE0A0E1 		mov	lr, pc
 1422 00f8 13FF2FE1 		bx	r3
 1423              	.LVL28:
 341:main.c        ****   display_char(nxt_avr_get_buttons().left ? 'L'
 1424              		.loc 1 341 16 is_stmt 1
 1425 00fc 60319FE5 		ldr	r3, .L73+40
 1426 0100 0FE0A0E1 		mov	lr, pc
 1427 0104 13FF2FE1 		bx	r3
 1428              	.LVL29:
 1429 0108 0030A0E1 		mov	r3, r0
 1430              		.loc 1 341 43 discriminator 1
 1431 010c FF3003E2 		and	r3, r3, #255
 1432 0110 023003E2 		and	r3, r3, #2
 1433 0114 FF3003E2 		and	r3, r3, #255
 1434              		.loc 1 341 3 discriminator 1
 1435 0118 000053E3 		cmp	r3, #0
 1436 011c 0100000A 		beq	.L67
 1437 0120 4C30A0E3 		mov	r3, #76
 1438 0124 000000EA 		b	.L68
 1439              	.L67:
 1440              		.loc 1 341 3 is_stmt 0 discriminator 2
 1441 0128 2D30A0E3 		mov	r3, #45
 1442              	.L68:
 1443              		.loc 1 341 3 discriminator 4
 1444 012c 0300A0E1 		mov	r0, r3
 1445 0130 30319FE5 		ldr	r3, .L73+44
 1446 0134 0FE0A0E1 		mov	lr, pc
 1447 0138 13FF2FE1 		bx	r3
 1448              	.LVL30:
 342:main.c        ****                                           : '-'); // Left/Right/Grey generien
 343:main.c        ****   display_char(nxt_avr_get_buttons().right ? 'R'
 1449              		.loc 1 343 16 is_stmt 1
 1450 013c 20319FE5 		ldr	r3, .L73+40
 1451 0140 0FE0A0E1 		mov	lr, pc
 1452 0144 13FF2FE1 		bx	r3
 1453              	.LVL31:
 1454 0148 0030A0E1 		mov	r3, r0
 1455              		.loc 1 343 44 discriminator 1
 1456 014c FF3003E2 		and	r3, r3, #255
 1457 0150 043003E2 		and	r3, r3, #4
 1458 0154 FF3003E2 		and	r3, r3, #255
 1459              		.loc 1 343 3 discriminator 1
 1460 0158 000053E3 		cmp	r3, #0
 1461 015c 0100000A 		beq	.L69
 1462 0160 5230A0E3 		mov	r3, #82
 1463 0164 000000EA 		b	.L70
 1464              	.L69:
 1465              		.loc 1 343 3 is_stmt 0 discriminator 2
 1466 0168 2D30A0E3 		mov	r3, #45
 1467              	.L70:
 1468              		.loc 1 343 3 discriminator 4
 1469 016c 0300A0E1 		mov	r0, r3
 1470 0170 F0309FE5 		ldr	r3, .L73+44
 1471 0174 0FE0A0E1 		mov	lr, pc
 1472 0178 13FF2FE1 		bx	r3
 1473              	.LVL32:
 344:main.c        ****                                            : '-'); // je eine eigenen Spannung
 345:main.c        ****   display_char(nxt_avr_get_buttons().grey
 1474              		.loc 1 345 16 is_stmt 1
 1475 017c E0309FE5 		ldr	r3, .L73+40
 1476 0180 0FE0A0E1 		mov	lr, pc
 1477 0184 13FF2FE1 		bx	r3
 1478              	.LVL33:
 1479 0188 0030A0E1 		mov	r3, r0
 346:main.c        ****                    ? 'G'
 1480              		.loc 1 346 20
 1481 018c FF3003E2 		and	r3, r3, #255
 1482 0190 083003E2 		and	r3, r3, #8
 1483 0194 FF3003E2 		and	r3, r3, #255
 345:main.c        ****                    ? 'G'
 1484              		.loc 1 345 3
 1485 0198 000053E3 		cmp	r3, #0
 1486 019c 0100000A 		beq	.L71
 345:main.c        ****                    ? 'G'
 1487              		.loc 1 345 3 is_stmt 0 discriminator 1
 1488 01a0 4730A0E3 		mov	r3, #71
 1489 01a4 000000EA 		b	.L72
 1490              	.L71:
 345:main.c        ****                    ? 'G'
 1491              		.loc 1 345 3 discriminator 2
 1492 01a8 2D30A0E3 		mov	r3, #45
 1493              	.L72:
 345:main.c        ****                    ? 'G'
 1494              		.loc 1 345 3 discriminator 4
 1495 01ac 0300A0E1 		mov	r0, r3
 1496 01b0 B0309FE5 		ldr	r3, .L73+44
 1497 01b4 0FE0A0E1 		mov	lr, pc
 1498 01b8 13FF2FE1 		bx	r3
 1499              	.LVL34:
 347:main.c        ****                    : '-'); // so dass diese 3 nicht gemeinsam
 348:main.c        ****                            // erkannt werden können
 349:main.c        ****   // Beispiel für Zeitdarstellung
 350:main.c        ****   display_goto_xy(0, 5);
 1500              		.loc 1 350 3 is_stmt 1
 1501 01bc 0510A0E3 		mov	r1, #5
 1502 01c0 0000A0E3 		mov	r0, #0
 1503 01c4 80309FE5 		ldr	r3, .L73+16
 1504 01c8 0FE0A0E1 		mov	lr, pc
 1505 01cc 13FF2FE1 		bx	r3
 1506              	.LVL35:
 351:main.c        ****   display_string("Time: ");
 1507              		.loc 1 351 3
 1508 01d0 94009FE5 		ldr	r0, .L73+48
 1509 01d4 64309FE5 		ldr	r3, .L73+4
 1510 01d8 0FE0A0E1 		mov	lr, pc
 1511 01dc 13FF2FE1 		bx	r3
 1512              	.LVL36:
 352:main.c        ****   display_unsigned(systick_get_ms() / 1000, 4);
 1513              		.loc 1 352 20
 1514 01e0 88309FE5 		ldr	r3, .L73+52
 1515 01e4 0FE0A0E1 		mov	lr, pc
 1516 01e8 13FF2FE1 		bx	r3
 1517              	.LVL37:
 1518 01ec 0030A0E1 		mov	r3, r0
 1519              		.loc 1 352 3 discriminator 1
 1520 01f0 7C209FE5 		ldr	r2, .L73+56
 1521 01f4 921383E0 		umull	r1, r3, r2, r3
 1522 01f8 2333A0E1 		lsr	r3, r3, #6
 1523 01fc 0410A0E3 		mov	r1, #4
 1524 0200 0300A0E1 		mov	r0, r3
 1525 0204 4C309FE5 		ldr	r3, .L73+28
 1526 0208 0FE0A0E1 		mov	lr, pc
 1527 020c 13FF2FE1 		bx	r3
 1528              	.LVL38:
 353:main.c        ****   display_string("s");
 1529              		.loc 1 353 3
 1530 0210 60009FE5 		ldr	r0, .L73+60
 1531 0214 24309FE5 		ldr	r3, .L73+4
 1532 0218 0FE0A0E1 		mov	lr, pc
 1533 021c 13FF2FE1 		bx	r3
 1534              	.LVL39:
 354:main.c        ****   display_update();
 1535              		.loc 1 354 3
 1536 0220 54309FE5 		ldr	r3, .L73+64
 1537 0224 0FE0A0E1 		mov	lr, pc
 1538 0228 13FF2FE1 		bx	r3
 1539              	.LVL40:
 355:main.c        **** }
 1540              		.loc 1 355 1
 1541 022c 0000A0E1 		nop
 1542 0230 04D04BE2 		sub	sp, fp, #4
 1543              		.cfi_def_cfa 13, 8
 1544              		@ sp needed
 1545 0234 0048BDE8 		pop	{fp, lr}
 1546              		.cfi_restore 14
 1547              		.cfi_restore 11
 1548              		.cfi_def_cfa_offset 0
 1549 0238 1EFF2FE1 		bx	lr
 1550              	.L74:
 1551              		.align	2
 1552              	.L73:
 1553 023c 0C000000 		.word	.LC1
 1554 0240 00000000 		.word	display_string
 1555 0244 00000000 		.word	nxt_avr_get_sensor_adc_raw
 1556 0248 00000000 		.word	display_hex
 1557 024c 00000000 		.word	display_goto_xy
 1558 0250 10000000 		.word	.LC2
 1559 0254 00000000 		.word	nxt_avr_get_battery_mv
 1560 0258 00000000 		.word	display_unsigned
 1561 025c 18000000 		.word	.LC3
 1562 0260 1C000000 		.word	.LC4
 1563 0264 00000000 		.word	nxt_avr_get_buttons
 1564 0268 00000000 		.word	display_char
 1565 026c 24000000 		.word	.LC5
 1566 0270 00000000 		.word	systick_get_ms
 1567 0274 D34D6210 		.word	274877907
 1568 0278 2C000000 		.word	.LC6
 1569 027c 00000000 		.word	display_update
 1570              		.cfi_endproc
 1571              	.LFE23:
 1573              		.section	.text.task_512ms,"ax",%progbits
 1574              		.align	2
 1575              		.global	task_512ms
 1576              		.syntax unified
 1577              		.arm
 1579              	task_512ms:
 1580              	.LFB24:
 356:main.c        **** void task_512ms(void) {
 1581              		.loc 1 356 23
 1582              		.cfi_startproc
 1583              		@ Function supports interworking.
 1584              		@ args = 0, pretend = 0, frame = 0
 1585              		@ frame_needed = 1, uses_anonymous_args = 0
 1586              		@ link register save eliminated.
 1587 0000 04B02DE5 		str	fp, [sp, #-4]!
 1588              		.cfi_def_cfa_offset 4
 1589              		.cfi_offset 11, -4
 1590 0004 00B08DE2 		add	fp, sp, #0
 1591              		.cfi_def_cfa_register 11
 357:main.c        ****   // Keine blockierende Aufrufe
 358:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 359:main.c        **** }
 1592              		.loc 1 359 1
 1593 0008 0000A0E1 		nop
 1594 000c 00D08BE2 		add	sp, fp, #0
 1595              		.cfi_def_cfa_register 13
 1596              		@ sp needed
 1597 0010 04B09DE4 		ldr	fp, [sp], #4
 1598              		.cfi_restore 11
 1599              		.cfi_def_cfa_offset 0
 1600 0014 1EFF2FE1 		bx	lr
 1601              		.cfi_endproc
 1602              	.LFE24:
 1604              		.section	.text.task_1024ms,"ax",%progbits
 1605              		.align	2
 1606              		.global	task_1024ms
 1607              		.syntax unified
 1608              		.arm
 1610              	task_1024ms:
 1611              	.LFB25:
 360:main.c        **** void task_1024ms(void) {
 1612              		.loc 1 360 24
 1613              		.cfi_startproc
 1614              		@ Function supports interworking.
 1615              		@ args = 0, pretend = 0, frame = 0
 1616              		@ frame_needed = 1, uses_anonymous_args = 0
 1617              		@ link register save eliminated.
 1618 0000 04B02DE5 		str	fp, [sp, #-4]!
 1619              		.cfi_def_cfa_offset 4
 1620              		.cfi_offset 11, -4
 1621 0004 00B08DE2 		add	fp, sp, #0
 1622              		.cfi_def_cfa_register 11
 361:main.c        ****   // Keine blockierende Aufrufe
 362:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 363:main.c        **** }
 1623              		.loc 1 363 1
 1624 0008 0000A0E1 		nop
 1625 000c 00D08BE2 		add	sp, fp, #0
 1626              		.cfi_def_cfa_register 13
 1627              		@ sp needed
 1628 0010 04B09DE4 		ldr	fp, [sp], #4
 1629              		.cfi_restore 11
 1630              		.cfi_def_cfa_offset 0
 1631 0014 1EFF2FE1 		bx	lr
 1632              		.cfi_endproc
 1633              	.LFE25:
 1635              		.section	.rodata
 1636 002e 0000     		.align	2
 1637              	.LC7:
 1638 0030 0A0D3D3D 		.ascii	"\012\015==>ENTER gedr\374ckt: '\000"
 1638      3E454E54 
 1638      45522067 
 1638      656472FC 
 1638      636B743A 
 1639 0047 00       		.align	2
 1640              	.LC8:
 1641 0048 270A0D00 		.ascii	"'\012\015\000"
 1642              		.section	.text.task_idle,"ax",%progbits
 1643              		.align	2
 1644              		.global	task_idle
 1645              		.syntax unified
 1646              		.arm
 1648              	task_idle:
 1649              	.LFB26:
 364:main.c        **** void task_idle(void) {
 1650              		.loc 1 364 22
 1651              		.cfi_startproc
 1652              		@ Function supports interworking.
 1653              		@ args = 0, pretend = 0, frame = 8
 1654              		@ frame_needed = 1, uses_anonymous_args = 0
 1655 0000 00482DE9 		push	{fp, lr}
 1656              		.cfi_def_cfa_offset 8
 1657              		.cfi_offset 11, -8
 1658              		.cfi_offset 14, -4
 1659 0004 04B08DE2 		add	fp, sp, #4
 1660              		.cfi_def_cfa 11, 4
 1661 0008 08D04DE2 		sub	sp, sp, #8
 365:main.c        ****   // Keine blockierende Aufrufe
 366:main.c        ****   // Max. Bearbeitungsdauer: IDLE_MS
 367:main.c        **** 
 368:main.c        ****   // Beispielanwendung für Terminal-Schnittstelle
 369:main.c        ****   unsigned char c;
 370:main.c        ****   static unsigned char string[100];
 371:main.c        ****   static uint8_t strpos = 0;
 372:main.c        **** 
 373:main.c        ****   if (term_read(&c, ASYNCSYNC_NONBLOCK) == 0) {
 1662              		.loc 1 373 7
 1663 000c 05304BE2 		sub	r3, fp, #5
 1664 0010 0010A0E3 		mov	r1, #0
 1665 0014 0300A0E1 		mov	r0, r3
 1666 0018 DC319FE5 		ldr	r3, .L80
 1667 001c 0FE0A0E1 		mov	lr, pc
 1668 0020 13FF2FE1 		bx	r3
 1669              	.LVL41:
 1670 0024 0030A0E1 		mov	r3, r0
 1671              		.loc 1 373 6 discriminator 1
 1672 0028 000053E3 		cmp	r3, #0
 1673 002c 6E00001A 		bne	.L79
 374:main.c        ****     main_data.term_status |=
 375:main.c        ****         term_char(c, ASYNCSYNC_NONBLOCK); // Das empfangene Zeichen als Echo an
 1674              		.loc 1 375 9
 1675 0030 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1676 0034 0010A0E3 		mov	r1, #0
 1677 0038 0300A0E1 		mov	r0, r3
 1678 003c BC319FE5 		ldr	r3, .L80+4
 1679 0040 0FE0A0E1 		mov	lr, pc
 1680 0044 13FF2FE1 		bx	r3
 1681              	.LVL42:
 1682 0048 0030A0E1 		mov	r3, r0
 374:main.c        ****     main_data.term_status |=
 1683              		.loc 1 374 14
 1684 004c B0219FE5 		ldr	r2, .L80+8
 1685 0050 D020D2E1 		ldrsb	r2, [r2]
 374:main.c        ****     main_data.term_status |=
 1686              		.loc 1 374 27
 1687 0054 033CA0E1 		lsl	r3, r3, #24
 1688 0058 433CA0E1 		asr	r3, r3, #24
 1689 005c 033082E1 		orr	r3, r2, r3
 1690 0060 033CA0E1 		lsl	r3, r3, #24
 1691 0064 432CA0E1 		asr	r2, r3, #24
 1692 0068 94319FE5 		ldr	r3, .L80+8
 1693 006c 0020C3E5 		strb	r2, [r3]
 376:main.c        ****                                           // das Terminal zurückschicken
 377:main.c        ****     string[strpos] = c;
 1694              		.loc 1 377 11
 1695 0070 90319FE5 		ldr	r3, .L80+12
 1696 0074 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1697 0078 0320A0E1 		mov	r2, r3
 1698              		.loc 1 377 20
 1699 007c 05105BE5 		ldrb	r1, [fp, #-5]	@ zero_extendqisi2
 1700 0080 84319FE5 		ldr	r3, .L80+16
 1701 0084 0210C3E7 		strb	r1, [r3, r2]
 378:main.c        ****     string[++strpos] = 0;
 1702              		.loc 1 378 12
 1703 0088 78319FE5 		ldr	r3, .L80+12
 1704 008c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1705 0090 013083E2 		add	r3, r3, #1
 1706 0094 FF2003E2 		and	r2, r3, #255
 1707              		.loc 1 378 22
 1708 0098 68319FE5 		ldr	r3, .L80+12
 1709 009c 0020C3E5 		strb	r2, [r3]
 1710              		.loc 1 378 12
 1711 00a0 60319FE5 		ldr	r3, .L80+12
 1712 00a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1713 00a8 0320A0E1 		mov	r2, r3
 1714              		.loc 1 378 22
 1715 00ac 58319FE5 		ldr	r3, .L80+16
 1716 00b0 0010A0E3 		mov	r1, #0
 1717 00b4 0210C3E7 		strb	r1, [r3, r2]
 379:main.c        ****     strpos = strpos >= (sizeof(string) - 1) ? (sizeof(string) - 2) : strpos;
 1718              		.loc 1 379 68
 1719 00b8 48319FE5 		ldr	r3, .L80+12
 1720 00bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1721 00c0 620053E3 		cmp	r3, #98
 1722 00c4 0330A031 		movcc	r3, r3
 1723 00c8 6230A023 		movcs	r3, #98
 1724 00cc FF2003E2 		and	r2, r3, #255
 1725              		.loc 1 379 12
 1726 00d0 30319FE5 		ldr	r3, .L80+12
 1727 00d4 0020C3E5 		strb	r2, [r3]
 380:main.c        **** 
 381:main.c        ****     if (c == '\r') {
 1728              		.loc 1 381 11
 1729 00d8 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1730              		.loc 1 381 8
 1731 00dc 0D0053E3 		cmp	r3, #13
 1732 00e0 4100001A 		bne	.L79
 382:main.c        ****       string[--strpos] = 0;
 1733              		.loc 1 382 14
 1734 00e4 1C319FE5 		ldr	r3, .L80+12
 1735 00e8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1736 00ec 013043E2 		sub	r3, r3, #1
 1737 00f0 FF2003E2 		and	r2, r3, #255
 1738              		.loc 1 382 24
 1739 00f4 0C319FE5 		ldr	r3, .L80+12
 1740 00f8 0020C3E5 		strb	r2, [r3]
 1741              		.loc 1 382 14
 1742 00fc 04319FE5 		ldr	r3, .L80+12
 1743 0100 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1744 0104 0320A0E1 		mov	r2, r3
 1745              		.loc 1 382 24
 1746 0108 FC309FE5 		ldr	r3, .L80+16
 1747 010c 0010A0E3 		mov	r1, #0
 1748 0110 0210C3E7 		strb	r1, [r3, r2]
 383:main.c        ****       main_data.term_status |= term_string("\n\r==>ENTER gedr\xFC"
 1749              		.loc 1 383 32
 1750 0114 0010A0E3 		mov	r1, #0
 1751 0118 F0009FE5 		ldr	r0, .L80+20
 1752 011c F0309FE5 		ldr	r3, .L80+24
 1753 0120 0FE0A0E1 		mov	lr, pc
 1754 0124 13FF2FE1 		bx	r3
 1755              	.LVL43:
 1756 0128 0030A0E1 		mov	r3, r0
 1757              		.loc 1 383 16 discriminator 1
 1758 012c D0209FE5 		ldr	r2, .L80+8
 1759 0130 D020D2E1 		ldrsb	r2, [r2]
 1760              		.loc 1 383 29 discriminator 1
 1761 0134 033CA0E1 		lsl	r3, r3, #24
 1762 0138 433CA0E1 		asr	r3, r3, #24
 1763 013c 033082E1 		orr	r3, r2, r3
 1764 0140 033CA0E1 		lsl	r3, r3, #24
 1765 0144 432CA0E1 		asr	r2, r3, #24
 1766 0148 B4309FE5 		ldr	r3, .L80+8
 1767 014c 0020C3E5 		strb	r2, [r3]
 384:main.c        ****                                            "ckt: '",
 385:main.c        ****                                            ASYNCSYNC_NONBLOCK);
 386:main.c        ****       main_data.term_status |= term_string((char *)string, ASYNCSYNC_NONBLOCK);
 1768              		.loc 1 386 32
 1769 0150 0010A0E3 		mov	r1, #0
 1770 0154 B0009FE5 		ldr	r0, .L80+16
 1771 0158 B4309FE5 		ldr	r3, .L80+24
 1772 015c 0FE0A0E1 		mov	lr, pc
 1773 0160 13FF2FE1 		bx	r3
 1774              	.LVL44:
 1775 0164 0030A0E1 		mov	r3, r0
 1776              		.loc 1 386 16 discriminator 1
 1777 0168 94209FE5 		ldr	r2, .L80+8
 1778 016c D020D2E1 		ldrsb	r2, [r2]
 1779              		.loc 1 386 29 discriminator 1
 1780 0170 033CA0E1 		lsl	r3, r3, #24
 1781 0174 433CA0E1 		asr	r3, r3, #24
 1782 0178 033082E1 		orr	r3, r2, r3
 1783 017c 033CA0E1 		lsl	r3, r3, #24
 1784 0180 432CA0E1 		asr	r2, r3, #24
 1785 0184 78309FE5 		ldr	r3, .L80+8
 1786 0188 0020C3E5 		strb	r2, [r3]
 387:main.c        ****       main_data.term_status |= term_string("'\n\r", ASYNCSYNC_NONBLOCK);
 1787              		.loc 1 387 32
 1788 018c 0010A0E3 		mov	r1, #0
 1789 0190 80009FE5 		ldr	r0, .L80+28
 1790 0194 78309FE5 		ldr	r3, .L80+24
 1791 0198 0FE0A0E1 		mov	lr, pc
 1792 019c 13FF2FE1 		bx	r3
 1793              	.LVL45:
 1794 01a0 0030A0E1 		mov	r3, r0
 1795              		.loc 1 387 16 discriminator 1
 1796 01a4 58209FE5 		ldr	r2, .L80+8
 1797 01a8 D020D2E1 		ldrsb	r2, [r2]
 1798              		.loc 1 387 29 discriminator 1
 1799 01ac 033CA0E1 		lsl	r3, r3, #24
 1800 01b0 433CA0E1 		asr	r3, r3, #24
 1801 01b4 033082E1 		orr	r3, r2, r3
 1802 01b8 033CA0E1 		lsl	r3, r3, #24
 1803 01bc 432CA0E1 		asr	r2, r3, #24
 1804 01c0 3C309FE5 		ldr	r3, .L80+8
 1805 01c4 0020C3E5 		strb	r2, [r3]
 388:main.c        ****       // oberen 128 ASCII zeichen des Terminal-Fensters sind wie folgt codiert
 389:main.c        ****       // https://en.wikipedia.org/wiki/VT100_encoding
 390:main.c        **** 
 391:main.c        ****       strpos = 0;
 1806              		.loc 1 391 14
 1807 01c8 38309FE5 		ldr	r3, .L80+12
 1808 01cc 0020A0E3 		mov	r2, #0
 1809 01d0 0020C3E5 		strb	r2, [r3]
 392:main.c        ****       string[strpos] = 0;
 1810              		.loc 1 392 13
 1811 01d4 2C309FE5 		ldr	r3, .L80+12
 1812 01d8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1813 01dc 0320A0E1 		mov	r2, r3
 1814              		.loc 1 392 22
 1815 01e0 24309FE5 		ldr	r3, .L80+16
 1816 01e4 0010A0E3 		mov	r1, #0
 1817 01e8 0210C3E7 		strb	r1, [r3, r2]
 1818              	.L79:
 393:main.c        ****     }
 394:main.c        ****   }
 395:main.c        **** }
 1819              		.loc 1 395 1
 1820 01ec 0000A0E1 		nop
 1821 01f0 04D04BE2 		sub	sp, fp, #4
 1822              		.cfi_def_cfa 13, 8
 1823              		@ sp needed
 1824 01f4 0048BDE8 		pop	{fp, lr}
 1825              		.cfi_restore 14
 1826              		.cfi_restore 11
 1827              		.cfi_def_cfa_offset 0
 1828 01f8 1EFF2FE1 		bx	lr
 1829              	.L81:
 1830              		.align	2
 1831              	.L80:
 1832 01fc 00000000 		.word	term_read
 1833 0200 00000000 		.word	term_char
 1834 0204 00000000 		.word	main_data
 1835 0208 28030000 		.word	strpos.3
 1836 020c 2C030000 		.word	string.2
 1837 0210 30000000 		.word	.LC7
 1838 0214 00000000 		.word	term_string
 1839 0218 48000000 		.word	.LC8
 1840              		.cfi_endproc
 1841              	.LFE26:
 1843              		.section	.text.premain_init,"ax",%progbits
 1844              		.align	2
 1845              		.global	premain_init
 1846              		.syntax unified
 1847              		.arm
 1849              	premain_init:
 1850              	.LFB27:
 396:main.c        **** /*****************************************************************************/
 397:main.c        **** /*    Pre-Main-Funktion                                                      */
 398:main.c        **** /*****************************************************************************/
 399:main.c        **** // Zur Vermeidung von malloc(1024) bei der ersten Ausgabe über stdout!
 400:main.c        **** //__attribute__(constructor) stellt sicher, dass premain_init() direkt nach
 401:main.c        **** //__sinit() aufgerufen wird (beides innerhalb von __libc_init_array())
 402:main.c        **** void __attribute__((constructor)) premain_init(void) {
 1851              		.loc 1 402 54
 1852              		.cfi_startproc
 1853              		@ Function supports interworking.
 1854              		@ args = 0, pretend = 0, frame = 0
 1855              		@ frame_needed = 1, uses_anonymous_args = 0
 1856 0000 30482DE9 		push	{r4, r5, fp, lr}
 1857              		.cfi_def_cfa_offset 16
 1858              		.cfi_offset 4, -16
 1859              		.cfi_offset 5, -12
 1860              		.cfi_offset 11, -8
 1861              		.cfi_offset 14, -4
 1862 0004 0CB08DE2 		add	fp, sp, #12
 1863              		.cfi_def_cfa 11, 4
 403:main.c        **** #if 0
 404:main.c        **** 	//No linebuffering, call stdio_write() immediately
 405:main.c        **** 	//-> Langsam, da mit jedem Zeichen __sflush_r()/_write()/stdio_write() aufgerufen wird 
 406:main.c        **** 	setvbuf(stdout,NULL,_IONBF,0);
 407:main.c        **** #else
 408:main.c        ****   static char linebuf[10];
 409:main.c        ****   // LineBuffering into global Varialbe (guter Kompromiss)
 410:main.c        ****   setvbuf(stdout, linebuf, _IOLBF, sizeof(linebuf)); // Linebuffering in
 1864              		.loc 1 410 11
 1865 0008 2C309FE5 		ldr	r3, .L83
 1866 000c 003093E5 		ldr	r3, [r3]
 1867 0010 080093E5 		ldr	r0, [r3, #8]
 1868              		.loc 1 410 3
 1869 0014 0A30A0E3 		mov	r3, #10
 1870 0018 0120A0E3 		mov	r2, #1
 1871 001c 1C109FE5 		ldr	r1, .L83+4
 1872 0020 1C409FE5 		ldr	r4, .L83+8
 1873 0024 0FE0A0E1 		mov	lr, pc
 1874 0028 14FF2FE1 		bx	r4
 1875              	.LVL46:
 411:main.c        **** #endif
 412:main.c        **** }
 1876              		.loc 1 412 1
 1877 002c 0000A0E1 		nop
 1878 0030 0CD04BE2 		sub	sp, fp, #12
 1879              		.cfi_def_cfa 13, 16
 1880              		@ sp needed
 1881 0034 3048BDE8 		pop	{r4, r5, fp, lr}
 1882              		.cfi_restore 14
 1883              		.cfi_restore 11
 1884              		.cfi_restore 5
 1885              		.cfi_restore 4
 1886              		.cfi_def_cfa_offset 0
 1887 0038 1EFF2FE1 		bx	lr
 1888              	.L84:
 1889              		.align	2
 1890              	.L83:
 1891 003c 00000000 		.word	_impure_ptr
 1892 0040 90030000 		.word	linebuf.1
 1893 0044 00000000 		.word	setvbuf
 1894              		.cfi_endproc
 1895              	.LFE27:
 1897              		.section	.init_array,"aw",%init_array
 1898              		.align	2
 1899 0000 00000000 		.word	premain_init(target1)
 1900              		.section	.rodata
 1901              		.align	2
 1902              	.LC9:
 1903 004c 64656D6F 		.ascii	"demo : 11:52:06\000"
 1903      203A2031 
 1903      313A3532 
 1903      3A303600 
 1904              		.align	2
 1905              	.LC10:
 1906 005c 1B5B324A 		.ascii	"\033[2J\033[H\033[0m\000"
 1906      1B5B481B 
 1906      5B306D00 
 1907              		.align	2
 1908              	.LC11:
 1909 0068 50726F67 		.ascii	"Prog: demo\012\015Version von: Oct  6 2025 11:52:06"
 1909      3A206465 
 1909      6D6F0A0D 
 1909      56657273 
 1909      696F6E20 
 1910 0095 0A0D00   		.ascii	"\012\015\000"
 1911              		.align	2
 1912              	.LC12:
 1913 0098 27762E64 		.ascii	"'v.draw %e trace_buf0 trace_buf1' zum oeffnen eines"
 1913      72617720 
 1913      25652074 
 1913      72616365 
 1913      5F627566 
 1914 00cb 20274F73 		.ascii	" 'Oszilloskop'\012\015\000"
 1914      7A696C6C 
 1914      6F736B6F 
 1914      70270A0D 
 1914      00
 1915              		.align	2
 1916              	.LC13:
 1917 00dc 27646F20 		.ascii	"'do trace_scope' zum oeffnen eines 'Oszilloskop'\012"
 1917      74726163 
 1917      655F7363 
 1917      6F706527 
 1917      207A756D 
 1918 010d 0D00     		.ascii	"\015\000"
 1919 010f 00       		.align	2
 1920              	.LC14:
 1921 0110 4E585420 		.ascii	"NXT Display Fenster am besten schliessen\012\015\000"
 1921      44697370 
 1921      6C617920 
 1921      46656E73 
 1921      74657220 
 1922 013b 00       		.align	2
 1923              	.LC15:
 1924 013c 5669656C 		.ascii	"Viel Erfolg!\012\015\000"
 1924      20457266 
 1924      6F6C6721 
 1924      0A0D00
 1925 014b 00       		.align	2
 1926              	.LC16:
 1927 014c 00       		.ascii	"\000"
 1928 014d 000000   		.align	2
 1929              	.LC17:
 1930 0150 386D7300 		.ascii	"8ms\000"
 1931              		.align	2
 1932              	.LC18:
 1933 0154 31366D73 		.ascii	"16ms\000"
 1933      00
 1934 0159 000000   		.align	2
 1935              	.LC19:
 1936 015c 33326D73 		.ascii	"32ms\000"
 1936      00
 1937 0161 000000   		.align	2
 1938              	.LC20:
 1939 0164 36346D73 		.ascii	"64ms\000"
 1939      00
 1940 0169 000000   		.align	2
 1941              	.LC21:
 1942 016c 3132386D 		.ascii	"128ms\000"
 1942      7300
 1943 0172 0000     		.align	2
 1944              	.LC22:
 1945 0174 3235366D 		.ascii	"256ms\000"
 1945      7300
 1946 017a 0000     		.align	2
 1947              	.LC23:
 1948 017c 3531326D 		.ascii	"512ms\000"
 1948      7300
 1949 0182 0000     		.align	2
 1950              	.LC24:
 1951 0184 31303234 		.ascii	"1024ms\000"
 1951      6D7300
 1952 018b 00       		.align	2
 1953              	.LC25:
 1954 018c 49646C65 		.ascii	"Idle\000"
 1954      00
 1955 0191 000000   		.align	2
 1956              	.LC26:
 1957 0194 1B5B3331 		.ascii	"\033[31mTiming durch '\000"
 1957      6D54696D 
 1957      696E6720 
 1957      64757263 
 1957      68202700 
 1958              		.align	2
 1959              	.LC27:
 1960 01a8 27207665 		.ascii	"' verletzt\012\015\033[39m\000"
 1960      726C6574 
 1960      7A740A0D 
 1960      1B5B3339 
 1960      6D00
 1961 01ba 0000     		.align	2
 1962              	.LC28:
 1963 01bc 1B5B3331 		.ascii	"\033[31mStack overflow durch '\000"
 1963      6D537461 
 1963      636B206F 
 1963      76657266 
 1963      6C6F7720 
 1964              		.align	2
 1965              	.LC29:
 1966 01d8 270A0D1B 		.ascii	"'\012\015\033[39m\000"
 1966      5B33396D 
 1966      00
 1967 01e1 000000   		.align	2
 1968              	.LC30:
 1969 01e4 1B5B3331 		.ascii	"\033[31m\012\015Low Battery\012\015\033[39m\000"
 1969      6D0A0D4C 
 1969      6F772042 
 1969      61747465 
 1969      72790A0D 
 1970 01fe 0000     		.align	2
 1971              	.LC31:
 1972 0200 1B5B3331 		.ascii	"\033[31m\012\015Terminal Overflow\012\015\033[39m\000"
 1972      6D0A0D54 
 1972      65726D69 
 1972      6E616C20 
 1972      4F766572 
 1973              		.section	.text.main,"ax",%progbits
 1974              		.align	2
 1975              		.global	main
 1976              		.syntax unified
 1977              		.arm
 1979              	main:
 1980              	.LFB28:
 413:main.c        **** /*****************************************************************************/
 414:main.c        **** /*    Main-Funktion                                                          */
 415:main.c        **** /*****************************************************************************/
 416:main.c        **** #if 0
 417:main.c        **** //Variante 1: Deklaration der main() Funktion
 418:main.c        **** //da es keine CLI gibt, über welcher die Anwendung getartet wird
 419:main.c        **** //sondern der start über startup.s erfolgt, macht dies kein Sinn
 420:main.c        **** //und belegt unnötige Speicherplatz auf den Stack
 421:main.c        **** int main(int argc, char *argv[]) 
 422:main.c        **** {
 423:main.c        **** 	(void) argc;
 424:main.c        **** 	(void) argv;
 425:main.c        **** #else
 426:main.c        **** // Variante 2: Deklaration der main() funktion
 427:main.c        **** int main(void) {
 1981              		.loc 1 427 16
 1982              		.cfi_startproc
 1983              		@ Function supports interworking.
 1984              		@ args = 0, pretend = 0, frame = 24
 1985              		@ frame_needed = 1, uses_anonymous_args = 0
 1986 0000 00482DE9 		push	{fp, lr}
 1987              		.cfi_def_cfa_offset 8
 1988              		.cfi_offset 11, -8
 1989              		.cfi_offset 14, -4
 1990 0004 04B08DE2 		add	fp, sp, #4
 1991              		.cfi_def_cfa 11, 4
 1992 0008 18D04DE2 		sub	sp, sp, #24
 428:main.c        **** #endif
 429:main.c        ****   /* Interrupts zu diesem Zeitpunkt disabled !!!! */
 430:main.c        **** 
 431:main.c        ****   /* 'Pflicht' Initialisierung, können nicht ausgelassen werden */
 432:main.c        ****   aic_init();          // Interrupt-Controller initialisieren
 1993              		.loc 1 432 3
 1994 000c E4359FE5 		ldr	r3, .L114
 1995 0010 0FE0A0E1 		mov	lr, pc
 1996 0014 13FF2FE1 		bx	r3
 1997              	.LVL47:
 433:main.c        ****   systick_init();      // System-Timer initialisieren
 1998              		.loc 1 433 3
 1999 0018 DC359FE5 		ldr	r3, .L114+4
 2000 001c 0FE0A0E1 		mov	lr, pc
 2001 0020 13FF2FE1 		bx	r3
 2002              	.LVL48:
 434:main.c        ****   interrupts_enable(); // Ohne Worte
 2003              		.loc 1 434 3
 2004 0024 D4359FE5 		ldr	r3, .L114+8
 2005 0028 0FE0A0E1 		mov	lr, pc
 2006 002c 13FF2FE1 		bx	r3
 2007              	.LVL49:
 435:main.c        ****   nxt_avr_init(8);
 2008              		.loc 1 435 3
 2009 0030 0800A0E3 		mov	r0, #8
 2010 0034 C8359FE5 		ldr	r3, .L114+12
 2011 0038 0FE0A0E1 		mov	lr, pc
 2012 003c 13FF2FE1 		bx	r3
 2013              	.LVL50:
 436:main.c        **** #if defined(MODE_RAM) || defined(MODE_SIM)
 437:main.c        ****   udmon3_init(); // Speicherzugriff durch den Debugger
 2014              		.loc 1 437 3
 2015 0040 C0359FE5 		ldr	r3, .L114+16
 2016 0044 0FE0A0E1 		mov	lr, pc
 2017 0048 13FF2FE1 		bx	r3
 2018              	.LVL51:
 438:main.c        ****                  // zur Programmlaufzeit mittels der
 439:main.c        ****                  // DCC Schnittstelle ermöglichen
 440:main.c        **** #endif
 441:main.c        **** 
 442:main.c        ****   /* 'Wahl' Initialisierung, hängt von den benötigten Komponenten ab */
 443:main.c        ****   term_init();
 2019              		.loc 1 443 3
 2020 004c B8359FE5 		ldr	r3, .L114+20
 2021 0050 0FE0A0E1 		mov	lr, pc
 2022 0054 13FF2FE1 		bx	r3
 2023              	.LVL52:
 444:main.c        ****   display_init();
 2024              		.loc 1 444 3
 2025 0058 B0359FE5 		ldr	r3, .L114+24
 2026 005c 0FE0A0E1 		mov	lr, pc
 2027 0060 13FF2FE1 		bx	r3
 2028              	.LVL53:
 445:main.c        ****   display_clear(0);
 2029              		.loc 1 445 3
 2030 0064 0000A0E3 		mov	r0, #0
 2031 0068 A4359FE5 		ldr	r3, .L114+28
 2032 006c 0FE0A0E1 		mov	lr, pc
 2033 0070 13FF2FE1 		bx	r3
 2034              	.LVL54:
 446:main.c        ****   display_string(APP_NAME " : " __TIME__);
 2035              		.loc 1 446 3
 2036 0074 9C059FE5 		ldr	r0, .L114+32
 2037 0078 9C359FE5 		ldr	r3, .L114+36
 2038 007c 0FE0A0E1 		mov	lr, pc
 2039 0080 13FF2FE1 		bx	r3
 2040              	.LVL55:
 447:main.c        ****   display_update();
 2041              		.loc 1 447 3
 2042 0084 94359FE5 		ldr	r3, .L114+40
 2043 0088 0FE0A0E1 		mov	lr, pc
 2044 008c 13FF2FE1 		bx	r3
 2045              	.LVL56:
 448:main.c        **** 
 449:main.c        ****   // ANSI Escape sequences - VT100 / VT52 (see main.h)
 450:main.c        ****   (void)term_string(
 2046              		.loc 1 450 9
 2047 0090 0110A0E3 		mov	r1, #1
 2048 0094 88059FE5 		ldr	r0, .L114+44
 2049 0098 88359FE5 		ldr	r3, .L114+48
 2050 009c 0FE0A0E1 		mov	lr, pc
 2051 00a0 13FF2FE1 		bx	r3
 2052              	.LVL57:
 451:main.c        ****       "\033[2J" VT100_CURSORHOME // Move Cursor to home position (0,0)
 452:main.c        ****           VT100_DEFAULT,
 453:main.c        ****       ASYNCSYNC_BLOCK);
 454:main.c        ****   (void)term_string("Prog: " APP_NAME "\n\rVersion von: " __DATE__ " " __TIME__
 2053              		.loc 1 454 9
 2054 00a4 0110A0E3 		mov	r1, #1
 2055 00a8 7C059FE5 		ldr	r0, .L114+52
 2056 00ac 74359FE5 		ldr	r3, .L114+48
 2057 00b0 0FE0A0E1 		mov	lr, pc
 2058 00b4 13FF2FE1 		bx	r3
 2059              	.LVL58:
 455:main.c        ****                     "\n\r",
 456:main.c        ****                     ASYNCSYNC_BLOCK);
 457:main.c        ****   (void)term_string(
 2060              		.loc 1 457 9
 2061 00b8 0110A0E3 		mov	r1, #1
 2062 00bc 6C059FE5 		ldr	r0, .L114+56
 2063 00c0 60359FE5 		ldr	r3, .L114+48
 2064 00c4 0FE0A0E1 		mov	lr, pc
 2065 00c8 13FF2FE1 		bx	r3
 2066              	.LVL59:
 458:main.c        ****       "'v.draw %e trace_buf0 trace_buf1' zum oeffnen eines 'Oszilloskop'\n\r",
 459:main.c        ****       ASYNCSYNC_BLOCK);
 460:main.c        ****   (void)term_string("'do trace_scope' zum oeffnen eines 'Oszilloskop'\n\r",
 2067              		.loc 1 460 9
 2068 00cc 0110A0E3 		mov	r1, #1
 2069 00d0 5C059FE5 		ldr	r0, .L114+60
 2070 00d4 4C359FE5 		ldr	r3, .L114+48
 2071 00d8 0FE0A0E1 		mov	lr, pc
 2072 00dc 13FF2FE1 		bx	r3
 2073              	.LVL60:
 461:main.c        ****                     ASYNCSYNC_BLOCK);
 462:main.c        ****   (void)term_string("NXT Display Fenster am besten schliessen\n\r",
 2074              		.loc 1 462 9
 2075 00e0 0110A0E3 		mov	r1, #1
 2076 00e4 4C059FE5 		ldr	r0, .L114+64
 2077 00e8 38359FE5 		ldr	r3, .L114+48
 2078 00ec 0FE0A0E1 		mov	lr, pc
 2079 00f0 13FF2FE1 		bx	r3
 2080              	.LVL61:
 463:main.c        ****                     ASYNCSYNC_BLOCK);
 464:main.c        ****   (void)term_string("Viel Erfolg!\n\r", ASYNCSYNC_BLOCK);
 2081              		.loc 1 464 9
 2082 00f4 0110A0E3 		mov	r1, #1
 2083 00f8 3C059FE5 		ldr	r0, .L114+68
 2084 00fc 24359FE5 		ldr	r3, .L114+48
 2085 0100 0FE0A0E1 		mov	lr, pc
 2086 0104 13FF2FE1 		bx	r3
 2087              	.LVL62:
 465:main.c        **** 
 466:main.c        ****   // Alternativ zu term_xxx() kann auch printf() oder noch besser iprintf
 467:main.c        ****   // genutzt werden beide bedingen jedoch einen großen Speicherbedarf!
 468:main.c        ****   // Alternativ zu term_read() kann auch scanf() genutzt werden. Auch diese
 469:main.c        ****   // Funktion
 470:main.c        ****   //  bedingt einen großen Speicherbedarf
 471:main.c        **** 
 472:main.c        **** #ifndef MODE_ROM
 473:main.c        ****   /* Watchdog Disable */
 474:main.c        ****   /* Mode-Register kann nur einmal beschrieben werden */
 475:main.c        ****   AT91C_BASE_WDTC->WDTC_WDMR = 0xFFF | AT91C_WDTC_WDDIS | /*WD Disable */
 2088              		.loc 1 475 18
 2089 0108 30359FE5 		ldr	r3, .L114+72
 2090              		.loc 1 475 30
 2091 010c 30259FE5 		ldr	r2, .L114+76
 2092 0110 042083E5 		str	r2, [r3, #4]
 2093              	.LBB8:
 2094              	.LBB9:
 2095              		.file 4 "lib/../main.h"
   1:lib/../main.h **** #ifndef main_h
   2:lib/../main.h **** #define main_h
   3:lib/../main.h **** #include <stdint.h>
   4:lib/../main.h **** 
   5:lib/../main.h **** //ASCII-Zeichen
   6:lib/../main.h **** //\a The “alert” character, Ctrl-g, ASCII code 7 (BEL). (This usually makes some sort of audibl
   7:lib/../main.h **** //\b Backspace, Ctrl-h, ASCII code 8 (BS).
   8:lib/../main.h **** //\f Formfeed, Ctrl-l, ASCII code 12 (FF).
   9:lib/../main.h **** //\n Newline, Ctrl-j, ASCII code 10 (LF).
  10:lib/../main.h **** //\r Carriage return, Ctrl-m, ASCII code 13 (CR).
  11:lib/../main.h **** //\t Horizontal TAB, Ctrl-i, ASCII code 9 (HT).
  12:lib/../main.h **** //\v Vertical tab, Ctrl-k, ASCII code 11 (VT).
  13:lib/../main.h **** //\nnn The octal value nnn, where nnn stands for 1 to 3 digits between ‘0’ and ‘7’. For exa
  14:lib/../main.h **** //\xhh...The hexadecimal value hh, where hh stands for a sequence of hexadecimal digits (‘0’–
  15:lib/../main.h **** //       Like the same construct in ISO C, the escape sequence continues until 
  16:lib/../main.h **** //       the first nonhexadecimal digit is seen. (c.e.) However, using more 
  17:lib/../main.h **** //       than two hexadecimal digits produces undefined results. 
  18:lib/../main.h **** //       (The ‘\x’ escape sequence is not allowed in POSIX awk.)
  19:lib/../main.h **** //\/ A literal slash (necessary for regexp constants only). This sequence 
  20:lib/../main.h **** //       is used when you want to write a regexp constant that contains a 
  21:lib/../main.h **** //       slash. Because the regexp is delimited by slashes, you need to 
  22:lib/../main.h **** //       escape the slash that is part of the pattern, in order to tell 
  23:lib/../main.h **** //       awk to keep processing the rest of the regexp.
  24:lib/../main.h **** //\"  A literal double quote (necessary for string constants only). 
  25:lib/../main.h **** //       This sequence is used when you want to write a string constant 
  26:lib/../main.h **** //       that contains a double quote. Because the string is delimited by 
  27:lib/../main.h **** //       double quotes, you need to escape the quote that is part of 
  28:lib/../main.h **** //       the string, in order to tell awk to keep processing the rest
  29:lib/../main.h **** //       of the string.#define ANSI_BLACK   30
  30:lib/../main.h **** 
  31:lib/../main.h **** //https://www-user.tu-chemnitz.de/~heha/hsn/terminal/terminal.htm
  32:lib/../main.h **** //https://gist.github.com/ConnerWill/d4b6c776b509add763e17f9f113fd25b
  33:lib/../main.h **** //Cursor Control
  34:lib/../main.h **** #define VT100_CURSORHOME      "\e[H"
  35:lib/../main.h **** #define VT100_CLEARSCREEN     "\e[2J"
  36:lib/../main.h **** #define VT100_GOTOYX          "\e[%d;%dH"
  37:lib/../main.h **** #define VT100_SAVEPOS         "\e7"
  38:lib/../main.h **** #define VT100_RESTOREPOS      "\e8"
  39:lib/../main.h **** #define VT100_ROLLY1Y2        "\e[%d;%dr"
  40:lib/../main.h **** #define VT100_ROLLOFF         "\e[r"
  41:lib/../main.h **** //Erase Functions
  42:lib/../main.h **** #define VT100_ERASEFROMCURSOR "\e[0J"
  43:lib/../main.h **** #define VT100_ERASETOCURSOR   "\e[1J"
  44:lib/../main.h **** #define VT100_ERASESCREEN     "\e[2J"
  45:lib/../main.h **** #define VT100_DEL_UNTILEOL    "\e[K"
  46:lib/../main.h **** #define VT100_DEL_TOCUR       "\e[1K"
  47:lib/../main.h **** #define VT100_DEL_LINE        "\e[2K"
  48:lib/../main.h **** //Color/Graphics Mode
  49:lib/../main.h **** #define VT100_DEFAULT         "\e[0m"  //stellt hellgraue Schrift auf schwarzem Grund ein
  50:lib/../main.h **** #define VT100_FETT              "\e[1m"
  51:lib/../main.h **** #define VT100_FETT_AUS          "\e[22m"
  52:lib/../main.h **** #define VT100_UNTERSTRICHEN     "\e[4m"
  53:lib/../main.h **** #define VT100_UNTERSTRICHEN_AUS "\e[24m"
  54:lib/../main.h **** #define VT100_BLINKEN           "\e[5m"
  55:lib/../main.h **** #define VT100_BLINKEN_AUS       "\e[25m"
  56:lib/../main.h **** #define VT100_INVERS            "\e[7m"
  57:lib/../main.h **** #define VT100_INVERS_AUS        "\e[27m"
  58:lib/../main.h **** #define VT100_UNSICHTBAR        "\e[8m"
  59:lib/../main.h **** #define VT100_SICHTBAR          "\e[28m"
  60:lib/../main.h **** #define VT100_VORDERGRUND_SCHWARZ "\e[30m"
  61:lib/../main.h **** #define VT100_VORDERGRUND_ROT     "\e[31m"
  62:lib/../main.h **** #define VT100_VORDERGRUND_GRUEN   "\e[32m"
  63:lib/../main.h **** #define VT100_VORDERGRUND_BRAUN   "\e[33m"
  64:lib/../main.h **** #define VT100_VORDERGRUND_BLAU    "\e[34m"
  65:lib/../main.h **** #define VT100_VORDERGRUND_BLAUROT "\e[35m"
  66:lib/../main.h **** #define VT100_VORDERGRUND_ZYAN    "\e[36m"
  67:lib/../main.h **** #define VT100_VORDERGRUND_WEISS   "\e[37m"  //Default
  68:lib/../main.h **** #define VT100_VORDERGRUND_DEFAULT "\e[39m"  //Nicht VT100
  69:lib/../main.h **** #define VT100_HINTERGRUND_SCHWARZ "\e[40m"  //Default
  70:lib/../main.h **** #define VT100_HINTERGRUND_ROT     "\e[41m"  
  71:lib/../main.h **** #define VT100_HINTERGRUND_GRUEN   "\e[42m"  
  72:lib/../main.h **** #define VT100_HINTERGRUND_BRAUN   "\e[43m"  
  73:lib/../main.h **** #define VT100_HINTERGRUND_BLAU    "\e[44m"  
  74:lib/../main.h **** #define VT100_HINTERGRUND_BLAUROT "\e[45m"  
  75:lib/../main.h **** #define VT100_HINTERGRUND_ZYAN    "\e[46m"  
  76:lib/../main.h **** #define VT100_HINTERGRUND_WEISS   "\e[47m"  
  77:lib/../main.h **** #define VT100_HINTERGRUND_DEFAULT "\e[49m"
  78:lib/../main.h **** 
  79:lib/../main.h ****                                                          /* Main Clock [Hz] */
  80:lib/../main.h **** #define MAINCK            18432000
  81:lib/../main.h ****                                      /* Maseter Clock (PLLRC div by 2) [Hz] */
  82:lib/../main.h **** #define MCK               47923200
  83:lib/../main.h ****                                              /* System clock tick rate [Hz] */
  84:lib/../main.h **** #define BSP_TICKS_PER_SEC 1000
  85:lib/../main.h **** 
  86:lib/../main.h **** //#define NODISCARD __attribute__((warn_unused_result))  
  87:lib/../main.h **** #define NODISCARD  [[nodiscard]]
  88:lib/../main.h **** 
  89:lib/../main.h **** typedef enum __attribute__((packed)) {ASYNCSYNC_NONBLOCK,ASYNCSYNC_BLOCK,ASYNCSYNC_ASYNCGET} asyncs
  90:lib/../main.h **** 
  91:lib/../main.h **** typedef enum {SENSOR_1,SENSOR_2,SENSOR_3,SENSOR_4,SENSOR_MAX} sensor_t;
  92:lib/../main.h **** 
  93:lib/../main.h **** typedef enum {MOTOR_A,MOTOR_B,MOTOR_C} motor_t;
  94:lib/../main.h **** 
  95:lib/../main.h **** typedef enum {MOTOR_BREAK, MOTOR_FLOAT} motor_zustand_t;
  96:lib/../main.h **** 
  97:lib/../main.h **** typedef enum {SENSOR_OFF=0x00, SENSOR_9V_PULSED=0x01, SENSOR_9V=0x10 } sensor_power_t;
  98:lib/../main.h **** 
  99:lib/../main.h **** typedef enum {BATTERY_AA, BATTERY_ACCU} battery_t;
 100:lib/../main.h **** 
 101:lib/../main.h **** typedef struct {
 102:lib/../main.h **** 	uint8_t orange : 1;
 103:lib/../main.h **** 	uint8_t left : 1;
 104:lib/../main.h **** 	uint8_t right : 1;
 105:lib/../main.h **** 	uint8_t grey : 1;
 106:lib/../main.h **** 	uint8_t reserved : 4;
 107:lib/../main.h **** } button_t;
 108:lib/../main.h **** 
 109:lib/../main.h **** #define I2C_BAUDRATE 10000  //Orignal 9600
 110:lib/../main.h **** 
 111:lib/../main.h **** extern uint32_t __stack_start__[];   //Definiert in link.ld
 112:lib/../main.h **** extern uint32_t __stack_end__;       //Definiert in link.ld
 113:lib/../main.h **** #define STACK_FILL 0x11111111
 114:lib/../main.h **** 
 115:lib/../main.h **** static __inline__ void stack_fill(void) __attribute__((always_inline));
 116:lib/../main.h **** static __inline__ void stack_fill(void)
 117:lib/../main.h **** {
 118:lib/../main.h **** 	         uint32_t *ptr;
 119:lib/../main.h **** 	register uint32_t *sp asm("r13");
 120:lib/../main.h **** 	for(ptr=&__stack_start__[0];ptr<sp;ptr++)
 2096              		.loc 4 120 9
 2097 0114 2C359FE5 		ldr	r3, .L114+80
 2098 0118 14300BE5 		str	r3, [fp, #-20]
 2099              		.loc 4 120 2
 2100 011c 050000EA 		b	.L86
 2101              	.L87:
 121:lib/../main.h **** 		*ptr=STACK_FILL;
 2102              		.loc 4 121 7
 2103 0120 14301BE5 		ldr	r3, [fp, #-20]
 2104 0124 20259FE5 		ldr	r2, .L114+84
 2105 0128 002083E5 		str	r2, [r3]
 120:lib/../main.h **** 		*ptr=STACK_FILL;
 2106              		.loc 4 120 40 discriminator 3
 2107 012c 14301BE5 		ldr	r3, [fp, #-20]
 2108 0130 043083E2 		add	r3, r3, #4
 2109 0134 14300BE5 		str	r3, [fp, #-20]
 2110              	.L86:
 120:lib/../main.h **** 		*ptr=STACK_FILL;
 2111              		.loc 4 120 33 discriminator 1
 2112 0138 0D20A0E1 		mov	r2, sp
 2113 013c 14301BE5 		ldr	r3, [fp, #-20]
 2114 0140 020053E1 		cmp	r3, r2
 2115 0144 F5FFFF3A 		bcc	.L87
 122:lib/../main.h **** }
 2116              		.loc 4 122 1
 2117 0148 0000A0E1 		nop
 2118              	.L88:
 2119              	.LBE9:
 2120              	.LBE8:
 476:main.c        ****                                AT91C_WDTC_WDDBGHLT |      /*Debug Halt */
 477:main.c        ****                                AT91C_WDTC_WDIDLEHLT;      /*Idle Halt  */
 478:main.c        **** #else
 479:main.c        **** #if 0
 480:main.c        **** 	/* Watchdog Enable */
 481:main.c        **** 	/* Da in dieser Version kein zyklischer Reset des Watchdogs */
 482:main.c        **** 	/* vorhanden ist, wird von einem Watchdog Enable abgesehen  */
 483:main.c        **** 	/* Mit Reset wird der Wachdog aktiviert!                    */
 484:main.c        **** #else
 485:main.c        **** /* Watchdog Disable */
 486:main.c        **** /* Mode-Register kann nur einmal beschrieben werden */
 487:main.c        **** AT91C_BASE_WDTC->WDTC_WDMR = 0xFFF | AT91C_WDTC_WDDIS | /*WD Disable */
 488:main.c        ****                              AT91C_WDTC_WDDBGHLT |      /*Debug Halt */
 489:main.c        ****                              AT91C_WDTC_WDIDLEHLT;      /*Idle Halt  */
 490:main.c        **** #endif
 491:main.c        **** #endif
 492:main.c        ****   // Vorangegangenen Stackaufbau 'löschen'
 493:main.c        ****   stack_fill();
 494:main.c        ****   // Label, so das mit 'go start' hierin gesprungen werden kann
 495:main.c        **** start:
 496:main.c        ****   __attribute__((unused));
 497:main.c        ****   uint32_t start_tick = systick_get_ms();
 2121              		.loc 1 497 25
 2122 014c FC349FE5 		ldr	r3, .L114+88
 2123 0150 0FE0A0E1 		mov	lr, pc
 2124 0154 13FF2FE1 		bx	r3
 2125              	.LVL63:
 2126 0158 08000BE5 		str	r0, [fp, #-8]
 498:main.c        ****   uint32_t zeitscheibe = 0;
 2127              		.loc 1 498 12
 2128 015c 0030A0E3 		mov	r3, #0
 2129 0160 0C300BE5 		str	r3, [fp, #-12]
 499:main.c        ****   char *task_aktiv = "";
 2130              		.loc 1 499 9
 2131 0164 E8349FE5 		ldr	r3, .L114+92
 2132 0168 10300BE5 		str	r3, [fp, #-16]
 2133              	.L113:
 500:main.c        ****   while (1) {
 501:main.c        ****     // Warten bis zum nächsten TimeSlot
 502:main.c        ****     while ((int)(start_tick - systick_get_ms()) > 0)
 2134              		.loc 1 502 11
 2135 016c 0000A0E1 		nop
 2136              	.L89:
 2137              		.loc 1 502 31 discriminator 1
 2138 0170 D8349FE5 		ldr	r3, .L114+88
 2139 0174 0FE0A0E1 		mov	lr, pc
 2140 0178 13FF2FE1 		bx	r3
 2141              	.LVL64:
 2142 017c 0020A0E1 		mov	r2, r0
 2143              		.loc 1 502 29 discriminator 1
 2144 0180 08301BE5 		ldr	r3, [fp, #-8]
 2145 0184 023043E0 		sub	r3, r3, r2
 2146              		.loc 1 502 49 discriminator 1
 2147 0188 000053E3 		cmp	r3, #0
 2148 018c F7FFFFCA 		bgt	.L89
 503:main.c        ****       ;
 504:main.c        ****     start_tick += ZYKLUS_MS;
 2149              		.loc 1 504 16
 2150 0190 08301BE5 		ldr	r3, [fp, #-8]
 2151 0194 043083E2 		add	r3, r3, #4
 2152 0198 08300BE5 		str	r3, [fp, #-8]
 2153              	.L90:
 505:main.c        ****     // Label, so das mit 'go zyklus' hierhin gesprungen werden kann
 506:main.c        ****   zyklus:
 507:main.c        ****     __attribute__((unused)) if ((zeitscheibe & 0b000000001) == 0b000000001) {
 2154              		.loc 1 507 46
 2155 019c 0C301BE5 		ldr	r3, [fp, #-12]
 2156 01a0 013003E2 		and	r3, r3, #1
 2157              		.loc 1 507 32
 2158 01a4 000053E3 		cmp	r3, #0
 2159 01a8 0500000A 		beq	.L91
 508:main.c        ****       task_aktiv = "8ms";
 2160              		.loc 1 508 18
 2161 01ac A4349FE5 		ldr	r3, .L114+96
 2162 01b0 10300BE5 		str	r3, [fp, #-16]
 509:main.c        ****       task_8ms();
 2163              		.loc 1 509 7
 2164 01b4 A0349FE5 		ldr	r3, .L114+100
 2165 01b8 0FE0A0E1 		mov	lr, pc
 2166 01bc 13FF2FE1 		bx	r3
 2167              	.LVL65:
 2168 01c0 440000EA 		b	.L92
 2169              	.L91:
 510:main.c        ****     }
 511:main.c        ****     else if ((zeitscheibe & 0b000000011) == 0b000000010) {
 2170              		.loc 1 511 27
 2171 01c4 0C301BE5 		ldr	r3, [fp, #-12]
 2172 01c8 033003E2 		and	r3, r3, #3
 2173              		.loc 1 511 13
 2174 01cc 020053E3 		cmp	r3, #2
 2175 01d0 0500001A 		bne	.L93
 512:main.c        ****       task_aktiv = "16ms";
 2176              		.loc 1 512 18
 2177 01d4 84349FE5 		ldr	r3, .L114+104
 2178 01d8 10300BE5 		str	r3, [fp, #-16]
 513:main.c        ****       task_16ms();
 2179              		.loc 1 513 7
 2180 01dc 80349FE5 		ldr	r3, .L114+108
 2181 01e0 0FE0A0E1 		mov	lr, pc
 2182 01e4 13FF2FE1 		bx	r3
 2183              	.LVL66:
 2184 01e8 3A0000EA 		b	.L92
 2185              	.L93:
 514:main.c        ****     }
 515:main.c        ****     else if ((zeitscheibe & 0b000000111) == 0b000000100) {
 2186              		.loc 1 515 27
 2187 01ec 0C301BE5 		ldr	r3, [fp, #-12]
 2188 01f0 073003E2 		and	r3, r3, #7
 2189              		.loc 1 515 13
 2190 01f4 040053E3 		cmp	r3, #4
 2191 01f8 0500001A 		bne	.L94
 516:main.c        ****       task_aktiv = "32ms";
 2192              		.loc 1 516 18
 2193 01fc 64349FE5 		ldr	r3, .L114+112
 2194 0200 10300BE5 		str	r3, [fp, #-16]
 517:main.c        ****       task_32ms();
 2195              		.loc 1 517 7
 2196 0204 60349FE5 		ldr	r3, .L114+116
 2197 0208 0FE0A0E1 		mov	lr, pc
 2198 020c 13FF2FE1 		bx	r3
 2199              	.LVL67:
 2200 0210 300000EA 		b	.L92
 2201              	.L94:
 518:main.c        ****     }
 519:main.c        ****     else if ((zeitscheibe & 0b000001111) == 0b000001000) {
 2202              		.loc 1 519 27
 2203 0214 0C301BE5 		ldr	r3, [fp, #-12]
 2204 0218 0F3003E2 		and	r3, r3, #15
 2205              		.loc 1 519 13
 2206 021c 080053E3 		cmp	r3, #8
 2207 0220 0500001A 		bne	.L95
 520:main.c        ****       task_aktiv = "64ms";
 2208              		.loc 1 520 18
 2209 0224 44349FE5 		ldr	r3, .L114+120
 2210 0228 10300BE5 		str	r3, [fp, #-16]
 521:main.c        ****       task_64ms();
 2211              		.loc 1 521 7
 2212 022c 40349FE5 		ldr	r3, .L114+124
 2213 0230 0FE0A0E1 		mov	lr, pc
 2214 0234 13FF2FE1 		bx	r3
 2215              	.LVL68:
 2216 0238 260000EA 		b	.L92
 2217              	.L95:
 522:main.c        ****     }
 523:main.c        ****     else if ((zeitscheibe & 0b000011111) == 0b000010000) {
 2218              		.loc 1 523 27
 2219 023c 0C301BE5 		ldr	r3, [fp, #-12]
 2220 0240 1F3003E2 		and	r3, r3, #31
 2221              		.loc 1 523 13
 2222 0244 100053E3 		cmp	r3, #16
 2223 0248 0500001A 		bne	.L96
 524:main.c        ****       task_aktiv = "128ms";
 2224              		.loc 1 524 18
 2225 024c 24349FE5 		ldr	r3, .L114+128
 2226 0250 10300BE5 		str	r3, [fp, #-16]
 525:main.c        ****       task_128ms();
 2227              		.loc 1 525 7
 2228 0254 20349FE5 		ldr	r3, .L114+132
 2229 0258 0FE0A0E1 		mov	lr, pc
 2230 025c 13FF2FE1 		bx	r3
 2231              	.LVL69:
 2232 0260 1C0000EA 		b	.L92
 2233              	.L96:
 526:main.c        ****     }
 527:main.c        ****     else if ((zeitscheibe & 0b000111111) == 0b000100000) {
 2234              		.loc 1 527 27
 2235 0264 0C301BE5 		ldr	r3, [fp, #-12]
 2236 0268 3F3003E2 		and	r3, r3, #63
 2237              		.loc 1 527 13
 2238 026c 200053E3 		cmp	r3, #32
 2239 0270 0500001A 		bne	.L97
 528:main.c        ****       task_aktiv = "256ms";
 2240              		.loc 1 528 18
 2241 0274 04349FE5 		ldr	r3, .L114+136
 2242 0278 10300BE5 		str	r3, [fp, #-16]
 529:main.c        ****       task_256ms();
 2243              		.loc 1 529 7
 2244 027c 00349FE5 		ldr	r3, .L114+140
 2245 0280 0FE0A0E1 		mov	lr, pc
 2246 0284 13FF2FE1 		bx	r3
 2247              	.LVL70:
 2248 0288 120000EA 		b	.L92
 2249              	.L97:
 530:main.c        ****     }
 531:main.c        ****     else if ((zeitscheibe & 0b001111111) == 0b001000000) {
 2250              		.loc 1 531 27
 2251 028c 0C301BE5 		ldr	r3, [fp, #-12]
 2252 0290 7F3003E2 		and	r3, r3, #127
 2253              		.loc 1 531 13
 2254 0294 400053E3 		cmp	r3, #64
 2255 0298 0500001A 		bne	.L98
 532:main.c        ****       task_aktiv = "512ms";
 2256              		.loc 1 532 18
 2257 029c E4339FE5 		ldr	r3, .L114+144
 2258 02a0 10300BE5 		str	r3, [fp, #-16]
 533:main.c        ****       task_512ms();
 2259              		.loc 1 533 7
 2260 02a4 E0339FE5 		ldr	r3, .L114+148
 2261 02a8 0FE0A0E1 		mov	lr, pc
 2262 02ac 13FF2FE1 		bx	r3
 2263              	.LVL71:
 2264 02b0 080000EA 		b	.L92
 2265              	.L98:
 534:main.c        ****     }
 535:main.c        ****     else if ((zeitscheibe & 0b011111111) == 0b010000000) {
 2266              		.loc 1 535 27
 2267 02b4 0C301BE5 		ldr	r3, [fp, #-12]
 2268 02b8 FF3003E2 		and	r3, r3, #255
 2269              		.loc 1 535 13
 2270 02bc 800053E3 		cmp	r3, #128
 2271 02c0 0400001A 		bne	.L92
 536:main.c        ****       task_aktiv = "1024ms";
 2272              		.loc 1 536 18
 2273 02c4 C4339FE5 		ldr	r3, .L114+152
 2274 02c8 10300BE5 		str	r3, [fp, #-16]
 537:main.c        ****       task_1024ms();
 2275              		.loc 1 537 7
 2276 02cc C0339FE5 		ldr	r3, .L114+156
 2277 02d0 0FE0A0E1 		mov	lr, pc
 2278 02d4 13FF2FE1 		bx	r3
 2279              	.LVL72:
 2280              	.L92:
 538:main.c        ****     }
 539:main.c        ****     // Zeit für IDLE-Task verfügbar
 540:main.c        ****     if ((int)(start_tick - systick_get_ms()) >= IDLE_MS) {
 2281              		.loc 1 540 28
 2282 02d8 70339FE5 		ldr	r3, .L114+88
 2283 02dc 0FE0A0E1 		mov	lr, pc
 2284 02e0 13FF2FE1 		bx	r3
 2285              	.LVL73:
 2286 02e4 0020A0E1 		mov	r2, r0
 2287              		.loc 1 540 26 discriminator 1
 2288 02e8 08301BE5 		ldr	r3, [fp, #-8]
 2289 02ec 023043E0 		sub	r3, r3, r2
 2290              		.loc 1 540 8 discriminator 1
 2291 02f0 010053E3 		cmp	r3, #1
 2292 02f4 040000DA 		ble	.L99
 541:main.c        ****       task_aktiv = "Idle";
 2293              		.loc 1 541 18
 2294 02f8 98339FE5 		ldr	r3, .L114+160
 2295 02fc 10300BE5 		str	r3, [fp, #-16]
 542:main.c        ****       task_idle();
 2296              		.loc 1 542 7
 2297 0300 94339FE5 		ldr	r3, .L114+164
 2298 0304 0FE0A0E1 		mov	lr, pc
 2299 0308 13FF2FE1 		bx	r3
 2300              	.LVL74:
 2301              	.L99:
 543:main.c        ****     }
 544:main.c        ****     // Max. Zeitdauer einer Zeitscheibe überschritten?
 545:main.c        ****     if ((int)(start_tick - systick_get_ms()) <= 0) {
 2302              		.loc 1 545 28
 2303 030c 3C339FE5 		ldr	r3, .L114+88
 2304 0310 0FE0A0E1 		mov	lr, pc
 2305 0314 13FF2FE1 		bx	r3
 2306              	.LVL75:
 2307 0318 0020A0E1 		mov	r2, r0
 2308              		.loc 1 545 26 discriminator 1
 2309 031c 08301BE5 		ldr	r3, [fp, #-8]
 2310 0320 023043E0 		sub	r3, r3, r2
 2311              		.loc 1 545 8 discriminator 1
 2312 0324 000053E3 		cmp	r3, #0
 2313 0328 2C0000CA 		bgt	.L100
 546:main.c        ****       main_data.term_status |= term_string(
 2314              		.loc 1 546 32
 2315 032c 0010A0E3 		mov	r1, #0
 2316 0330 68039FE5 		ldr	r0, .L114+168
 2317 0334 EC329FE5 		ldr	r3, .L114+48
 2318 0338 0FE0A0E1 		mov	lr, pc
 2319 033c 13FF2FE1 		bx	r3
 2320              	.LVL76:
 2321 0340 0030A0E1 		mov	r3, r0
 2322              		.loc 1 546 16 discriminator 1
 2323 0344 58239FE5 		ldr	r2, .L114+172
 2324 0348 D020D2E1 		ldrsb	r2, [r2]
 2325              		.loc 1 546 29 discriminator 1
 2326 034c 033CA0E1 		lsl	r3, r3, #24
 2327 0350 433CA0E1 		asr	r3, r3, #24
 2328 0354 033082E1 		orr	r3, r2, r3
 2329 0358 033CA0E1 		lsl	r3, r3, #24
 2330 035c 432CA0E1 		asr	r2, r3, #24
 2331 0360 3C339FE5 		ldr	r3, .L114+172
 2332 0364 0020C3E5 		strb	r2, [r3]
 547:main.c        ****           VT100_VORDERGRUND_ROT "Timing durch '", ASYNCSYNC_NONBLOCK);
 548:main.c        ****       main_data.term_status |= term_string(task_aktiv, ASYNCSYNC_NONBLOCK);
 2333              		.loc 1 548 32
 2334 0368 0010A0E3 		mov	r1, #0
 2335 036c 10001BE5 		ldr	r0, [fp, #-16]
 2336 0370 B0329FE5 		ldr	r3, .L114+48
 2337 0374 0FE0A0E1 		mov	lr, pc
 2338 0378 13FF2FE1 		bx	r3
 2339              	.LVL77:
 2340 037c 0030A0E1 		mov	r3, r0
 2341              		.loc 1 548 16 discriminator 1
 2342 0380 1C239FE5 		ldr	r2, .L114+172
 2343 0384 D020D2E1 		ldrsb	r2, [r2]
 2344              		.loc 1 548 29 discriminator 1
 2345 0388 033CA0E1 		lsl	r3, r3, #24
 2346 038c 433CA0E1 		asr	r3, r3, #24
 2347 0390 033082E1 		orr	r3, r2, r3
 2348 0394 033CA0E1 		lsl	r3, r3, #24
 2349 0398 432CA0E1 		asr	r2, r3, #24
 2350 039c 00339FE5 		ldr	r3, .L114+172
 2351 03a0 0020C3E5 		strb	r2, [r3]
 549:main.c        ****       main_data.term_status |= term_string(
 2352              		.loc 1 549 32
 2353 03a4 0010A0E3 		mov	r1, #0
 2354 03a8 F8029FE5 		ldr	r0, .L114+176
 2355 03ac 74329FE5 		ldr	r3, .L114+48
 2356 03b0 0FE0A0E1 		mov	lr, pc
 2357 03b4 13FF2FE1 		bx	r3
 2358              	.LVL78:
 2359 03b8 0030A0E1 		mov	r3, r0
 2360              		.loc 1 549 16 discriminator 1
 2361 03bc E0229FE5 		ldr	r2, .L114+172
 2362 03c0 D020D2E1 		ldrsb	r2, [r2]
 2363              		.loc 1 549 29 discriminator 1
 2364 03c4 033CA0E1 		lsl	r3, r3, #24
 2365 03c8 433CA0E1 		asr	r3, r3, #24
 2366 03cc 033082E1 		orr	r3, r2, r3
 2367 03d0 033CA0E1 		lsl	r3, r3, #24
 2368 03d4 432CA0E1 		asr	r2, r3, #24
 2369 03d8 C4329FE5 		ldr	r3, .L114+172
 2370 03dc 0020C3E5 		strb	r2, [r3]
 2371              	.L100:
 550:main.c        ****           "' verletzt\n\r" VT100_VORDERGRUND_DEFAULT, ASYNCSYNC_NONBLOCK);
 551:main.c        ****     }
 552:main.c        ****     // Zeitscheibe erhöhen
 553:main.c        ****     zeitscheibe++;
 2372              		.loc 1 553 16
 2373 03e0 0C301BE5 		ldr	r3, [fp, #-12]
 2374 03e4 013083E2 		add	r3, r3, #1
 2375 03e8 0C300BE5 		str	r3, [fp, #-12]
 2376              	.LBB10:
 2377              	.LBB11:
 123:lib/../main.h **** 
 124:lib/../main.h **** static __inline__ int32_t stack_check(void) __attribute__((always_inline));
 125:lib/../main.h **** static __inline__ int32_t stack_check(void)
 126:lib/../main.h **** {
 127:lib/../main.h **** 	         uint32_t *ptr;
 128:lib/../main.h **** //	register uint32_t *sp asm("r13");
 129:lib/../main.h **** 	for(ptr=&__stack_start__[0];*ptr==STACK_FILL;++ptr);
 2378              		.loc 4 129 9
 2379 03ec 54329FE5 		ldr	r3, .L114+80
 2380 03f0 18300BE5 		str	r3, [fp, #-24]
 2381              		.loc 4 129 2
 2382 03f4 020000EA 		b	.L101
 2383              	.L102:
 2384              		.loc 4 129 47 discriminator 3
 2385 03f8 18301BE5 		ldr	r3, [fp, #-24]
 2386 03fc 043083E2 		add	r3, r3, #4
 2387 0400 18300BE5 		str	r3, [fp, #-24]
 2388              	.L101:
 2389              		.loc 4 129 30 discriminator 1
 2390 0404 18301BE5 		ldr	r3, [fp, #-24]
 2391 0408 003093E5 		ldr	r3, [r3]
 2392              		.loc 4 129 34 discriminator 1
 2393 040c 38229FE5 		ldr	r2, .L114+84
 2394 0410 020053E1 		cmp	r3, r2
 2395 0414 F7FFFF0A 		beq	.L102
 130:lib/../main.h **** 	return (int32_t)(ptr-&__stack_start__[0]);
 2396              		.loc 4 130 22
 2397 0418 18301BE5 		ldr	r3, [fp, #-24]
 2398 041c 24229FE5 		ldr	r2, .L114+80
 2399 0420 023043E0 		sub	r3, r3, r2
 2400              		.loc 4 130 9
 2401 0424 4331A0E1 		asr	r3, r3, #2
 2402              	.LBE11:
 2403              	.LBE10:
 554:main.c        **** 
 555:main.c        ****     // Stack Testen
 556:main.c        ****     if (stack_check() < (1 * 4)) {
 2404              		.loc 1 556 8 discriminator 1
 2405 0428 030053E3 		cmp	r3, #3
 2406 042c 350000CA 		bgt	.L104
 2407              	.LBB12:
 557:main.c        ****       static uint8_t stack_cnt = 0;
 558:main.c        ****       if (stack_cnt == 0) {
 2408              		.loc 1 558 21
 2409 0430 74329FE5 		ldr	r3, .L114+180
 2410 0434 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2411              		.loc 1 558 10
 2412 0438 000053E3 		cmp	r3, #0
 2413 043c 3100001A 		bne	.L104
 559:main.c        ****         stack_cnt = 1;
 2414              		.loc 1 559 19
 2415 0440 64329FE5 		ldr	r3, .L114+180
 2416 0444 0120A0E3 		mov	r2, #1
 2417 0448 0020C3E5 		strb	r2, [r3]
 560:main.c        ****         main_data.term_status |= term_string(
 2418              		.loc 1 560 34
 2419 044c 0010A0E3 		mov	r1, #0
 2420 0450 58029FE5 		ldr	r0, .L114+184
 2421 0454 CC319FE5 		ldr	r3, .L114+48
 2422 0458 0FE0A0E1 		mov	lr, pc
 2423 045c 13FF2FE1 		bx	r3
 2424              	.LVL79:
 2425 0460 0030A0E1 		mov	r3, r0
 2426              		.loc 1 560 18 discriminator 1
 2427 0464 38229FE5 		ldr	r2, .L114+172
 2428 0468 D020D2E1 		ldrsb	r2, [r2]
 2429              		.loc 1 560 31 discriminator 1
 2430 046c 033CA0E1 		lsl	r3, r3, #24
 2431 0470 433CA0E1 		asr	r3, r3, #24
 2432 0474 033082E1 		orr	r3, r2, r3
 2433 0478 033CA0E1 		lsl	r3, r3, #24
 2434 047c 432CA0E1 		asr	r2, r3, #24
 2435 0480 1C329FE5 		ldr	r3, .L114+172
 2436 0484 0020C3E5 		strb	r2, [r3]
 561:main.c        ****             VT100_VORDERGRUND_ROT "Stack overflow durch '", ASYNCSYNC_NONBLOCK);
 562:main.c        ****         main_data.term_status |= term_string(task_aktiv, ASYNCSYNC_NONBLOCK);
 2437              		.loc 1 562 34
 2438 0488 0010A0E3 		mov	r1, #0
 2439 048c 10001BE5 		ldr	r0, [fp, #-16]
 2440 0490 90319FE5 		ldr	r3, .L114+48
 2441 0494 0FE0A0E1 		mov	lr, pc
 2442 0498 13FF2FE1 		bx	r3
 2443              	.LVL80:
 2444 049c 0030A0E1 		mov	r3, r0
 2445              		.loc 1 562 18 discriminator 1
 2446 04a0 FC219FE5 		ldr	r2, .L114+172
 2447 04a4 D020D2E1 		ldrsb	r2, [r2]
 2448              		.loc 1 562 31 discriminator 1
 2449 04a8 033CA0E1 		lsl	r3, r3, #24
 2450 04ac 433CA0E1 		asr	r3, r3, #24
 2451 04b0 033082E1 		orr	r3, r2, r3
 2452 04b4 033CA0E1 		lsl	r3, r3, #24
 2453 04b8 432CA0E1 		asr	r2, r3, #24
 2454 04bc E0319FE5 		ldr	r3, .L114+172
 2455 04c0 0020C3E5 		strb	r2, [r3]
 563:main.c        ****         main_data.term_status |=
 564:main.c        ****             term_string("'\n\r" VT100_VORDERGRUND_DEFAULT, ASYNCSYNC_NONBLOCK);
 2456              		.loc 1 564 13
 2457 04c4 0010A0E3 		mov	r1, #0
 2458 04c8 E4019FE5 		ldr	r0, .L114+188
 2459 04cc 54319FE5 		ldr	r3, .L114+48
 2460 04d0 0FE0A0E1 		mov	lr, pc
 2461 04d4 13FF2FE1 		bx	r3
 2462              	.LVL81:
 2463 04d8 0030A0E1 		mov	r3, r0
 563:main.c        ****         main_data.term_status |=
 2464              		.loc 1 563 18
 2465 04dc C0219FE5 		ldr	r2, .L114+172
 2466 04e0 D020D2E1 		ldrsb	r2, [r2]
 563:main.c        ****         main_data.term_status |=
 2467              		.loc 1 563 31
 2468 04e4 033CA0E1 		lsl	r3, r3, #24
 2469 04e8 433CA0E1 		asr	r3, r3, #24
 2470 04ec 033082E1 		orr	r3, r2, r3
 2471 04f0 033CA0E1 		lsl	r3, r3, #24
 2472 04f4 432CA0E1 		asr	r2, r3, #24
 2473 04f8 A4319FE5 		ldr	r3, .L114+172
 2474 04fc 0020C3E5 		strb	r2, [r3]
 2475              	.L105:
 565:main.c        ****         while (1)
 2476              		.loc 1 565 15
 2477 0500 0000A0E1 		nop
 2478 0504 FDFFFFEA 		b	.L105
 2479              	.L104:
 2480              	.LBE12:
 566:main.c        ****           ;
 567:main.c        ****       }
 568:main.c        ****     }
 569:main.c        **** 
 570:main.c        ****     // Batteriespannung überprüfen
 571:main.c        ****     // Ggf. schlägt die Unterspannungsprüfung im Akku zuvor ein!
 572:main.c        ****     if (nxt_avr_get_battery_raw() < ((2 * 3000 /*mV*/) << 10) / 14180) {
 2481              		.loc 1 572 9
 2482 0508 A8319FE5 		ldr	r3, .L114+192
 2483 050c 0FE0A0E1 		mov	lr, pc
 2484 0510 13FF2FE1 		bx	r3
 2485              	.LVL82:
 2486 0514 0030A0E1 		mov	r3, r0
 2487              		.loc 1 572 8 discriminator 1
 2488 0518 1B0E53E3 		cmp	r3, #432
 2489 051c 1D00008A 		bhi	.L106
 573:main.c        ****       if (main_data.lowbat_cnt++ > 100)
 2490              		.loc 1 573 20
 2491 0520 7C319FE5 		ldr	r3, .L114+172
 2492 0524 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2493              		.loc 1 573 31
 2494 0528 012083E2 		add	r2, r3, #1
 2495 052c FF1002E2 		and	r1, r2, #255
 2496 0530 6C219FE5 		ldr	r2, .L114+172
 2497 0534 0210C2E5 		strb	r1, [r2, #2]
 2498              		.loc 1 573 10
 2499 0538 640053E3 		cmp	r3, #100
 2500 053c 0100009A 		bls	.L107
 2501              	.L108:
 574:main.c        ****         while (1)
 2502              		.loc 1 574 15
 2503 0540 0000A0E1 		nop
 2504 0544 FDFFFFEA 		b	.L108
 2505              	.L107:
 575:main.c        ****           ;
 576:main.c        ****       else if (main_data.lowbat_cnt == 10)
 2506              		.loc 1 576 25
 2507 0548 54319FE5 		ldr	r3, .L114+172
 2508 054c 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2509              		.loc 1 576 15
 2510 0550 0A0053E3 		cmp	r3, #10
 2511 0554 1200001A 		bne	.L109
 577:main.c        ****         main_data.term_status |=
 578:main.c        ****             term_string(VT100_VORDERGRUND_ROT
 2512              		.loc 1 578 13
 2513 0558 0010A0E3 		mov	r1, #0
 2514 055c 58019FE5 		ldr	r0, .L114+196
 2515 0560 C0309FE5 		ldr	r3, .L114+48
 2516 0564 0FE0A0E1 		mov	lr, pc
 2517 0568 13FF2FE1 		bx	r3
 2518              	.LVL83:
 2519 056c 0030A0E1 		mov	r3, r0
 577:main.c        ****         main_data.term_status |=
 2520              		.loc 1 577 18
 2521 0570 2C219FE5 		ldr	r2, .L114+172
 2522 0574 D020D2E1 		ldrsb	r2, [r2]
 577:main.c        ****         main_data.term_status |=
 2523              		.loc 1 577 31
 2524 0578 033CA0E1 		lsl	r3, r3, #24
 2525 057c 433CA0E1 		asr	r3, r3, #24
 2526 0580 033082E1 		orr	r3, r2, r3
 2527 0584 033CA0E1 		lsl	r3, r3, #24
 2528 0588 432CA0E1 		asr	r2, r3, #24
 2529 058c 10319FE5 		ldr	r3, .L114+172
 2530 0590 0020C3E5 		strb	r2, [r3]
 2531 0594 020000EA 		b	.L109
 2532              	.L106:
 579:main.c        ****                         "\n\rLow Battery\n\r" VT100_VORDERGRUND_DEFAULT,
 580:main.c        ****                         ASYNCSYNC_NONBLOCK);
 581:main.c        ****     } else {
 582:main.c        ****       main_data.lowbat_cnt = 0;
 2533              		.loc 1 582 28
 2534 0598 04319FE5 		ldr	r3, .L114+172
 2535 059c 0020A0E3 		mov	r2, #0
 2536 05a0 0220C3E5 		strb	r2, [r3, #2]
 2537              	.L109:
 583:main.c        ****     }
 584:main.c        **** 
 585:main.c        ****     // Termstatus ueberpruefen
 586:main.c        ****     if (main_data.term_cnt == 0 && main_data.term_status != 0) {
 2538              		.loc 1 586 18
 2539 05a4 F8309FE5 		ldr	r3, .L114+172
 2540 05a8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2541              		.loc 1 586 8
 2542 05ac 000053E3 		cmp	r3, #0
 2543 05b0 EDFEFF1A 		bne	.L113
 2544              		.loc 1 586 45 discriminator 1
 2545 05b4 E8309FE5 		ldr	r3, .L114+172
 2546 05b8 D030D3E1 		ldrsb	r3, [r3]
 2547              		.loc 1 586 33 discriminator 1
 2548 05bc 000053E3 		cmp	r3, #0
 2549 05c0 E9FEFF0A 		beq	.L113
 587:main.c        ****       main_data.term_cnt++;
 2550              		.loc 1 587 16
 2551 05c4 D8309FE5 		ldr	r3, .L114+172
 2552 05c8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2553              		.loc 1 587 25
 2554 05cc 013083E2 		add	r3, r3, #1
 2555 05d0 FF2003E2 		and	r2, r3, #255
 2556 05d4 C8309FE5 		ldr	r3, .L114+172
 2557 05d8 0120C3E5 		strb	r2, [r3, #1]
 2558              	.L111:
 588:main.c        ****     overflow:
 589:main.c        ****       __attribute__((unused));
 590:main.c        **** 
 591:main.c        ****       (void)term_string(VT100_VORDERGRUND_ROT
 2559              		.loc 1 591 13
 2560 05dc 0110A0E3 		mov	r1, #1
 2561 05e0 D8009FE5 		ldr	r0, .L114+200
 2562 05e4 3C309FE5 		ldr	r3, .L114+48
 2563 05e8 0FE0A0E1 		mov	lr, pc
 2564 05ec 13FF2FE1 		bx	r3
 2565              	.LVL84:
 2566              	.L112:
 592:main.c        ****                         "\n\rTerminal Overflow\n\r" VT100_VORDERGRUND_DEFAULT,
 593:main.c        ****                         ASYNCSYNC_BLOCK);
 594:main.c        ****       while (1)
 2567              		.loc 1 594 13
 2568 05f0 0000A0E1 		nop
 2569 05f4 FDFFFFEA 		b	.L112
 2570              	.L115:
 2571              		.align	2
 2572              	.L114:
 2573 05f8 00000000 		.word	aic_init
 2574 05fc 00000000 		.word	systick_init
 2575 0600 00000000 		.word	interrupts_enable
 2576 0604 00000000 		.word	nxt_avr_init
 2577 0608 00000000 		.word	udmon3_init
 2578 060c 00000000 		.word	term_init
 2579 0610 00000000 		.word	display_init
 2580 0614 00000000 		.word	display_clear
 2581 0618 4C000000 		.word	.LC9
 2582 061c 00000000 		.word	display_string
 2583 0620 00000000 		.word	display_update
 2584 0624 5C000000 		.word	.LC10
 2585 0628 00000000 		.word	term_string
 2586 062c 68000000 		.word	.LC11
 2587 0630 98000000 		.word	.LC12
 2588 0634 DC000000 		.word	.LC13
 2589 0638 10010000 		.word	.LC14
 2590 063c 3C010000 		.word	.LC15
 2591 0640 40FDFFFF 		.word	-704
 2592 0644 FF8F0030 		.word	805343231
 2593 0648 00000000 		.word	__stack_start__
 2594 064c 11111111 		.word	286331153
 2595 0650 00000000 		.word	systick_get_ms
 2596 0654 4C010000 		.word	.LC16
 2597 0658 50010000 		.word	.LC17
 2598 065c 00000000 		.word	task_8ms
 2599 0660 54010000 		.word	.LC18
 2600 0664 00000000 		.word	task_16ms
 2601 0668 5C010000 		.word	.LC19
 2602 066c 00000000 		.word	task_32ms
 2603 0670 64010000 		.word	.LC20
 2604 0674 00000000 		.word	task_64ms
 2605 0678 6C010000 		.word	.LC21
 2606 067c 00000000 		.word	task_128ms
 2607 0680 74010000 		.word	.LC22
 2608 0684 00000000 		.word	task_256ms
 2609 0688 7C010000 		.word	.LC23
 2610 068c 00000000 		.word	task_512ms
 2611 0690 84010000 		.word	.LC24
 2612 0694 00000000 		.word	task_1024ms
 2613 0698 8C010000 		.word	.LC25
 2614 069c 00000000 		.word	task_idle
 2615 06a0 94010000 		.word	.LC26
 2616 06a4 00000000 		.word	main_data
 2617 06a8 A8010000 		.word	.LC27
 2618 06ac 9A030000 		.word	stack_cnt.0
 2619 06b0 BC010000 		.word	.LC28
 2620 06b4 D8010000 		.word	.LC29
 2621 06b8 00000000 		.word	nxt_avr_get_battery_raw
 2622 06bc E4010000 		.word	.LC30
 2623 06c0 00020000 		.word	.LC31
 2624              		.cfi_endproc
 2625              	.LFE28:
 2627              		.bss
 2628              		.align	2
 2629              	trace_index.4:
 2630 0324 00000000 		.space	4
 2632              	strpos.3:
 2633 0328 00       		.space	1
 2635 0329 000000   		.align	2
 2636              	string.2:
 2637 032c 00000000 		.space	100
 2637      00000000 
 2637      00000000 
 2637      00000000 
 2637      00000000 
 2639              		.align	2
 2640              	linebuf.1:
 2641 0390 00000000 		.space	10
 2641      00000000 
 2641      0000
 2643              	stack_cnt.0:
 2644 039a 00       		.space	1
 2646              		.text
 2647              	.Letext0:
 2648              		.file 5 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/machi
 2649              		.file 6 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/_
 2650              		.file 7 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/lib/gcc/arm-none-eabi/14.3.
 2651              		.file 8 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/_
 2652              		.file 9 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/r
 2653              		.file 10 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/
 2654              		.file 11 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/stdi
 2655              		.file 12 "AT91SAM7S64.h"
 2656              		.file 13 "lib/display.h"
 2657              		.file 14 "lib/term.h"
 2658              		.file 15 "trace32/udmon3.h"
 2659              		.file 16 "lib/nxt_avr.h"
 2660              		.file 17 "lib/isr.h"
 2661              		.file 18 "lib/systick.h"
 2662              		.file 19 "lib/aic.h"
 2663              		.file 20 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cco2VSqV.s:19     .text.byte_fifo_put_possible:00000000 $a
     /tmp/cco2VSqV.s:23     .text.byte_fifo_put_possible:00000000 byte_fifo_put_possible
     /tmp/cco2VSqV.s:75     .text.byte_fifo_remain:00000000 $a
     /tmp/cco2VSqV.s:79     .text.byte_fifo_remain:00000000 byte_fifo_remain
     /tmp/cco2VSqV.s:133    .text.byte_fifo_used:00000000 $a
     /tmp/cco2VSqV.s:137    .text.byte_fifo_used:00000000 byte_fifo_used
     /tmp/cco2VSqV.s:188    .text.byte_fifo_put:00000000 $a
     /tmp/cco2VSqV.s:192    .text.byte_fifo_put:00000000 byte_fifo_put
     /tmp/cco2VSqV.s:277    .text.byte_fifo_get_possible:00000000 $a
     /tmp/cco2VSqV.s:281    .text.byte_fifo_get_possible:00000000 byte_fifo_get_possible
     /tmp/cco2VSqV.s:325    .text.byte_fifo_get:00000000 $a
     /tmp/cco2VSqV.s:329    .text.byte_fifo_get:00000000 byte_fifo_get
     /tmp/cco2VSqV.s:408    .text.byte_fifo_cb_put_possible:00000000 $a
     /tmp/cco2VSqV.s:412    .text.byte_fifo_cb_put_possible:00000000 byte_fifo_cb_put_possible
     /tmp/cco2VSqV.s:450    .text.byte_fifo_cb_put_possible:0000003c $d
     /tmp/cco2VSqV.s:455    .text.byte_fifo_cb_put:00000000 $a
     /tmp/cco2VSqV.s:459    .text.byte_fifo_cb_put:00000000 byte_fifo_cb_put
     /tmp/cco2VSqV.s:520    .text.byte_fifo_cb_put:0000007c $d
     /tmp/cco2VSqV.s:525    .text.byte_fifo_cb_get_possible:00000000 $a
     /tmp/cco2VSqV.s:529    .text.byte_fifo_cb_get_possible:00000000 byte_fifo_cb_get_possible
     /tmp/cco2VSqV.s:566    .text.byte_fifo_cb_get_possible:0000003c $d
     /tmp/cco2VSqV.s:571    .text.byte_fifo_cb_get:00000000 $a
     /tmp/cco2VSqV.s:575    .text.byte_fifo_cb_get:00000000 byte_fifo_cb_get
     /tmp/cco2VSqV.s:614    .text.byte_fifo_cb_get:00000044 $d
     /tmp/cco2VSqV.s:623    .bss:00000000 main_data
     /tmp/cco2VSqV.s:620    .bss:00000000 $d
     /tmp/cco2VSqV.s:626    .text._exit:00000000 $a
     /tmp/cco2VSqV.s:631    .text._exit:00000000 _exit
     /tmp/cco2VSqV.s:658    .bss:00000004 trace_buf0
     /tmp/cco2VSqV.s:664    .bss:00000194 trace_buf1
     /tmp/cco2VSqV.s:667    .text.trace_scope:00000000 $a
     /tmp/cco2VSqV.s:672    .text.trace_scope:00000000 trace_scope
     /tmp/cco2VSqV.s:760    .text.trace_scope:000000c8 $d
     /tmp/cco2VSqV.s:2629   .bss:00000324 trace_index.4
     /tmp/cco2VSqV.s:771    .data:00000000 h
     /tmp/cco2VSqV.s:768    .data:00000000 $d
     /tmp/cco2VSqV.s:784    .rodata:00000000 $d
     /tmp/cco2VSqV.s:788    .text.herzschlag_process:00000000 $a
     /tmp/cco2VSqV.s:793    .text.herzschlag_process:00000000 herzschlag_process
     /tmp/cco2VSqV.s:1106   .text.herzschlag_process:00000324 $d
     /tmp/cco2VSqV.s:1123   .text.task_8ms:00000000 $a
     /tmp/cco2VSqV.s:1128   .text.task_8ms:00000000 task_8ms
     /tmp/cco2VSqV.s:1167   .text.task_8ms:0000003c $d
     /tmp/cco2VSqV.s:1173   .text.task_16ms:00000000 $a
     /tmp/cco2VSqV.s:1178   .text.task_16ms:00000000 task_16ms
     /tmp/cco2VSqV.s:1204   .text.task_32ms:00000000 $a
     /tmp/cco2VSqV.s:1209   .text.task_32ms:00000000 task_32ms
     /tmp/cco2VSqV.s:1235   .text.task_64ms:00000000 $a
     /tmp/cco2VSqV.s:1240   .text.task_64ms:00000000 task_64ms
     /tmp/cco2VSqV.s:1266   .text.task_128ms:00000000 $a
     /tmp/cco2VSqV.s:1271   .text.task_128ms:00000000 task_128ms
     /tmp/cco2VSqV.s:1316   .text.task_256ms:00000000 $a
     /tmp/cco2VSqV.s:1321   .text.task_256ms:00000000 task_256ms
     /tmp/cco2VSqV.s:1553   .text.task_256ms:0000023c $d
     /tmp/cco2VSqV.s:1574   .text.task_512ms:00000000 $a
     /tmp/cco2VSqV.s:1579   .text.task_512ms:00000000 task_512ms
     /tmp/cco2VSqV.s:1605   .text.task_1024ms:00000000 $a
     /tmp/cco2VSqV.s:1610   .text.task_1024ms:00000000 task_1024ms
     /tmp/cco2VSqV.s:1643   .text.task_idle:00000000 $a
     /tmp/cco2VSqV.s:1648   .text.task_idle:00000000 task_idle
     /tmp/cco2VSqV.s:1832   .text.task_idle:000001fc $d
     /tmp/cco2VSqV.s:2632   .bss:00000328 strpos.3
     /tmp/cco2VSqV.s:2636   .bss:0000032c string.2
     /tmp/cco2VSqV.s:1844   .text.premain_init:00000000 $a
     /tmp/cco2VSqV.s:1849   .text.premain_init:00000000 premain_init
     /tmp/cco2VSqV.s:1891   .text.premain_init:0000003c $d
     /tmp/cco2VSqV.s:2640   .bss:00000390 linebuf.1
     /tmp/cco2VSqV.s:1898   .init_array:00000000 $d
     /tmp/cco2VSqV.s:1974   .text.main:00000000 $a
     /tmp/cco2VSqV.s:1979   .text.main:00000000 main
     /tmp/cco2VSqV.s:2573   .text.main:000005f8 $d
     /tmp/cco2VSqV.s:2643   .bss:0000039a stack_cnt.0

UNDEFINED SYMBOLS
systick_get_ms
__aeabi_ui2f
__aeabi_fdiv
__aeabi_fmul
__aeabi_fadd
__aeabi_f2iz
printf
nxt_avr_get_sensor_adc_raw
display_string
display_hex
display_goto_xy
nxt_avr_get_battery_mv
display_unsigned
nxt_avr_get_buttons
display_char
display_update
term_read
term_char
term_string
_impure_ptr
setvbuf
aic_init
systick_init
interrupts_enable
nxt_avr_init
udmon3_init
term_init
display_init
display_clear
__stack_start__
nxt_avr_get_battery_raw
