   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"udmon3.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "./trace32/udmon3.c"
  18              		.section	.text.byte_fifo_put_possible,"ax",%progbits
  19              		.align	2
  20              		.syntax unified
  21              		.arm
  23              	byte_fifo_put_possible:
  24              	.LFB0:
  25              		.file 2 "./trace32/../lib/byte_fifo.h"
   1:./trace32/../lib/byte_fifo.h **** /* Byte FIFO queue implementation.
   2:./trace32/../lib/byte_fifo.h ****  *
   3:./trace32/../lib/byte_fifo.h ****  * Implements a simple reader/write save byte FIFO on top of a data buffer, that lets
   4:./trace32/../lib/byte_fifo.h ****  * you enqueue and dequeue single bytes.
   5:./trace32/../lib/byte_fifo.h ****  */
   6:./trace32/../lib/byte_fifo.h **** 
   7:./trace32/../lib/byte_fifo.h **** #ifndef __BYTE_FIFO_H__
   8:./trace32/../lib/byte_fifo.h **** #define __BYTE_FIFO_H__
   9:./trace32/../lib/byte_fifo.h **** 
  10:./trace32/../lib/byte_fifo.h **** 
  11:./trace32/../lib/byte_fifo.h **** typedef struct
  12:./trace32/../lib/byte_fifo.h **** {
  13:./trace32/../lib/byte_fifo.h **** 	unsigned short rd;
  14:./trace32/../lib/byte_fifo.h **** 	unsigned short wr;
  15:./trace32/../lib/byte_fifo.h ****     unsigned short mask;
  16:./trace32/../lib/byte_fifo.h **** 	unsigned char  buf[];
  17:./trace32/../lib/byte_fifo.h **** } byte_fifo_t;
  18:./trace32/../lib/byte_fifo.h **** 
  19:./trace32/../lib/byte_fifo.h **** #define TEST_2erPOTENZ(x) (((x) & ((x) - 1))?0:(x))
  20:./trace32/../lib/byte_fifo.h **** #define TEST_64k(x)       ((x)>0x10000?0:(x))
  21:./trace32/../lib/byte_fifo.h **** #define TEST_SIZE(x)      (TEST_64k(TEST_2erPOTENZ(x)))
  22:./trace32/../lib/byte_fifo.h **** 
  23:./trace32/../lib/byte_fifo.h **** //size muss einer 2er Potenzzahl sein, andernfalls gibt der Compiler
  24:./trace32/../lib/byte_fifo.h **** //die Fehlermeldung aus, dass die Array-GrÃ¶ÃŸe (hier -1) ungÃ¼ltit ist
  25:./trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_INIT(size)  (byte_fifo_t) {.rd=0,\
  26:./trace32/../lib/byte_fifo.h ****                                              .wr=0,\
  27:./trace32/../lib/byte_fifo.h **** 						        	         .mask=TEST_SIZE(size)-1,\
  28:./trace32/../lib/byte_fifo.h **** 								    		 .buf={[TEST_SIZE(size)-1]=0}\
  29:./trace32/../lib/byte_fifo.h **** 									    	}
  30:./trace32/../lib/byte_fifo.h **** 
  31:./trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_TYPEOF_RDWR typeof (((byte_fifo_t *)0)->rd)
  32:./trace32/../lib/byte_fifo.h **** 
  33:./trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic push
  34:./trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  35:./trace32/../lib/byte_fifo.h **** 
  36:./trace32/../lib/byte_fifo.h **** static int byte_fifo_put_possible(byte_fifo_t *fifo)
  37:./trace32/../lib/byte_fifo.h **** {
  26              		.loc 2 37 1
  27              		.cfi_startproc
  28              		@ Function supports interworking.
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 04B02DE5 		str	fp, [sp, #-4]!
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 11, -4
  35 0004 00B08DE2 		add	fp, sp, #0
  36              		.cfi_def_cfa_register 11
  37 0008 0CD04DE2 		sub	sp, sp, #12
  38 000c 08000BE5 		str	r0, [fp, #-8]
  38:./trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
  39              		.loc 2 38 11
  40 0010 08301BE5 		ldr	r3, [fp, #-8]
  41 0014 B230D3E1 		ldrh	r3, [r3, #2]
  42              		.loc 2 38 15
  43 0018 013083E2 		add	r3, r3, #1
  44              		.loc 2 38 24
  45 001c 08201BE5 		ldr	r2, [fp, #-8]
  46 0020 B420D2E1 		ldrh	r2, [r2, #4]
  47              		.loc 2 38 18
  48 0024 023003E0 		and	r3, r3, r2
  49              		.loc 2 38 40
  50 0028 08201BE5 		ldr	r2, [fp, #-8]
  51 002c B020D2E1 		ldrh	r2, [r2]
  52              		.loc 2 38 4
  53 0030 020053E1 		cmp	r3, r2
  54 0034 0100001A 		bne	.L2
  39:./trace32/../lib/byte_fifo.h **** 		return -1;
  55              		.loc 2 39 10
  56 0038 0030E0E3 		mvn	r3, #0
  57 003c 000000EA 		b	.L3
  58              	.L2:
  40:./trace32/../lib/byte_fifo.h **** 	
  41:./trace32/../lib/byte_fifo.h **** 	return 0;
  59              		.loc 2 41 9
  60 0040 0030A0E3 		mov	r3, #0
  61              	.L3:
  42:./trace32/../lib/byte_fifo.h **** }
  62              		.loc 2 42 1
  63 0044 0300A0E1 		mov	r0, r3
  64 0048 00D08BE2 		add	sp, fp, #0
  65              		.cfi_def_cfa_register 13
  66              		@ sp needed
  67 004c 04B09DE4 		ldr	fp, [sp], #4
  68              		.cfi_restore 11
  69              		.cfi_def_cfa_offset 0
  70 0050 1EFF2FE1 		bx	lr
  71              		.cfi_endproc
  72              	.LFE0:
  74              		.section	.text.byte_fifo_remain,"ax",%progbits
  75              		.align	2
  76              		.syntax unified
  77              		.arm
  79              	byte_fifo_remain:
  80              	.LFB1:
  43:./trace32/../lib/byte_fifo.h **** 
  44:./trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_remain(byte_fifo_t *fifo)
  45:./trace32/../lib/byte_fifo.h **** {
  81              		.loc 2 45 1
  82              		.cfi_startproc
  83              		@ Function supports interworking.
  84              		@ args = 0, pretend = 0, frame = 8
  85              		@ frame_needed = 1, uses_anonymous_args = 0
  86              		@ link register save eliminated.
  87 0000 04B02DE5 		str	fp, [sp, #-4]!
  88              		.cfi_def_cfa_offset 4
  89              		.cfi_offset 11, -4
  90 0004 00B08DE2 		add	fp, sp, #0
  91              		.cfi_def_cfa_register 11
  92 0008 0CD04DE2 		sub	sp, sp, #12
  93 000c 08000BE5 		str	r0, [fp, #-8]
  46:./trace32/../lib/byte_fifo.h **** 	return fifo->mask - ((fifo->wr-fifo->rd)&fifo->mask);
  94              		.loc 2 46 37
  95 0010 08301BE5 		ldr	r3, [fp, #-8]
  96 0014 B020D3E1 		ldrh	r2, [r3]
  97              		.loc 2 46 28
  98 0018 08301BE5 		ldr	r3, [fp, #-8]
  99 001c B230D3E1 		ldrh	r3, [r3, #2]
 100              		.loc 2 46 20
 101 0020 033042E0 		sub	r3, r2, r3
 102 0024 0338A0E1 		lsl	r3, r3, #16
 103 0028 2338A0E1 		lsr	r3, r3, #16
 104 002c 013043E2 		sub	r3, r3, #1
 105 0030 0338A0E1 		lsl	r3, r3, #16
 106 0034 2338A0E1 		lsr	r3, r3, #16
 107 0038 0338A0E1 		lsl	r3, r3, #16
 108 003c 4328A0E1 		asr	r2, r3, #16
 109              		.loc 2 46 47
 110 0040 08301BE5 		ldr	r3, [fp, #-8]
 111 0044 B430D3E1 		ldrh	r3, [r3, #4]
 112 0048 0338A0E1 		lsl	r3, r3, #16
 113 004c 4338A0E1 		asr	r3, r3, #16
 114              		.loc 2 46 20
 115 0050 023003E0 		and	r3, r3, r2
 116 0054 0338A0E1 		lsl	r3, r3, #16
 117 0058 4338A0E1 		asr	r3, r3, #16
 118 005c 0338A0E1 		lsl	r3, r3, #16
 119 0060 2338A0E1 		lsr	r3, r3, #16
  47:./trace32/../lib/byte_fifo.h **** }
 120              		.loc 2 47 1
 121 0064 0300A0E1 		mov	r0, r3
 122 0068 00D08BE2 		add	sp, fp, #0
 123              		.cfi_def_cfa_register 13
 124              		@ sp needed
 125 006c 04B09DE4 		ldr	fp, [sp], #4
 126              		.cfi_restore 11
 127              		.cfi_def_cfa_offset 0
 128 0070 1EFF2FE1 		bx	lr
 129              		.cfi_endproc
 130              	.LFE1:
 132              		.section	.text.byte_fifo_used,"ax",%progbits
 133              		.align	2
 134              		.syntax unified
 135              		.arm
 137              	byte_fifo_used:
 138              	.LFB2:
  48:./trace32/../lib/byte_fifo.h **** 	
  49:./trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_used(byte_fifo_t *fifo)
  50:./trace32/../lib/byte_fifo.h **** {
 139              		.loc 2 50 1
 140              		.cfi_startproc
 141              		@ Function supports interworking.
 142              		@ args = 0, pretend = 0, frame = 8
 143              		@ frame_needed = 1, uses_anonymous_args = 0
 144              		@ link register save eliminated.
 145 0000 04B02DE5 		str	fp, [sp, #-4]!
 146              		.cfi_def_cfa_offset 4
 147              		.cfi_offset 11, -4
 148 0004 00B08DE2 		add	fp, sp, #0
 149              		.cfi_def_cfa_register 11
 150 0008 0CD04DE2 		sub	sp, sp, #12
 151 000c 08000BE5 		str	r0, [fp, #-8]
  51:./trace32/../lib/byte_fifo.h **** 	return (fifo->wr-fifo->rd)&fifo->mask;
 152              		.loc 2 51 14
 153 0010 08301BE5 		ldr	r3, [fp, #-8]
 154 0014 B220D3E1 		ldrh	r2, [r3, #2]
 155              		.loc 2 51 23
 156 0018 08301BE5 		ldr	r3, [fp, #-8]
 157 001c B030D3E1 		ldrh	r3, [r3]
 158              		.loc 2 51 18
 159 0020 033042E0 		sub	r3, r2, r3
 160 0024 0338A0E1 		lsl	r3, r3, #16
 161 0028 2338A0E1 		lsr	r3, r3, #16
 162 002c 0338A0E1 		lsl	r3, r3, #16
 163 0030 4328A0E1 		asr	r2, r3, #16
 164              		.loc 2 51 33
 165 0034 08301BE5 		ldr	r3, [fp, #-8]
 166 0038 B430D3E1 		ldrh	r3, [r3, #4]
 167 003c 0338A0E1 		lsl	r3, r3, #16
 168 0040 4338A0E1 		asr	r3, r3, #16
 169              		.loc 2 51 28
 170 0044 023003E0 		and	r3, r3, r2
 171 0048 0338A0E1 		lsl	r3, r3, #16
 172 004c 4338A0E1 		asr	r3, r3, #16
 173 0050 0338A0E1 		lsl	r3, r3, #16
 174 0054 2338A0E1 		lsr	r3, r3, #16
  52:./trace32/../lib/byte_fifo.h **** }
 175              		.loc 2 52 1
 176 0058 0300A0E1 		mov	r0, r3
 177 005c 00D08BE2 		add	sp, fp, #0
 178              		.cfi_def_cfa_register 13
 179              		@ sp needed
 180 0060 04B09DE4 		ldr	fp, [sp], #4
 181              		.cfi_restore 11
 182              		.cfi_def_cfa_offset 0
 183 0064 1EFF2FE1 		bx	lr
 184              		.cfi_endproc
 185              	.LFE2:
 187              		.section	.text.byte_fifo_put,"ax",%progbits
 188              		.align	2
 189              		.syntax unified
 190              		.arm
 192              	byte_fifo_put:
 193              	.LFB3:
  53:./trace32/../lib/byte_fifo.h **** 	
  54:./trace32/../lib/byte_fifo.h **** static int byte_fifo_put(byte_fifo_t *fifo,unsigned char val)
  55:./trace32/../lib/byte_fifo.h **** {
 194              		.loc 2 55 1
 195              		.cfi_startproc
 196              		@ Function supports interworking.
 197              		@ args = 0, pretend = 0, frame = 8
 198              		@ frame_needed = 1, uses_anonymous_args = 0
 199              		@ link register save eliminated.
 200 0000 04B02DE5 		str	fp, [sp, #-4]!
 201              		.cfi_def_cfa_offset 4
 202              		.cfi_offset 11, -4
 203 0004 00B08DE2 		add	fp, sp, #0
 204              		.cfi_def_cfa_register 11
 205 0008 0CD04DE2 		sub	sp, sp, #12
 206 000c 08000BE5 		str	r0, [fp, #-8]
 207 0010 0130A0E1 		mov	r3, r1
 208 0014 09304BE5 		strb	r3, [fp, #-9]
  56:./trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
 209              		.loc 2 56 11
 210 0018 08301BE5 		ldr	r3, [fp, #-8]
 211 001c B230D3E1 		ldrh	r3, [r3, #2]
 212              		.loc 2 56 15
 213 0020 013083E2 		add	r3, r3, #1
 214              		.loc 2 56 24
 215 0024 08201BE5 		ldr	r2, [fp, #-8]
 216 0028 B420D2E1 		ldrh	r2, [r2, #4]
 217              		.loc 2 56 18
 218 002c 023003E0 		and	r3, r3, r2
 219              		.loc 2 56 40
 220 0030 08201BE5 		ldr	r2, [fp, #-8]
 221 0034 B020D2E1 		ldrh	r2, [r2]
 222              		.loc 2 56 4
 223 0038 020053E1 		cmp	r3, r2
 224 003c 0100001A 		bne	.L9
  57:./trace32/../lib/byte_fifo.h **** 		return -1;
 225              		.loc 2 57 10
 226 0040 0030E0E3 		mvn	r3, #0
 227 0044 190000EA 		b	.L10
 228              	.L9:
  58:./trace32/../lib/byte_fifo.h **** 	
  59:./trace32/../lib/byte_fifo.h **** 	fifo->buf[fifo->wr]=val;
 229              		.loc 2 59 16
 230 0048 08301BE5 		ldr	r3, [fp, #-8]
 231 004c B230D3E1 		ldrh	r3, [r3, #2]
 232 0050 0320A0E1 		mov	r2, r3
 233              		.loc 2 59 21
 234 0054 08301BE5 		ldr	r3, [fp, #-8]
 235 0058 023083E0 		add	r3, r3, r2
 236 005c 09205BE5 		ldrb	r2, [fp, #-9]
 237 0060 0620C3E5 		strb	r2, [r3, #6]
  60:./trace32/../lib/byte_fifo.h **** 	fifo->wr=(fifo->wr+1)&(fifo->mask);
 238              		.loc 2 60 16
 239 0064 08301BE5 		ldr	r3, [fp, #-8]
 240 0068 B230D3E1 		ldrh	r3, [r3, #2]
 241              		.loc 2 60 20
 242 006c 013083E2 		add	r3, r3, #1
 243 0070 0338A0E1 		lsl	r3, r3, #16
 244 0074 2338A0E1 		lsr	r3, r3, #16
 245 0078 0338A0E1 		lsl	r3, r3, #16
 246 007c 4328A0E1 		asr	r2, r3, #16
 247              		.loc 2 60 29
 248 0080 08301BE5 		ldr	r3, [fp, #-8]
 249 0084 B430D3E1 		ldrh	r3, [r3, #4]
 250 0088 0338A0E1 		lsl	r3, r3, #16
 251 008c 4338A0E1 		asr	r3, r3, #16
 252              		.loc 2 60 23
 253 0090 023003E0 		and	r3, r3, r2
 254 0094 0338A0E1 		lsl	r3, r3, #16
 255 0098 4338A0E1 		asr	r3, r3, #16
 256 009c 0338A0E1 		lsl	r3, r3, #16
 257 00a0 2328A0E1 		lsr	r2, r3, #16
 258              		.loc 2 60 10
 259 00a4 08301BE5 		ldr	r3, [fp, #-8]
 260 00a8 B220C3E1 		strh	r2, [r3, #2]	@ movhi
  61:./trace32/../lib/byte_fifo.h **** 	return 0;
 261              		.loc 2 61 9
 262 00ac 0030A0E3 		mov	r3, #0
 263              	.L10:
  62:./trace32/../lib/byte_fifo.h **** }
 264              		.loc 2 62 1
 265 00b0 0300A0E1 		mov	r0, r3
 266 00b4 00D08BE2 		add	sp, fp, #0
 267              		.cfi_def_cfa_register 13
 268              		@ sp needed
 269 00b8 04B09DE4 		ldr	fp, [sp], #4
 270              		.cfi_restore 11
 271              		.cfi_def_cfa_offset 0
 272 00bc 1EFF2FE1 		bx	lr
 273              		.cfi_endproc
 274              	.LFE3:
 276              		.section	.text.byte_fifo_get_possible,"ax",%progbits
 277              		.align	2
 278              		.syntax unified
 279              		.arm
 281              	byte_fifo_get_possible:
 282              	.LFB4:
  63:./trace32/../lib/byte_fifo.h **** 
  64:./trace32/../lib/byte_fifo.h **** static int byte_fifo_get_possible(byte_fifo_t *fifo)
  65:./trace32/../lib/byte_fifo.h **** {
 283              		.loc 2 65 1
 284              		.cfi_startproc
 285              		@ Function supports interworking.
 286              		@ args = 0, pretend = 0, frame = 8
 287              		@ frame_needed = 1, uses_anonymous_args = 0
 288              		@ link register save eliminated.
 289 0000 04B02DE5 		str	fp, [sp, #-4]!
 290              		.cfi_def_cfa_offset 4
 291              		.cfi_offset 11, -4
 292 0004 00B08DE2 		add	fp, sp, #0
 293              		.cfi_def_cfa_register 11
 294 0008 0CD04DE2 		sub	sp, sp, #12
 295 000c 08000BE5 		str	r0, [fp, #-8]
  66:./trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 296              		.loc 2 66 9
 297 0010 08301BE5 		ldr	r3, [fp, #-8]
 298 0014 B020D3E1 		ldrh	r2, [r3]
 299              		.loc 2 66 21
 300 0018 08301BE5 		ldr	r3, [fp, #-8]
 301 001c B230D3E1 		ldrh	r3, [r3, #2]
 302              		.loc 2 66 4
 303 0020 030052E1 		cmp	r2, r3
 304 0024 0100001A 		bne	.L12
  67:./trace32/../lib/byte_fifo.h **** 		return -1;
 305              		.loc 2 67 10
 306 0028 0030E0E3 		mvn	r3, #0
 307 002c 000000EA 		b	.L13
 308              	.L12:
  68:./trace32/../lib/byte_fifo.h **** 		
  69:./trace32/../lib/byte_fifo.h **** 	return 0;
 309              		.loc 2 69 9
 310 0030 0030A0E3 		mov	r3, #0
 311              	.L13:
  70:./trace32/../lib/byte_fifo.h **** }
 312              		.loc 2 70 1
 313 0034 0300A0E1 		mov	r0, r3
 314 0038 00D08BE2 		add	sp, fp, #0
 315              		.cfi_def_cfa_register 13
 316              		@ sp needed
 317 003c 04B09DE4 		ldr	fp, [sp], #4
 318              		.cfi_restore 11
 319              		.cfi_def_cfa_offset 0
 320 0040 1EFF2FE1 		bx	lr
 321              		.cfi_endproc
 322              	.LFE4:
 324              		.section	.text.byte_fifo_get,"ax",%progbits
 325              		.align	2
 326              		.syntax unified
 327              		.arm
 329              	byte_fifo_get:
 330              	.LFB5:
  71:./trace32/../lib/byte_fifo.h **** 
  72:./trace32/../lib/byte_fifo.h **** static int byte_fifo_get(byte_fifo_t *fifo,unsigned char *val)
  73:./trace32/../lib/byte_fifo.h **** {
 331              		.loc 2 73 1
 332              		.cfi_startproc
 333              		@ Function supports interworking.
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 1, uses_anonymous_args = 0
 336              		@ link register save eliminated.
 337 0000 04B02DE5 		str	fp, [sp, #-4]!
 338              		.cfi_def_cfa_offset 4
 339              		.cfi_offset 11, -4
 340 0004 00B08DE2 		add	fp, sp, #0
 341              		.cfi_def_cfa_register 11
 342 0008 0CD04DE2 		sub	sp, sp, #12
 343 000c 08000BE5 		str	r0, [fp, #-8]
 344 0010 0C100BE5 		str	r1, [fp, #-12]
  74:./trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 345              		.loc 2 74 9
 346 0014 08301BE5 		ldr	r3, [fp, #-8]
 347 0018 B020D3E1 		ldrh	r2, [r3]
 348              		.loc 2 74 21
 349 001c 08301BE5 		ldr	r3, [fp, #-8]
 350 0020 B230D3E1 		ldrh	r3, [r3, #2]
 351              		.loc 2 74 4
 352 0024 030052E1 		cmp	r2, r3
 353 0028 0100001A 		bne	.L15
  75:./trace32/../lib/byte_fifo.h **** 		return -1;
 354              		.loc 2 75 10
 355 002c 0030E0E3 		mvn	r3, #0
 356 0030 1A0000EA 		b	.L16
 357              	.L15:
  76:./trace32/../lib/byte_fifo.h **** 		
  77:./trace32/../lib/byte_fifo.h **** 	*val=fifo->buf[fifo->rd];
 358              		.loc 2 77 21
 359 0034 08301BE5 		ldr	r3, [fp, #-8]
 360 0038 B030D3E1 		ldrh	r3, [r3]
 361 003c 0320A0E1 		mov	r2, r3
 362              		.loc 2 77 16
 363 0040 08301BE5 		ldr	r3, [fp, #-8]
 364 0044 023083E0 		add	r3, r3, r2
 365 0048 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 366              		.loc 2 77 6
 367 004c 0C301BE5 		ldr	r3, [fp, #-12]
 368 0050 0020C3E5 		strb	r2, [r3]
  78:./trace32/../lib/byte_fifo.h **** 	fifo->rd=(fifo->rd+1)&(fifo->mask);
 369              		.loc 2 78 16
 370 0054 08301BE5 		ldr	r3, [fp, #-8]
 371 0058 B030D3E1 		ldrh	r3, [r3]
 372              		.loc 2 78 20
 373 005c 013083E2 		add	r3, r3, #1
 374 0060 0338A0E1 		lsl	r3, r3, #16
 375 0064 2338A0E1 		lsr	r3, r3, #16
 376 0068 0338A0E1 		lsl	r3, r3, #16
 377 006c 4328A0E1 		asr	r2, r3, #16
 378              		.loc 2 78 29
 379 0070 08301BE5 		ldr	r3, [fp, #-8]
 380 0074 B430D3E1 		ldrh	r3, [r3, #4]
 381 0078 0338A0E1 		lsl	r3, r3, #16
 382 007c 4338A0E1 		asr	r3, r3, #16
 383              		.loc 2 78 23
 384 0080 023003E0 		and	r3, r3, r2
 385 0084 0338A0E1 		lsl	r3, r3, #16
 386 0088 4338A0E1 		asr	r3, r3, #16
 387 008c 0338A0E1 		lsl	r3, r3, #16
 388 0090 2328A0E1 		lsr	r2, r3, #16
 389              		.loc 2 78 10
 390 0094 08301BE5 		ldr	r3, [fp, #-8]
 391 0098 B020C3E1 		strh	r2, [r3]	@ movhi
  79:./trace32/../lib/byte_fifo.h **** 	return 0;
 392              		.loc 2 79 9
 393 009c 0030A0E3 		mov	r3, #0
 394              	.L16:
  80:./trace32/../lib/byte_fifo.h **** }
 395              		.loc 2 80 1
 396 00a0 0300A0E1 		mov	r0, r3
 397 00a4 00D08BE2 		add	sp, fp, #0
 398              		.cfi_def_cfa_register 13
 399              		@ sp needed
 400 00a8 04B09DE4 		ldr	fp, [sp], #4
 401              		.cfi_restore 11
 402              		.cfi_def_cfa_offset 0
 403 00ac 1EFF2FE1 		bx	lr
 404              		.cfi_endproc
 405              	.LFE5:
 407              		.section	.text.byte_fifo_cb_put_possible,"ax",%progbits
 408              		.align	2
 409              		.syntax unified
 410              		.arm
 412              	byte_fifo_cb_put_possible:
 413              	.LFB6:
 414              		.file 3 "./trace32/../lib/byte_fifo_cb.h"
   1:./trace32/../lib/byte_fifo_cb.h **** /* Byte FIFO with CallBack
   2:./trace32/../lib/byte_fifo_cb.h ****  *
   3:./trace32/../lib/byte_fifo_cb.h ****  * Appends the Byte_Fifo with a callback function, which is called
   4:./trace32/../lib/byte_fifo_cb.h ****  * when putting some stuff into the fifo (e.g. Enable transmitting interrupt)
   5:./trace32/../lib/byte_fifo_cb.h ****  */
   6:./trace32/../lib/byte_fifo_cb.h **** 
   7:./trace32/../lib/byte_fifo_cb.h **** #ifndef __BYTE_FIFO_CB_H__
   8:./trace32/../lib/byte_fifo_cb.h **** #define __BYTE_FIFO_CB_H__
   9:./trace32/../lib/byte_fifo_cb.h **** 
  10:./trace32/../lib/byte_fifo_cb.h **** #include "byte_fifo.h"
  11:./trace32/../lib/byte_fifo_cb.h **** 
  12:./trace32/../lib/byte_fifo_cb.h **** typedef void (*byte_fifo_cb)(void);
  13:./trace32/../lib/byte_fifo_cb.h **** 
  14:./trace32/../lib/byte_fifo_cb.h **** typedef struct {
  15:./trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_cb cb;
  16:./trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_t  byte_fifo; //Aufgrund des Flexible Array Member hier hinter keine weiteren Strukturel
  17:./trace32/../lib/byte_fifo_cb.h **** } byte_fifo_cb_t;
  18:./trace32/../lib/byte_fifo_cb.h **** 
  19:./trace32/../lib/byte_fifo_cb.h **** #define BYTE_FIFO_CB_INIT(size,func)  (byte_fifo_cb_t) {.cb=func, \
  20:./trace32/../lib/byte_fifo_cb.h ****                                                         .byte_fifo=BYTE_FIFO_INIT(size) \
  21:./trace32/../lib/byte_fifo_cb.h **** 									    			   }
  22:./trace32/../lib/byte_fifo_cb.h **** 
  23:./trace32/../lib/byte_fifo_cb.h **** size_t byte_fifo_cb_putsize(byte_fifo_cb_t *fifo,const unsigned char *start,size_t len);
  24:./trace32/../lib/byte_fifo_cb.h **** 
  25:./trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic push
  26:./trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  27:./trace32/../lib/byte_fifo_cb.h **** 
  28:./trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put_possible(byte_fifo_cb_t *fifo)
  29:./trace32/../lib/byte_fifo_cb.h **** {
 415              		.loc 3 29 1
 416              		.cfi_startproc
 417              		@ Function supports interworking.
 418              		@ args = 0, pretend = 0, frame = 8
 419              		@ frame_needed = 1, uses_anonymous_args = 0
 420 0000 00482DE9 		push	{fp, lr}
 421              		.cfi_def_cfa_offset 8
 422              		.cfi_offset 11, -8
 423              		.cfi_offset 14, -4
 424 0004 04B08DE2 		add	fp, sp, #4
 425              		.cfi_def_cfa 11, 4
 426 0008 08D04DE2 		sub	sp, sp, #8
 427 000c 08000BE5 		str	r0, [fp, #-8]
  30:./trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_put_possible(&fifo->byte_fifo);
 428              		.loc 3 30 9
 429 0010 08301BE5 		ldr	r3, [fp, #-8]
 430 0014 043083E2 		add	r3, r3, #4
 431 0018 0300A0E1 		mov	r0, r3
 432 001c 18309FE5 		ldr	r3, .L19
 433 0020 0FE0A0E1 		mov	lr, pc
 434 0024 13FF2FE1 		bx	r3
 435              	.LVL0:
 436 0028 0030A0E1 		mov	r3, r0
  31:./trace32/../lib/byte_fifo_cb.h **** }
 437              		.loc 3 31 1
 438 002c 0300A0E1 		mov	r0, r3
 439 0030 04D04BE2 		sub	sp, fp, #4
 440              		.cfi_def_cfa 13, 8
 441              		@ sp needed
 442 0034 0048BDE8 		pop	{fp, lr}
 443              		.cfi_restore 14
 444              		.cfi_restore 11
 445              		.cfi_def_cfa_offset 0
 446 0038 1EFF2FE1 		bx	lr
 447              	.L20:
 448              		.align	2
 449              	.L19:
 450 003c 00000000 		.word	byte_fifo_put_possible
 451              		.cfi_endproc
 452              	.LFE6:
 454              		.section	.text.byte_fifo_cb_put,"ax",%progbits
 455              		.align	2
 456              		.syntax unified
 457              		.arm
 459              	byte_fifo_cb_put:
 460              	.LFB7:
  32:./trace32/../lib/byte_fifo_cb.h **** 	
  33:./trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put(byte_fifo_cb_t *fifo,unsigned char val)
  34:./trace32/../lib/byte_fifo_cb.h **** {
 461              		.loc 3 34 1
 462              		.cfi_startproc
 463              		@ Function supports interworking.
 464              		@ args = 0, pretend = 0, frame = 16
 465              		@ frame_needed = 1, uses_anonymous_args = 0
 466 0000 00482DE9 		push	{fp, lr}
 467              		.cfi_def_cfa_offset 8
 468              		.cfi_offset 11, -8
 469              		.cfi_offset 14, -4
 470 0004 04B08DE2 		add	fp, sp, #4
 471              		.cfi_def_cfa 11, 4
 472 0008 10D04DE2 		sub	sp, sp, #16
 473 000c 10000BE5 		str	r0, [fp, #-16]
 474 0010 0130A0E1 		mov	r3, r1
 475 0014 11304BE5 		strb	r3, [fp, #-17]
  35:./trace32/../lib/byte_fifo_cb.h **** 	int ret=byte_fifo_put(&fifo->byte_fifo,val);
 476              		.loc 3 35 10
 477 0018 10301BE5 		ldr	r3, [fp, #-16]
 478 001c 043083E2 		add	r3, r3, #4
 479 0020 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 480 0024 0210A0E1 		mov	r1, r2
 481 0028 0300A0E1 		mov	r0, r3
 482 002c 48309FE5 		ldr	r3, .L24
 483 0030 0FE0A0E1 		mov	lr, pc
 484 0034 13FF2FE1 		bx	r3
 485              	.LVL1:
 486 0038 08000BE5 		str	r0, [fp, #-8]
  36:./trace32/../lib/byte_fifo_cb.h **** 	if( !ret && fifo->cb)
 487              		.loc 3 36 4
 488 003c 08301BE5 		ldr	r3, [fp, #-8]
 489 0040 000053E3 		cmp	r3, #0
 490 0044 0700001A 		bne	.L22
 491              		.loc 3 36 18 discriminator 1
 492 0048 10301BE5 		ldr	r3, [fp, #-16]
 493 004c 003093E5 		ldr	r3, [r3]
 494              		.loc 3 36 11 discriminator 1
 495 0050 000053E3 		cmp	r3, #0
 496 0054 0300000A 		beq	.L22
  37:./trace32/../lib/byte_fifo_cb.h **** 		fifo->cb();
 497              		.loc 3 37 7
 498 0058 10301BE5 		ldr	r3, [fp, #-16]
 499 005c 003093E5 		ldr	r3, [r3]
 500              		.loc 3 37 3
 501 0060 0FE0A0E1 		mov	lr, pc
 502 0064 13FF2FE1 		bx	r3
 503              	.LVL2:
 504              	.L22:
  38:./trace32/../lib/byte_fifo_cb.h **** 	return ret;
 505              		.loc 3 38 9
 506 0068 08301BE5 		ldr	r3, [fp, #-8]
  39:./trace32/../lib/byte_fifo_cb.h **** }
 507              		.loc 3 39 1
 508 006c 0300A0E1 		mov	r0, r3
 509 0070 04D04BE2 		sub	sp, fp, #4
 510              		.cfi_def_cfa 13, 8
 511              		@ sp needed
 512 0074 0048BDE8 		pop	{fp, lr}
 513              		.cfi_restore 14
 514              		.cfi_restore 11
 515              		.cfi_def_cfa_offset 0
 516 0078 1EFF2FE1 		bx	lr
 517              	.L25:
 518              		.align	2
 519              	.L24:
 520 007c 00000000 		.word	byte_fifo_put
 521              		.cfi_endproc
 522              	.LFE7:
 524              		.section	.text.byte_fifo_cb_get_possible,"ax",%progbits
 525              		.align	2
 526              		.syntax unified
 527              		.arm
 529              	byte_fifo_cb_get_possible:
 530              	.LFB8:
  40:./trace32/../lib/byte_fifo_cb.h **** 
  41:./trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get_possible(byte_fifo_cb_t *fifo)
  42:./trace32/../lib/byte_fifo_cb.h **** {
 531              		.loc 3 42 1
 532              		.cfi_startproc
 533              		@ Function supports interworking.
 534              		@ args = 0, pretend = 0, frame = 8
 535              		@ frame_needed = 1, uses_anonymous_args = 0
 536 0000 00482DE9 		push	{fp, lr}
 537              		.cfi_def_cfa_offset 8
 538              		.cfi_offset 11, -8
 539              		.cfi_offset 14, -4
 540 0004 04B08DE2 		add	fp, sp, #4
 541              		.cfi_def_cfa 11, 4
 542 0008 08D04DE2 		sub	sp, sp, #8
 543 000c 08000BE5 		str	r0, [fp, #-8]
  43:./trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get_possible(&fifo->byte_fifo);
 544              		.loc 3 43 9
 545 0010 08301BE5 		ldr	r3, [fp, #-8]
 546 0014 043083E2 		add	r3, r3, #4
 547 0018 0300A0E1 		mov	r0, r3
 548 001c 18309FE5 		ldr	r3, .L28
 549 0020 0FE0A0E1 		mov	lr, pc
 550 0024 13FF2FE1 		bx	r3
 551              	.LVL3:
 552 0028 0030A0E1 		mov	r3, r0
  44:./trace32/../lib/byte_fifo_cb.h **** }
 553              		.loc 3 44 1
 554 002c 0300A0E1 		mov	r0, r3
 555 0030 04D04BE2 		sub	sp, fp, #4
 556              		.cfi_def_cfa 13, 8
 557              		@ sp needed
 558 0034 0048BDE8 		pop	{fp, lr}
 559              		.cfi_restore 14
 560              		.cfi_restore 11
 561              		.cfi_def_cfa_offset 0
 562 0038 1EFF2FE1 		bx	lr
 563              	.L29:
 564              		.align	2
 565              	.L28:
 566 003c 00000000 		.word	byte_fifo_get_possible
 567              		.cfi_endproc
 568              	.LFE8:
 570              		.section	.text.byte_fifo_cb_get,"ax",%progbits
 571              		.align	2
 572              		.syntax unified
 573              		.arm
 575              	byte_fifo_cb_get:
 576              	.LFB9:
  45:./trace32/../lib/byte_fifo_cb.h **** 
  46:./trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get(byte_fifo_cb_t *fifo,unsigned char *val)
  47:./trace32/../lib/byte_fifo_cb.h **** {
 577              		.loc 3 47 1
 578              		.cfi_startproc
 579              		@ Function supports interworking.
 580              		@ args = 0, pretend = 0, frame = 8
 581              		@ frame_needed = 1, uses_anonymous_args = 0
 582 0000 00482DE9 		push	{fp, lr}
 583              		.cfi_def_cfa_offset 8
 584              		.cfi_offset 11, -8
 585              		.cfi_offset 14, -4
 586 0004 04B08DE2 		add	fp, sp, #4
 587              		.cfi_def_cfa 11, 4
 588 0008 08D04DE2 		sub	sp, sp, #8
 589 000c 08000BE5 		str	r0, [fp, #-8]
 590 0010 0C100BE5 		str	r1, [fp, #-12]
  48:./trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get(&fifo->byte_fifo,val);
 591              		.loc 3 48 9
 592 0014 08301BE5 		ldr	r3, [fp, #-8]
 593 0018 043083E2 		add	r3, r3, #4
 594 001c 0C101BE5 		ldr	r1, [fp, #-12]
 595 0020 0300A0E1 		mov	r0, r3
 596 0024 18309FE5 		ldr	r3, .L32
 597 0028 0FE0A0E1 		mov	lr, pc
 598 002c 13FF2FE1 		bx	r3
 599              	.LVL4:
 600 0030 0030A0E1 		mov	r3, r0
  49:./trace32/../lib/byte_fifo_cb.h **** }
 601              		.loc 3 49 1
 602 0034 0300A0E1 		mov	r0, r3
 603 0038 04D04BE2 		sub	sp, fp, #4
 604              		.cfi_def_cfa 13, 8
 605              		@ sp needed
 606 003c 0048BDE8 		pop	{fp, lr}
 607              		.cfi_restore 14
 608              		.cfi_restore 11
 609              		.cfi_def_cfa_offset 0
 610 0040 1EFF2FE1 		bx	lr
 611              	.L33:
 612              		.align	2
 613              	.L32:
 614 0044 00000000 		.word	byte_fifo_get
 615              		.cfi_endproc
 616              	.LFE9:
 618              		.global	udmon3
 619              		.bss
 620              		.align	2
 623              	udmon3:
 624 0000 00000000 		.space	100
 624      00000000 
 624      00000000 
 624      00000000 
 624      00000000 
 625              		.section	.text.udmon3_init,"ax",%progbits
 626              		.align	2
 627              		.global	udmon3_init
 628              		.syntax unified
 629              		.arm
 631              	udmon3_init:
 632              	.LFB10:
   1:./trace32/udmon3.c **** /**************************************************************************
   2:./trace32/udmon3.c **** Bereitstellung des UDMON3 Treibers für
   3:./trace32/udmon3.c ****  - Im RAM-Modus
   4:./trace32/udmon3.c ****       Zugriff auf Speicher über '%e' Befehle
   5:./trace32/udmon3.c **** 	  Zugriff auf 'Virtuellen' DisplaySpeicher 
   6:./trace32/udmon3.c **** 	     (Interne Bitmap wird auf GrayScale Bitmap umgemap)
   7:./trace32/udmon3.c ****       Zugriff auf MMU/Cache (jedoch in AT91SAM7 nicht vorhanden)
   8:./trace32/udmon3.c ****       Terminal Datenaustausch
   9:./trace32/udmon3.c ****  - Im Simulations-Modus
  10:./trace32/udmon3.c ****       Terminal Datenaustausch
  11:./trace32/udmon3.c **** 
  12:./trace32/udmon3.c ****  Aus debugger_arm.pdf
  13:./trace32/udmon3.c ****  If SYStem.MemAccess ist not denied, it is possible to read from memory, 
  14:./trace32/udmon3.c ****  to wirte to memory and to set software breakpoints while the CPU
  15:./trace32/udmon3.c ****  is executing the programm. This requeires one of the follow monitors
  16:./trace32/udmon3.c ****  - CERBERUS (Infineon)
  17:./trace32/udmon3.c ****  - CPU (Instruction Set simulator)
  18:./trace32/udmon3.c ****  - DAP (Debug Access Port)
  19:./trace32/udmon3.c ****  - NEXUS
  20:./trace32/udmon3.c ****  - TSMON3: A run-time memory access is done via a Time Sharing Monitor
  21:./trace32/udmon3.c ****    The application is responsible for calling the monitor code periodically.
  22:./trace32/udmon3.c ****    The call ist typically include in a periodic interrupt or int the idle 
  23:./trace32/udmon3.c ****    task of the kernel. (runtime_memory_access)
  24:./trace32/udmon3.c ****    Besides runtime memory access TSMON3 would allow run mode debugging.
  25:./trace32/udmon3.c ****    But manual break is not possible with TSMON 3 and could only be emulated
  26:./trace32/udmon3.c ****    by polling the DCC port. 
  27:./trace32/udmon3.c ****  - PTMON3: A run-time memory access is done via a PULSE Triggered Monitor
  28:./trace32/udmon3.c ****    Whenever the debugger wants to perform a memory access while the program
  29:./trace32/udmon3.c ****    is running, the debugger generates a trigger for the trigger bus. If the
  30:./trace32/udmon3.c ****    trigger bus in configured appropriate (TrBus), this trigger is output
  31:./trace32/udmon3.c ****    via the TRIGGER connector of the TRACE32 development tool. The TRIGGER
  32:./trace32/udmon3.c ****    output can be connected to an external interrupt in order to call a 
  33:./trace32/udmon3.c ****    monitor.  (runtime_memory_access)
  34:./trace32/udmon3.c ****    Besides runtime memory acces PTMON3 would allow run mode debugging.
  35:./trace32/udmon3.c ****    But manual break is not possible with PTMON3 and could only be emulated
  36:./trace32/udmon3.c ****    by polling the DCC port.
  37:./trace32/udmon3.c ****  - UDMON3: A run-time memory access is done via a Usermode Debug Monitor
  38:./trace32/udmon3.c ****    The application is responsible for calling the montiro code periodically.
  39:./trace32/udmon3.c ****    The call is typically include in a periodic interrupt or in the idle task
  40:./trace32/udmon3.c ****    of the kernel. For runtime memory access UDMON3 behaves exactly as TSMON3. 
  41:./trace32/udmon3.c ****    (runtime_memory_access)
  42:./trace32/udmon3.c ****    Besides runtime memory access UDMON3 allows run mode debugging.
  43:./trace32/udmon3.c ****    Handling of interrupts when the application is stopped is possible when
  44:./trace32/udmon3.c ****    the background monitor is activated. On-chip breakpoints and manual 
  45:./trace32/udmon3.c ****    program break are only possible when the application runs in user (USR)
  46:./trace32/udmon3.c ****    mode. (background_monitor)
  47:./trace32/udmon3.c **** **************************************************************************/
  48:./trace32/udmon3.c **** #include <stddef.h>          //fuer NULL
  49:./trace32/udmon3.c **** #include "udmon3.h"
  50:./trace32/udmon3.c **** #include "../lib/aic.h"  //fuer aic_sys_register_commxx() 
  51:./trace32/udmon3.c ****                          //     aic_sys_register_pit() aic_sys_vl_t
  52:./trace32/udmon3.c **** 
  53:./trace32/udmon3.c **** #pragma GCC push_options
  54:./trace32/udmon3.c **** #pragma GCC optimize ("O2")
  55:./trace32/udmon3.c **** 
  56:./trace32/udmon3.c **** #define UDMON3_ZYKLISCH 0
  57:./trace32/udmon3.c **** #define UDMON3_IRQ      1
  58:./trace32/udmon3.c **** #define UDMON3_MODE     UDMON3_ZYKLISCH
  59:./trace32/udmon3.c **** //#define UDMON3_MODE     UDMON3_IRQ
  60:./trace32/udmon3.c **** //Datenübertragung per IRQ funktioniert gut. Dann sollte jedoch kein d.image genutzt werden
  61:./trace32/udmon3.c **** //da trace32 zur Darstellung einer hohen Bildwiederholrate annäherend kontinuierlich
  62:./trace32/udmon3.c **** //den Bildschirmspeicher ausliest! Damit bleibt der Hauptanwendung nur noch wenig
  63:./trace32/udmon3.c **** //Rechenzeit übrig!
  64:./trace32/udmon3.c ****   
  65:./trace32/udmon3.c **** #ifdef MODE_RAM
  66:./trace32/udmon3.c ****   //Fuer den Zugriff des Debuggers auf das Display wird der der Display-Speicher
  67:./trace32/udmon3.c ****   //in einen 'virtuellen' Speicherbereich ab LCD_MEMORY_OFFSET abgebildet
  68:./trace32/udmon3.c ****   #include "../lib/nxt_lcd.h"  //fuer NXT_LCD_WIDTH  NXT_LCD_DEPTH
  69:./trace32/udmon3.c ****   #include "../lib/display.h"  //fuer display_get_buffer()
  70:./trace32/udmon3.c **** 
  71:./trace32/udmon3.c ****   //aus sim_NXT/sim_NXT.h
  72:./trace32/udmon3.c ****   #define LCD_MEMORY_OFFSET  0x10000000  //in diesem Bereich 
  73:./trace32/udmon3.c ****                                          //- tätigt der Simulator eine Kopie des Bildschirmspeicher
  74:./trace32/udmon3.c **** 										 //- muss im RAM-Modus der Bildschirmspeicher abgebildet werden
  75:./trace32/udmon3.c ****   #define NXT_MEMORY_OFFSET  0x20000000  //in diesen Bereich schreibt der Simulator die NXT
  76:./trace32/udmon3.c ****                                          //spezfischen Daten (siehe auch link.ld)
  77:./trace32/udmon3.c **** 
  78:./trace32/udmon3.c ****   //aus sim_NXT/nxt.c
  79:./trace32/udmon3.c ****   #define NXT_WIDTH 150   //Gesamtgröße NXT-Grafik
  80:./trace32/udmon3.c ****   #define NXT_HIGH  250   //Gesamtgröße NXT-Grafik
  81:./trace32/udmon3.c ****   
  82:./trace32/udmon3.c ****   #define LCD_WIDTH 100   //Größe LCD-Display
  83:./trace32/udmon3.c ****   #define LCD_HIGH   64   //Größe LCD-Display
  84:./trace32/udmon3.c ****   #define LCD_X      25   //Offset für LCD-Display
  85:./trace32/udmon3.c ****   #define LCD_Y      50   //Offset für LCD-Display
  86:./trace32/udmon3.c **** 
  87:./trace32/udmon3.c **** 
  88:./trace32/udmon3.c ****   //Zur Sicherheit Daten aus sim_NXT mit Daten aus nxt_lcd vergleichen
  89:./trace32/udmon3.c ****   #if (NXT_LCD_DEPTH*8 != LCD_HIGH)
  90:./trace32/udmon3.c ****     #error "LCD_HIGH != NXT_LCD_DEPTH"
  91:./trace32/udmon3.c ****   #endif
  92:./trace32/udmon3.c ****   #if (NXT_LCD_WIDTH != LCD_WIDTH)
  93:./trace32/udmon3.c ****     #error "LCD_WIDTH != NXT_LCD_WIDTH"
  94:./trace32/udmon3.c ****   #endif
  95:./trace32/udmon3.c **** #endif
  96:./trace32/udmon3.c **** 
  97:./trace32/udmon3.c **** 
  98:./trace32/udmon3.c **** #include "../AT91SAM7S64.h"
  99:./trace32/udmon3.c **** 
 100:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_IRQ
 101:./trace32/udmon3.c **** #define COMMTX_IRQ_ENABLE()    *AT91C_DBGU_IER = AT91C_US_COMM_TX
 102:./trace32/udmon3.c **** #define COMMTX_IRQ_DISABLE()   *AT91C_DBGU_IDR = AT91C_US_COMM_TX
 103:./trace32/udmon3.c **** #define COMMRX_IRQ_ENABLE()    *AT91C_DBGU_IER = AT91C_US_COMM_RX
 104:./trace32/udmon3.c **** #endif
 105:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_ZYKLISCH
 106:./trace32/udmon3.c **** #define COMMTX_IRQ_ENABLE()
 107:./trace32/udmon3.c **** #define COMMTX_IRQ_DISABLE()
 108:./trace32/udmon3.c **** #define COMMRX_IRQ_ENABLE()
 109:./trace32/udmon3.c **** #endif
 110:./trace32/udmon3.c **** 
 111:./trace32/udmon3.c **** 
 112:./trace32/udmon3.c **** /**************************************************************************
 113:./trace32/udmon3.c **** **************************************************************************/
 114:./trace32/udmon3.c **** 
 115:./trace32/udmon3.c **** struct {
 116:./trace32/udmon3.c **** 	byte_fifo_cb_t *term_send;
 117:./trace32/udmon3.c **** 	byte_fifo_cb_t *term_recv;
 118:./trace32/udmon3.c **** 	
 119:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_ZYKLISCH
 120:./trace32/udmon3.c ****     aic_sys_vl_t   aic_sys_vl;
 121:./trace32/udmon3.c **** #endif	
 122:./trace32/udmon3.c **** #ifdef MODE_RAM
 123:./trace32/udmon3.c ****     unsigned char *display_buffer;
 124:./trace32/udmon3.c **** #endif
 125:./trace32/udmon3.c **** 
 126:./trace32/udmon3.c **** #ifdef MODE_RAM
 127:./trace32/udmon3.c **** 	unsigned int monitor_address_high;
 128:./trace32/udmon3.c **** 	unsigned int monitor_address_low;
 129:./trace32/udmon3.c **** 	unsigned int monitor_buffer[16];
 130:./trace32/udmon3.c **** 	         int monitor_index;
 131:./trace32/udmon3.c **** 			 int monitor_count;       //Anzahl zu sendender Zeichen
 132:./trace32/udmon3.c **** #endif
 133:./trace32/udmon3.c **** #ifdef PTMON3
 134:./trace32/udmon3.c ****     #define MONITOR_STACKSIZE 0x40
 135:./trace32/udmon3.c **** 	unsigned int  monitor_stacksize;
 136:./trace32/udmon3.c **** 	unsigned int  monitor_registers_and_stack[MONITOR_STACKSIZE+40];
 137:./trace32/udmon3.c **** 	unsigned int *monitor_stackbase;
 138:./trace32/udmon3.c **** #endif	
 139:./trace32/udmon3.c **** } udmon3 = {
 140:./trace32/udmon3.c **** 	.term_send  = NULL,
 141:./trace32/udmon3.c **** 	.term_recv  = NULL,
 142:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_ZYKLISCH
 143:./trace32/udmon3.c **** 	.aic_sys_vl = {.next=NULL,.fcn=NULL},
 144:./trace32/udmon3.c **** #endif	
 145:./trace32/udmon3.c **** #ifdef MODE_RAM
 146:./trace32/udmon3.c **** 	.display_buffer=NULL,
 147:./trace32/udmon3.c **** #endif
 148:./trace32/udmon3.c **** #ifdef PTMON3
 149:./trace32/udmon3.c **** 	.monitor_stacksize = MONITOR_STACKSIZE;
 150:./trace32/udmon3.c **** 	.monitor_stackbase = udmon3.monitor_registers_and_stack+MONITOR_STACKSIZE;
 151:./trace32/udmon3.c **** #endif	
 152:./trace32/udmon3.c **** };
 153:./trace32/udmon3.c **** 
 154:./trace32/udmon3.c **** 
 155:./trace32/udmon3.c **** void udmon3_handler(void);
 156:./trace32/udmon3.c **** 
 157:./trace32/udmon3.c **** void udmon3_init(void) 
 158:./trace32/udmon3.c **** {
 633              		.loc 1 158 1
 634              		.cfi_startproc
 635              		@ Function supports interworking.
 636              		@ args = 0, pretend = 0, frame = 0
 637              		@ frame_needed = 0, uses_anonymous_args = 0
 159:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_ZYKLISCH
 160:./trace32/udmon3.c ****   /* Callback Routine einhängen */
 161:./trace32/udmon3.c ****   aic_sys_register_pit(&udmon3.aic_sys_vl,udmon3_handler);
 638              		.loc 1 161 3
 158:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_ZYKLISCH
 639              		.loc 1 158 1 is_stmt 0
 640 0000 10402DE9 		push	{r4, lr}
 641              		.cfi_def_cfa_offset 8
 642              		.cfi_offset 4, -8
 643              		.cfi_offset 14, -4
 644              		.loc 1 161 3
 645 0004 14109FE5 		ldr	r1, .L37
 646 0008 14009FE5 		ldr	r0, .L37+4
 647 000c 14309FE5 		ldr	r3, .L37+8
 648 0010 0FE0A0E1 		mov	lr, pc
 649 0014 13FF2FE1 		bx	r3
 650              	.LVL5:
 162:./trace32/udmon3.c **** #endif  
 163:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_IRQ
 164:./trace32/udmon3.c **** 	aic_sys_register_commxx(udmon3_handler);
 165:./trace32/udmon3.c **** 	COMMRX_IRQ_ENABLE();
 166:./trace32/udmon3.c **** #endif
 167:./trace32/udmon3.c **** }
 651              		.loc 1 167 1
 652 0018 1040BDE8 		pop	{r4, lr}
 653              		.cfi_restore 14
 654              		.cfi_restore 4
 655              		.cfi_def_cfa_offset 0
 656 001c 1EFF2FE1 		bx	lr
 657              	.L38:
 658              		.align	2
 659              	.L37:
 660 0020 00000000 		.word	udmon3_handler
 661 0024 08000000 		.word	udmon3+8
 662 0028 00000000 		.word	aic_sys_register_pit
 663              		.cfi_endproc
 664              	.LFE10:
 666              		.section	.text.udmon3_term_init,"ax",%progbits
 667              		.align	2
 668              		.global	udmon3_term_init
 669              		.syntax unified
 670              		.arm
 672              	udmon3_term_init:
 673              	.LFB11:
 168:./trace32/udmon3.c **** 
 169:./trace32/udmon3.c **** 
 170:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_IRQ
 171:./trace32/udmon3.c **** static void enable_commtx(void)
 172:./trace32/udmon3.c **** {
 173:./trace32/udmon3.c **** 	COMMTX_IRQ_ENABLE();
 174:./trace32/udmon3.c **** }
 175:./trace32/udmon3.c **** #endif
 176:./trace32/udmon3.c **** 
 177:./trace32/udmon3.c **** void udmon3_term_init(byte_fifo_cb_t *recv,byte_fifo_cb_t *send,byte_fifo_cb *tx_cb)
 178:./trace32/udmon3.c **** {
 674              		.loc 1 178 1 is_stmt 1
 675              		.cfi_startproc
 676              		@ Function supports interworking.
 677              		@ args = 0, pretend = 0, frame = 0
 678              		@ frame_needed = 0, uses_anonymous_args = 0
 679              		@ link register save eliminated.
 680              	.LVL6:
 179:./trace32/udmon3.c **** 	udmon3.term_send=send;
 681              		.loc 1 179 2
 180:./trace32/udmon3.c **** 	udmon3.term_recv=recv;
 181:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_IRQ
 182:./trace32/udmon3.c **** 	*tx_cb = enable_commtx;
 183:./trace32/udmon3.c **** #endif
 184:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_ZYKLISCH
 185:./trace32/udmon3.c **** 	*tx_cb = NULL;
 682              		.loc 1 185 9 is_stmt 0
 683 0000 00C0A0E3 		mov	ip, #0
 179:./trace32/udmon3.c **** 	udmon3.term_send=send;
 684              		.loc 1 179 18
 685 0004 0C309FE5 		ldr	r3, .L40
 180:./trace32/udmon3.c **** 	udmon3.term_recv=recv;
 686              		.loc 1 180 18
 687 0008 040083E5 		str	r0, [r3, #4]
 179:./trace32/udmon3.c **** 	udmon3.term_send=send;
 688              		.loc 1 179 18
 689 000c 001083E5 		str	r1, [r3]
 180:./trace32/udmon3.c **** 	udmon3.term_recv=recv;
 690              		.loc 1 180 2 is_stmt 1
 691              		.loc 1 185 2
 692              		.loc 1 185 9 is_stmt 0
 693 0010 00C082E5 		str	ip, [r2]
 186:./trace32/udmon3.c **** #endif
 187:./trace32/udmon3.c **** }
 694              		.loc 1 187 1
 695 0014 1EFF2FE1 		bx	lr
 696              	.L41:
 697              		.align	2
 698              	.L40:
 699 0018 00000000 		.word	udmon3
 700              		.cfi_endproc
 701              	.LFE11:
 703              		.section	.text.Monitor_ReadByte,"ax",%progbits
 704              		.align	2
 705              		.syntax unified
 706              		.arm
 708              	Monitor_ReadByte:
 709              	.LFB12:
 188:./trace32/udmon3.c **** 
 189:./trace32/udmon3.c **** /**************************************************************************
 190:./trace32/udmon3.c **** 
 191:./trace32/udmon3.c ****   CP15 access  / MMU + Cache
 192:./trace32/udmon3.c **** 
 193:./trace32/udmon3.c ****   Does not support all CP15 register. Can be extended appropriate to your need.
 194:./trace32/udmon3.c **** 
 195:./trace32/udmon3.c ****   ARM9 requires the CP15 accesses to be done in a privileged mode (not in
 196:./trace32/udmon3.c ****   user mode). In this example the Monitor_Handler will be called from the
 197:./trace32/udmon3.c ****   monitor (privileged mode), but also from the application (user mode).
 198:./trace32/udmon3.c ****   Therefore do not access CP15 register while the application is running
 199:./trace32/udmon3.c ****   (e.g. by 'Data.In EC15:0x0001 /Long').
 200:./trace32/udmon3.c **** 
 201:./trace32/udmon3.c **** **************************************************************************/
 202:./trace32/udmon3.c **** #if 0 
 203:./trace32/udmon3.c **** static unsigned int Monitor_ReadCP15 (unsigned int address)
 204:./trace32/udmon3.c **** {
 205:./trace32/udmon3.c ****   unsigned int data = 0;
 206:./trace32/udmon3.c **** 
 207:./trace32/udmon3.c ****   switch (address)
 208:./trace32/udmon3.c ****   {
 209:./trace32/udmon3.c ****     case 0xf000:
 210:./trace32/udmon3.c **** 		asm volatile("MRC p15, 0, %0  , c0, c0" : "=r" (data));
 211:./trace32/udmon3.c **** 		break;
 212:./trace32/udmon3.c ****     case 0xf001:
 213:./trace32/udmon3.c **** 		asm volatile("MRC p15, 0, %0  , c1, c0" : "=r" (data));
 214:./trace32/udmon3.c **** 		break;
 215:./trace32/udmon3.c ****     case 0xf002:
 216:./trace32/udmon3.c **** 		asm volatile("MRC p15, 0, %0  , c2, c0" : "=r" (data));
 217:./trace32/udmon3.c **** 		break;
 218:./trace32/udmon3.c ****     case 0xf003:
 219:./trace32/udmon3.c **** 		asm volatile("MRC p15, 0, %0  , c3, c0" : "=r" (data));
 220:./trace32/udmon3.c **** 		break;
 221:./trace32/udmon3.c ****     case 0xf004:
 222:./trace32/udmon3.c **** 		asm volatile("MRC p15, 0, %0  , c4, c0" : "=r" (data));
 223:./trace32/udmon3.c **** 		break;
 224:./trace32/udmon3.c ****     case 0xf005:
 225:./trace32/udmon3.c **** 		asm volatile("MRC p15, 0, %0  , c5, c0" : "=r" (data));
 226:./trace32/udmon3.c **** 		break;
 227:./trace32/udmon3.c ****   }
 228:./trace32/udmon3.c ****   return data;
 229:./trace32/udmon3.c **** }
 230:./trace32/udmon3.c **** 
 231:./trace32/udmon3.c **** static void Monitor_WriteCP15 (unsigned int address, unsigned int data)
 232:./trace32/udmon3.c **** {
 233:./trace32/udmon3.c ****   switch (address)
 234:./trace32/udmon3.c ****   {
 235:./trace32/udmon3.c ****     case 0xf000:
 236:./trace32/udmon3.c **** 		asm volatile("mcr p15, 0, %0, c0, c0" : : "r" (data));
 237:./trace32/udmon3.c **** 		break;
 238:./trace32/udmon3.c ****     case 0xf001:
 239:./trace32/udmon3.c **** 		asm volatile("mcr p15, 0, %0, c1, c0" : : "r" (data));
 240:./trace32/udmon3.c **** 		break;
 241:./trace32/udmon3.c ****     case 0xf002:
 242:./trace32/udmon3.c **** 		asm volatile("mcr p15, 0, %0, c2, c0" : : "r" (data));
 243:./trace32/udmon3.c **** 		break;
 244:./trace32/udmon3.c ****     case 0xf003:
 245:./trace32/udmon3.c **** 		asm volatile("mcr p15, 0, %0, c3, c0" : : "r" (data));
 246:./trace32/udmon3.c **** 		break;
 247:./trace32/udmon3.c ****     case 0xf004:
 248:./trace32/udmon3.c **** 		asm volatile("mcr p15, 0, %0, c4, c0" : : "r" (data));
 249:./trace32/udmon3.c **** 		break;
 250:./trace32/udmon3.c ****     case 0xf005:
 251:./trace32/udmon3.c **** 		asm volatile("mcr p15, 0, %0, c5, c0" : : "r" (data));
 252:./trace32/udmon3.c **** 		break;
 253:./trace32/udmon3.c ****   }
 254:./trace32/udmon3.c **** }
 255:./trace32/udmon3.c **** #endif
 256:./trace32/udmon3.c **** 
 257:./trace32/udmon3.c **** /**************************************************************************
 258:./trace32/udmon3.c **** 
 259:./trace32/udmon3.c ****   CP14 access  / Debug Schnittstelle
 260:./trace32/udmon3.c ****   
 261:./trace32/udmon3.c ****   ARM family dependent DCC driver functions
 262:./trace32/udmon3.c **** 
 263:./trace32/udmon3.c **** **************************************************************************/
 264:./trace32/udmon3.c **** 
 265:./trace32/udmon3.c **** #if 0
 266:./trace32/udmon3.c **** static inline unsigned int DCC_SendStatus (void)
 267:./trace32/udmon3.c **** {
 268:./trace32/udmon3.c **** 	int status;
 269:./trace32/udmon3.c **** 
 270:./trace32/udmon3.c **** 	asm volatile("mrc p14, 0, %0, c0, c0" : "=r" (status));
 271:./trace32/udmon3.c **** 
 272:./trace32/udmon3.c **** 	return (status & 2);
 273:./trace32/udmon3.c **** }
 274:./trace32/udmon3.c **** 
 275:./trace32/udmon3.c **** static inline void DCC_SendWord (unsigned int data)
 276:./trace32/udmon3.c **** {
 277:./trace32/udmon3.c **** 	asm volatile("mcr p14, 0, %0, c1, c0" : : "r" (data));
 278:./trace32/udmon3.c **** }
 279:./trace32/udmon3.c **** 
 280:./trace32/udmon3.c **** static inline unsigned int DCC_ReceiveStatus (void)
 281:./trace32/udmon3.c **** {
 282:./trace32/udmon3.c **** 	int  status;
 283:./trace32/udmon3.c **** 
 284:./trace32/udmon3.c **** 	asm volatile("mrc p14, 0, %0, c0, c0" : "=r" (status));
 285:./trace32/udmon3.c **** 
 286:./trace32/udmon3.c **** 	return (status & 1);
 287:./trace32/udmon3.c **** }
 288:./trace32/udmon3.c **** 
 289:./trace32/udmon3.c **** static inline unsigned int DCC_ReceiveWord (void)
 290:./trace32/udmon3.c **** {
 291:./trace32/udmon3.c **** 	unsigned int data;
 292:./trace32/udmon3.c **** 
 293:./trace32/udmon3.c **** 	asm volatile("mrc p14, 0, %0, c1, c0" : "=r" (data));
 294:./trace32/udmon3.c **** 
 295:./trace32/udmon3.c **** 	return data;
 296:./trace32/udmon3.c **** }
 297:./trace32/udmon3.c **** 
 298:./trace32/udmon3.c **** #else
 299:./trace32/udmon3.c **** 
 300:./trace32/udmon3.c **** #define DCC_SendStatus()    ({int status; \
 301:./trace32/udmon3.c ****                               asm volatile inline("mrc p14, 0, %0, c0, c0" : "=r" (status));\
 302:./trace32/udmon3.c ****                               status & 2;})
 303:./trace32/udmon3.c **** 
 304:./trace32/udmon3.c **** #define DCC_SendWord(data)    asm inline("mcr p14, 0, %0, c1, c0" : : "r" (data));
 305:./trace32/udmon3.c **** 
 306:./trace32/udmon3.c **** #define DCC_ReceiveStatus() ({int status;\
 307:./trace32/udmon3.c ****                               asm volatile inline("mrc p14, 0, %0, c0, c0" : "=r" (status));\
 308:./trace32/udmon3.c **** 							  status & 1;})
 309:./trace32/udmon3.c **** 
 310:./trace32/udmon3.c **** #define DCC_ReceiveWord()   ({unsigned int data; \
 311:./trace32/udmon3.c **** 	                          asm inline("mrc p14, 0, %0, c1, c0" : "=r" (data));\
 312:./trace32/udmon3.c ****                               data;})
 313:./trace32/udmon3.c **** #endif
 314:./trace32/udmon3.c **** 
 315:./trace32/udmon3.c **** /**************************************************************************
 316:./trace32/udmon3.c **** 
 317:./trace32/udmon3.c ****   memory access
 318:./trace32/udmon3.c **** 
 319:./trace32/udmon3.c **** **************************************************************************/
 320:./trace32/udmon3.c **** 
 321:./trace32/udmon3.c **** #ifdef MODE_RAM
 322:./trace32/udmon3.c **** static void Monitor_ReadByte (void * buf, void * address, int len)
 323:./trace32/udmon3.c **** {
 710              		.loc 1 323 1 is_stmt 1
 711              		.cfi_startproc
 712              		@ Function supports interworking.
 713              		@ args = 0, pretend = 0, frame = 8
 714              		@ frame_needed = 0, uses_anonymous_args = 0
 715              	.LVL7:
 716 0000 F0472DE9 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 717              		.cfi_def_cfa_offset 32
 718              		.cfi_offset 4, -32
 719              		.cfi_offset 5, -28
 720              		.cfi_offset 6, -24
 721              		.cfi_offset 7, -20
 722              		.cfi_offset 8, -16
 723              		.cfi_offset 9, -12
 724              		.cfi_offset 10, -8
 725              		.cfi_offset 14, -4
 324:./trace32/udmon3.c ****   int i;
 325:./trace32/udmon3.c ****   unsigned char *source = (unsigned char *) address;
 326:./trace32/udmon3.c ****   unsigned char *target = (unsigned char *) buf;
 327:./trace32/udmon3.c **** 
 328:./trace32/udmon3.c ****   //Zur Darstellung des virtuellen Bildschirmsepeichers
 329:./trace32/udmon3.c ****   //Debugger greift bei Nutzung von 'd.image 0x10000000 100. 64. /MONO'
 330:./trace32/udmon3.c ****   //nur Byteweise auf diesen Sepicher zu.
 331:./trace32/udmon3.c ****   if(((int)source & 0xffC00000) == LCD_MEMORY_OFFSET)
 726              		.loc 1 331 19 is_stmt 0
 727 0004 213BA0E1 		lsr	r3, r1, #22
 728 0008 033BA0E1 		lsl	r3, r3, #22
 729              		.loc 1 331 5
 730 000c 010253E3 		cmp	r3, #268435456
 323:./trace32/udmon3.c ****   int i;
 731              		.loc 1 323 1
 732 0010 0050A0E1 		mov	r5, r0
 324:./trace32/udmon3.c ****   int i;
 733              		.loc 1 324 3 is_stmt 1
 325:./trace32/udmon3.c ****   unsigned char *target = (unsigned char *) buf;
 734              		.loc 1 325 3
 735              	.LVL8:
 326:./trace32/udmon3.c **** 
 736              		.loc 1 326 3
 737              		.loc 1 331 3
 323:./trace32/udmon3.c ****   int i;
 738              		.loc 1 323 1 is_stmt 0
 739 0014 08D04DE2 		sub	sp, sp, #8
 740              		.cfi_def_cfa_offset 40
 741              		.loc 1 331 5
 742 0018 0C00000A 		beq	.L43
 743              	.LVL9:
 332:./trace32/udmon3.c ****   {
 333:./trace32/udmon3.c **** 	if(udmon3.display_buffer == NULL)
 334:./trace32/udmon3.c **** 		udmon3.display_buffer = display_get_buffer();
 335:./trace32/udmon3.c **** 
 336:./trace32/udmon3.c **** 	for (i = 0; i < len; i++) {
 337:./trace32/udmon3.c **** 		int lcd_y = (((int)&source[i]-LCD_MEMORY_OFFSET)*8) / 104;   //(NXT_WIDTH/8=100/8=12,5->104/8=13)
 338:./trace32/udmon3.c **** 		int lcd_x = (((int)&source[i]-LCD_MEMORY_OFFSET)*8) - (104*lcd_y);  //Zur Vermeidung von ... % 13
 339:./trace32/udmon3.c **** 		uint8_t *read=&udmon3.display_buffer[((lcd_y/8)*LCD_WIDTH) + lcd_x];
 340:./trace32/udmon3.c **** 		uint8_t  mask=1<<(lcd_y%8);
 341:./trace32/udmon3.c **** 		target[i] = (read[0] & mask ? 0x80 : 0x00) |
 342:./trace32/udmon3.c **** 		            (read[1] & mask ? 0x40 : 0x00) |
 343:./trace32/udmon3.c **** 		            (read[2] & mask ? 0x20 : 0x00) |
 344:./trace32/udmon3.c **** 		            (read[3] & mask ? 0x10 : 0x00) |
 345:./trace32/udmon3.c **** 		            (read[4] & mask ? 0x08 : 0x00) |
 346:./trace32/udmon3.c **** 		            (read[5] & mask ? 0x04 : 0x00) |
 347:./trace32/udmon3.c **** 		            (read[6] & mask ? 0x02 : 0x00) |
 348:./trace32/udmon3.c **** 		            (read[7] & mask ? 0x01 : 0x00);
 349:./trace32/udmon3.c **** 	}
 350:./trace32/udmon3.c ****   }
 351:./trace32/udmon3.c ****   else
 352:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 744              		.loc 1 352 16 is_stmt 1 discriminator 1
 745 001c 000052E3 		cmp	r2, #0
 746 0020 012042C2 		subgt	r2, r2, #1
 747              	.LVL10:
 748 0024 013041C2 		subgt	r3, r1, #1
 749 0028 010040C2 		subgt	r0, r0, #1
 750              	.LVL11:
 751 002c 012082C0 		addgt	r2, r2, r1
 752 0030 030000DA 		ble	.L42
 753              	.LVL12:
 754              	.L49:
 353:./trace32/udmon3.c **** 		target[i] = source[i];
 755              		.loc 1 353 3
 756              		.loc 1 353 21 is_stmt 0
 757 0034 0110F3E5 		ldrb	r1, [r3, #1]!	@ zero_extendqisi2
 758              	.LVL13:
 352:./trace32/udmon3.c **** 		target[i] = source[i];
 759              		.loc 1 352 16 discriminator 1
 760 0038 020053E1 		cmp	r3, r2
 761              		.loc 1 353 13
 762 003c 0110E0E5 		strb	r1, [r0, #1]!
 352:./trace32/udmon3.c **** 		target[i] = source[i];
 763              		.loc 1 352 24 is_stmt 1 discriminator 3
 764              	.LVL14:
 352:./trace32/udmon3.c **** 		target[i] = source[i];
 765              		.loc 1 352 16 discriminator 1
 766 0040 FBFFFF1A 		bne	.L49
 767              	.LVL15:
 768              	.L42:
 354:./trace32/udmon3.c **** }
 769              		.loc 1 354 1 is_stmt 0
 770 0044 08D08DE2 		add	sp, sp, #8
 771              		.cfi_remember_state
 772              		.cfi_def_cfa_offset 32
 773              		@ sp needed
 774 0048 F047BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 775              		.cfi_restore 14
 776              		.cfi_restore 10
 777              		.cfi_restore 9
 778              		.cfi_restore 8
 779              		.cfi_restore 7
 780              		.cfi_restore 6
 781              		.cfi_restore 5
 782              		.cfi_restore 4
 783              		.cfi_def_cfa_offset 0
 784              	.LVL16:
 785 004c 1EFF2FE1 		bx	lr
 786              	.LVL17:
 787              	.L43:
 788              		.cfi_restore_state
 333:./trace32/udmon3.c **** 		udmon3.display_buffer = display_get_buffer();
 789              		.loc 1 333 11
 790 0050 44719FE5 		ldr	r7, .L54
 333:./trace32/udmon3.c **** 		udmon3.display_buffer = display_get_buffer();
 791              		.loc 1 333 4
 792 0054 103097E5 		ldr	r3, [r7, #16]
 793 0058 000053E3 		cmp	r3, #0
 794 005c 0140A0E1 		mov	r4, r1
 333:./trace32/udmon3.c **** 		udmon3.display_buffer = display_get_buffer();
 795              		.loc 1 333 2 is_stmt 1
 333:./trace32/udmon3.c **** 		udmon3.display_buffer = display_get_buffer();
 796              		.loc 1 333 4 is_stmt 0
 797 0060 4600000A 		beq	.L53
 798              	.LVL18:
 799              	.L46:
 336:./trace32/udmon3.c **** 		int lcd_y = (((int)&source[i]-LCD_MEMORY_OFFSET)*8) / 104;   //(NXT_WIDTH/8=100/8=12,5->104/8=13)
 800              		.loc 1 336 16 is_stmt 1 discriminator 1
 801 0064 000052E3 		cmp	r2, #0
 802 0068 F5FFFFDA 		ble	.L42
 803              	.LBB2:
 340:./trace32/udmon3.c **** 		target[i] = (read[0] & mask ? 0x80 : 0x00) |
 804              		.loc 1 340 18 is_stmt 0
 805 006c 0190A0E3 		mov	r9, #1
 806 0070 016042E2 		sub	r6, r2, #1
 807 0074 063085E0 		add	r3, r5, r6
 337:./trace32/udmon3.c **** 		int lcd_x = (((int)&source[i]-LCD_MEMORY_OFFSET)*8) - (104*lcd_y);  //Zur Vermeidung von ... % 13
 808              		.loc 1 337 7
 809 0078 20A19FE5 		ldr	r10, .L54+4
 810 007c 04308DE5 		str	r3, [sp, #4]
 811 0080 011045E2 		sub	r1, r5, #1
 812              	.LVL19:
 813              	.L47:
 337:./trace32/udmon3.c **** 		int lcd_x = (((int)&source[i]-LCD_MEMORY_OFFSET)*8) - (104*lcd_y);  //Zur Vermeidung von ... % 13
 814              		.loc 1 337 3 is_stmt 1
 337:./trace32/udmon3.c **** 		int lcd_x = (((int)&source[i]-LCD_MEMORY_OFFSET)*8) - (104*lcd_y);  //Zur Vermeidung von ... % 13
 815              		.loc 1 337 32 is_stmt 0
 816 0084 0FE284E2 		add	lr, r4, #-268435456
 337:./trace32/udmon3.c **** 		int lcd_x = (((int)&source[i]-LCD_MEMORY_OFFSET)*8) - (104*lcd_y);  //Zur Vermeidung von ... % 13
 817              		.loc 1 337 7
 818 0088 9A3ECCE0 		smull	r3, ip, r10, lr
 819 008c CE3FA0E1 		asr	r3, lr, #31
 820 0090 4C2163E0 		rsb	r2, r3, ip, asr #2
 821              	.LVL20:
 338:./trace32/udmon3.c **** 		uint8_t *read=&udmon3.display_buffer[((lcd_y/8)*LCD_WIDTH) + lcd_x];
 822              		.loc 1 338 3 is_stmt 1
 339:./trace32/udmon3.c **** 		uint8_t  mask=1<<(lcd_y%8);
 823              		.loc 1 339 3
 338:./trace32/udmon3.c **** 		uint8_t *read=&udmon3.display_buffer[((lcd_y/8)*LCD_WIDTH) + lcd_x];
 824              		.loc 1 338 55 is_stmt 0
 825 0094 020E62E0 		rsb	r0, r2, r2, lsl #28
 339:./trace32/udmon3.c **** 		uint8_t  mask=1<<(lcd_y%8);
 826              		.loc 1 339 47
 827 0098 CC3263E0 		rsb	r3, r3, ip, asr #5
 338:./trace32/udmon3.c **** 		uint8_t *read=&udmon3.display_buffer[((lcd_y/8)*LCD_WIDTH) + lcd_x];
 828              		.loc 1 338 55
 829 009c 800182E0 		add	r0, r2, r0, lsl #3
 339:./trace32/udmon3.c **** 		uint8_t  mask=1<<(lcd_y%8);
 830              		.loc 1 339 50
 831 00a0 033183E0 		add	r3, r3, r3, lsl #2
 338:./trace32/udmon3.c **** 		uint8_t *read=&udmon3.display_buffer[((lcd_y/8)*LCD_WIDTH) + lcd_x];
 832              		.loc 1 338 55
 833 00a4 800082E0 		add	r0, r2, r0, lsl #1
 339:./trace32/udmon3.c **** 		uint8_t  mask=1<<(lcd_y%8);
 834              		.loc 1 339 50
 835 00a8 033183E0 		add	r3, r3, r3, lsl #2
 339:./trace32/udmon3.c **** 		uint8_t  mask=1<<(lcd_y%8);
 836              		.loc 1 339 12
 837 00ac 10C097E5 		ldr	ip, [r7, #16]
 338:./trace32/udmon3.c **** 		uint8_t *read=&udmon3.display_buffer[((lcd_y/8)*LCD_WIDTH) + lcd_x];
 838              		.loc 1 338 55
 839 00b0 0E0080E0 		add	r0, r0, lr
 339:./trace32/udmon3.c **** 		uint8_t  mask=1<<(lcd_y%8);
 840              		.loc 1 339 50
 841 00b4 0331A0E1 		lsl	r3, r3, #2
 339:./trace32/udmon3.c **** 		uint8_t  mask=1<<(lcd_y%8);
 842              		.loc 1 339 62
 843 00b8 803183E0 		add	r3, r3, r0, lsl #3
 339:./trace32/udmon3.c **** 		uint8_t  mask=1<<(lcd_y%8);
 844              		.loc 1 339 12
 845 00bc 03008CE0 		add	r0, ip, r3
 846              	.LVL21:
 340:./trace32/udmon3.c **** 		target[i] = (read[0] & mask ? 0x80 : 0x00) |
 847              		.loc 1 340 3 is_stmt 1
 342:./trace32/udmon3.c **** 		            (read[2] & mask ? 0x20 : 0x00) |
 848              		.loc 1 342 31 is_stmt 0
 849 00c0 01E0D0E5 		ldrb	lr, [r0, #1]	@ zero_extendqisi2
 850              	.LVL22:
 340:./trace32/udmon3.c **** 		target[i] = (read[0] & mask ? 0x80 : 0x00) |
 851              		.loc 1 340 18
 852 00c4 072002E2 		and	r2, r2, #7
 853              	.LVL23:
 854 00c8 1922A0E1 		lsl	r2, r9, r2
 855              	.LVL24:
 341:./trace32/udmon3.c **** 		            (read[1] & mask ? 0x40 : 0x00) |
 856              		.loc 1 341 3 is_stmt 1
 341:./trace32/udmon3.c **** 		            (read[1] & mask ? 0x40 : 0x00) |
 857              		.loc 1 341 31 is_stmt 0
 858 00cc 0330DCE7 		ldrb	r3, [ip, r3]	@ zero_extendqisi2
 341:./trace32/udmon3.c **** 		            (read[1] & mask ? 0x40 : 0x00) |
 859              		.loc 1 341 46 discriminator 4
 860 00d0 0E0012E1 		tst	r2, lr
 861 00d4 0180A013 		movne	r8, #1
 862 00d8 0080A003 		moveq	r8, #0
 341:./trace32/udmon3.c **** 		            (read[1] & mask ? 0x40 : 0x00) |
 863              		.loc 1 341 46
 864 00dc 030012E1 		tst	r2, r3
 865 00e0 0130A013 		movne	r3, #1
 866 00e4 0030A003 		moveq	r3, #0
 348:./trace32/udmon3.c **** 	}
 867              		.loc 1 348 38
 868 00e8 07C0D0E5 		ldrb	ip, [r0, #7]	@ zero_extendqisi2
 343:./trace32/udmon3.c **** 		            (read[3] & mask ? 0x10 : 0x00) |
 869              		.loc 1 343 31
 870 00ec 0260D0E5 		ldrb	r6, [r0, #2]	@ zero_extendqisi2
 341:./trace32/udmon3.c **** 		            (read[1] & mask ? 0x40 : 0x00) |
 871              		.loc 1 341 46
 872 00f0 8333A0E1 		lsl	r3, r3, #7
 344:./trace32/udmon3.c **** 		            (read[4] & mask ? 0x08 : 0x00) |
 873              		.loc 1 344 31
 874 00f4 0350D0E5 		ldrb	r5, [r0, #3]	@ zero_extendqisi2
 348:./trace32/udmon3.c **** 	}
 875              		.loc 1 348 38
 876 00f8 0C0012E1 		tst	r2, ip
 347:./trace32/udmon3.c **** 		            (read[7] & mask ? 0x01 : 0x00);
 877              		.loc 1 347 46
 878 00fc 083383E1 		orr	r3, r3, r8, lsl #6
 345:./trace32/udmon3.c **** 		            (read[5] & mask ? 0x04 : 0x00) |
 879              		.loc 1 345 31
 880 0100 04E0D0E5 		ldrb	lr, [r0, #4]	@ zero_extendqisi2
 347:./trace32/udmon3.c **** 		            (read[7] & mask ? 0x01 : 0x00);
 881              		.loc 1 347 46
 882 0104 01308313 		orrne	r3, r3, #1
 342:./trace32/udmon3.c **** 		            (read[2] & mask ? 0x20 : 0x00) |
 883              		.loc 1 342 46
 884 0108 060012E1 		tst	r2, r6
 346:./trace32/udmon3.c **** 		            (read[6] & mask ? 0x02 : 0x00) |
 885              		.loc 1 346 31
 886 010c 05C0D0E5 		ldrb	ip, [r0, #5]	@ zero_extendqisi2
 342:./trace32/udmon3.c **** 		            (read[2] & mask ? 0x20 : 0x00) |
 887              		.loc 1 342 46
 888 0110 0160A013 		movne	r6, #1
 889 0114 0060A003 		moveq	r6, #0
 343:./trace32/udmon3.c **** 		            (read[3] & mask ? 0x10 : 0x00) |
 890              		.loc 1 343 46
 891 0118 050012E1 		tst	r2, r5
 892 011c 0150A013 		movne	r5, #1
 893 0120 0050A003 		moveq	r5, #0
 347:./trace32/udmon3.c **** 		            (read[7] & mask ? 0x01 : 0x00);
 894              		.loc 1 347 31
 895 0124 0600D0E5 		ldrb	r0, [r0, #6]	@ zero_extendqisi2
 896              	.LVL25:
 344:./trace32/udmon3.c **** 		            (read[4] & mask ? 0x08 : 0x00) |
 897              		.loc 1 344 46
 898 0128 0E0012E1 		tst	r2, lr
 899 012c 01E0A013 		movne	lr, #1
 900 0130 00E0A003 		moveq	lr, #0
 345:./trace32/udmon3.c **** 		            (read[5] & mask ? 0x04 : 0x00) |
 901              		.loc 1 345 46
 902 0134 0C0012E1 		tst	r2, ip
 903 0138 01C0A013 		movne	ip, #1
 904 013c 00C0A003 		moveq	ip, #0
 346:./trace32/udmon3.c **** 		            (read[6] & mask ? 0x02 : 0x00) |
 905              		.loc 1 346 46
 906 0140 000012E1 		tst	r2, r0
 907 0144 0120A013 		movne	r2, #1
 908              	.LVL26:
 909 0148 0020A003 		moveq	r2, #0
 347:./trace32/udmon3.c **** 		            (read[7] & mask ? 0x01 : 0x00);
 910              		.loc 1 347 46
 911 014c 863283E1 		orr	r3, r3, r6, lsl #5
 912 0150 053283E1 		orr	r3, r3, r5, lsl #4
 913 0154 8E3183E1 		orr	r3, r3, lr, lsl #3
 914 0158 0C3183E1 		orr	r3, r3, ip, lsl #2
 915 015c 823083E1 		orr	r3, r3, r2, lsl #1
 341:./trace32/udmon3.c **** 		            (read[1] & mask ? 0x40 : 0x00) |
 916              		.loc 1 341 13
 917 0160 0130E1E5 		strb	r3, [r1, #1]!
 918              	.LVL27:
 919              	.LBE2:
 336:./trace32/udmon3.c **** 		int lcd_y = (((int)&source[i]-LCD_MEMORY_OFFSET)*8) / 104;   //(NXT_WIDTH/8=100/8=12,5->104/8=13)
 920              		.loc 1 336 24 is_stmt 1 discriminator 2
 336:./trace32/udmon3.c **** 		int lcd_y = (((int)&source[i]-LCD_MEMORY_OFFSET)*8) / 104;   //(NXT_WIDTH/8=100/8=12,5->104/8=13)
 921              		.loc 1 336 16 discriminator 1
 922 0164 04309DE5 		ldr	r3, [sp, #4]
 923 0168 030051E1 		cmp	r1, r3
 924 016c 014084E2 		add	r4, r4, #1
 925              	.LVL28:
 926 0170 C3FFFF1A 		bne	.L47
 927              		.loc 1 354 1 is_stmt 0
 928 0174 08D08DE2 		add	sp, sp, #8
 929              		.cfi_remember_state
 930              		.cfi_def_cfa_offset 32
 931              		@ sp needed
 932 0178 F047BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 933              		.cfi_restore 14
 934              		.cfi_restore 10
 935              		.cfi_restore 9
 936              		.cfi_restore 8
 937              		.cfi_restore 7
 938              		.cfi_restore 6
 939              		.cfi_restore 5
 940              		.cfi_restore 4
 941              		.cfi_def_cfa_offset 0
 942              	.LVL29:
 943 017c 1EFF2FE1 		bx	lr
 944              	.LVL30:
 945              	.L53:
 946              		.cfi_restore_state
 334:./trace32/udmon3.c **** 
 947              		.loc 1 334 3 is_stmt 1
 334:./trace32/udmon3.c **** 
 948              		.loc 1 334 27 is_stmt 0
 949 0180 1C309FE5 		ldr	r3, .L54+8
 950 0184 04208DE5 		str	r2, [sp, #4]
 951 0188 0FE0A0E1 		mov	lr, pc
 952 018c 13FF2FE1 		bx	r3
 953              	.LVL31:
 954 0190 04209DE5 		ldr	r2, [sp, #4]
 334:./trace32/udmon3.c **** 
 955              		.loc 1 334 25 discriminator 1
 956 0194 100087E5 		str	r0, [r7, #16]
 957 0198 B1FFFFEA 		b	.L46
 958              	.L55:
 959              		.align	2
 960              	.L54:
 961 019c 00000000 		.word	udmon3
 962 01a0 4FECC44E 		.word	1321528399
 963 01a4 00000000 		.word	display_get_buffer
 964              		.cfi_endproc
 965              	.LFE12:
 967              		.section	.text.Monitor_ReadHalf,"ax",%progbits
 968              		.align	2
 969              		.syntax unified
 970              		.arm
 972              	Monitor_ReadHalf:
 973              	.LFB13:
 355:./trace32/udmon3.c **** 
 356:./trace32/udmon3.c **** 
 357:./trace32/udmon3.c **** static void Monitor_ReadHalf (void * buf, void * address, int len)
 358:./trace32/udmon3.c **** {
 974              		.loc 1 358 1 is_stmt 1
 975              		.cfi_startproc
 976              		@ Function supports interworking.
 977              		@ args = 0, pretend = 0, frame = 0
 978              		@ frame_needed = 0, uses_anonymous_args = 0
 979              		@ link register save eliminated.
 980              	.LVL32:
 359:./trace32/udmon3.c ****   int i;
 981              		.loc 1 359 3
 360:./trace32/udmon3.c ****   unsigned short *source = (unsigned short *) address;
 982              		.loc 1 360 3
 361:./trace32/udmon3.c ****   unsigned short *target = (unsigned short *) buf;
 983              		.loc 1 361 3
 362:./trace32/udmon3.c **** 
 363:./trace32/udmon3.c ****   if(((int)source & 0xffC00000) == LCD_MEMORY_OFFSET)
 984              		.loc 1 363 3
 985              		.loc 1 363 19 is_stmt 0
 986 0000 213BA0E1 		lsr	r3, r1, #22
 987 0004 033BA0E1 		lsl	r3, r3, #22
 988              		.loc 1 363 5
 989 0008 010253E3 		cmp	r3, #268435456
 990 000c 0A00000A 		beq	.L57
 991              	.LVL33:
 364:./trace32/udmon3.c ****   {
 365:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 366:./trace32/udmon3.c **** 		target[i] = 0x55;
 367:./trace32/udmon3.c ****   }
 368:./trace32/udmon3.c ****   else
 369:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 992              		.loc 1 369 16 is_stmt 1 discriminator 1
 993 0010 000052E3 		cmp	r2, #0
 994 0014 1EFF2FD1 		bxle	lr
 995 0018 823081E0 		add	r3, r1, r2, lsl #1
 996 001c 020040E2 		sub	r0, r0, #2
 997              	.LVL34:
 998 0020 021041E2 		sub	r1, r1, #2
 999              	.LVL35:
 1000 0024 023043E2 		sub	r3, r3, #2
 1001              	.LVL36:
 1002              	.L61:
 370:./trace32/udmon3.c **** 		target[i] = source[i];
 1003              		.loc 1 370 3
 1004              		.loc 1 370 21 is_stmt 0
 1005 0028 B220F1E1 		ldrh	r2, [r1, #2]!
 369:./trace32/udmon3.c **** 		target[i] = source[i];
 1006              		.loc 1 369 16 discriminator 1
 1007 002c 030051E1 		cmp	r1, r3
 1008              		.loc 1 370 13
 1009 0030 B220E0E1 		strh	r2, [r0, #2]!	@ movhi
 369:./trace32/udmon3.c **** 		target[i] = source[i];
 1010              		.loc 1 369 24 is_stmt 1 discriminator 3
 369:./trace32/udmon3.c **** 		target[i] = source[i];
 1011              		.loc 1 369 16 discriminator 1
 1012 0034 FBFFFF1A 		bne	.L61
 1013 0038 1EFF2FE1 		bx	lr
 1014              	.LVL37:
 1015              	.L57:
 365:./trace32/udmon3.c **** 		target[i] = 0x55;
 1016              		.loc 1 365 16 discriminator 1
 1017 003c 000052E3 		cmp	r2, #0
 1018 0040 1EFF2FD1 		bxle	lr
 366:./trace32/udmon3.c ****   }
 1019              		.loc 1 366 13 is_stmt 0
 1020 0044 5510A0E3 		mov	r1, #85
 1021              	.LVL38:
 1022 0048 823080E0 		add	r3, r0, r2, lsl #1
 1023 004c 023043E2 		sub	r3, r3, #2
 1024 0050 020040E2 		sub	r0, r0, #2
 1025              	.LVL39:
 1026              	.L60:
 366:./trace32/udmon3.c ****   }
 1027              		.loc 1 366 3 is_stmt 1
 366:./trace32/udmon3.c ****   }
 1028              		.loc 1 366 13 is_stmt 0
 1029 0054 B210E0E1 		strh	r1, [r0, #2]!	@ movhi
 365:./trace32/udmon3.c **** 		target[i] = 0x55;
 1030              		.loc 1 365 24 is_stmt 1 discriminator 3
 365:./trace32/udmon3.c **** 		target[i] = 0x55;
 1031              		.loc 1 365 16 discriminator 1
 1032 0058 030050E1 		cmp	r0, r3
 1033 005c FCFFFF1A 		bne	.L60
 1034 0060 1EFF2FE1 		bx	lr
 1035              		.cfi_endproc
 1036              	.LFE13:
 1038              		.section	.text.Monitor_ReadWord,"ax",%progbits
 1039              		.align	2
 1040              		.syntax unified
 1041              		.arm
 1043              	Monitor_ReadWord:
 1044              	.LFB14:
 371:./trace32/udmon3.c **** }
 372:./trace32/udmon3.c **** 
 373:./trace32/udmon3.c **** 
 374:./trace32/udmon3.c **** static void Monitor_ReadWord (void * buf, void * address, int len)
 375:./trace32/udmon3.c **** {
 1045              		.loc 1 375 1
 1046              		.cfi_startproc
 1047              		@ Function supports interworking.
 1048              		@ args = 0, pretend = 0, frame = 0
 1049              		@ frame_needed = 0, uses_anonymous_args = 0
 1050              		@ link register save eliminated.
 1051              	.LVL40:
 376:./trace32/udmon3.c ****   int i;
 1052              		.loc 1 376 3
 377:./trace32/udmon3.c ****   unsigned int *source = (unsigned int *) address;
 1053              		.loc 1 377 3
 378:./trace32/udmon3.c ****   unsigned int *target = (unsigned int *) buf;
 1054              		.loc 1 378 3
 379:./trace32/udmon3.c **** 
 380:./trace32/udmon3.c ****   if(((int)source & 0xffC00000) == LCD_MEMORY_OFFSET)
 1055              		.loc 1 380 3
 1056              		.loc 1 380 19 is_stmt 0
 1057 0000 213BA0E1 		lsr	r3, r1, #22
 1058 0004 033BA0E1 		lsl	r3, r3, #22
 1059              		.loc 1 380 5
 1060 0008 010253E3 		cmp	r3, #268435456
 1061 000c 0A00000A 		beq	.L67
 1062              	.LVL41:
 381:./trace32/udmon3.c ****   {
 382:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 383:./trace32/udmon3.c **** 		target[i] = 0xAA;
 384:./trace32/udmon3.c ****   }
 385:./trace32/udmon3.c ****   else
 386:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1063              		.loc 1 386 16 is_stmt 1 discriminator 1
 1064 0010 000052E3 		cmp	r2, #0
 1065 0014 1EFF2FD1 		bxle	lr
 1066 0018 023181E0 		add	r3, r1, r2, lsl #2
 1067 001c 040040E2 		sub	r0, r0, #4
 1068              	.LVL42:
 1069 0020 041041E2 		sub	r1, r1, #4
 1070              	.LVL43:
 1071 0024 043043E2 		sub	r3, r3, #4
 1072              	.LVL44:
 1073              	.L71:
 387:./trace32/udmon3.c **** 		target[i] = source[i];
 1074              		.loc 1 387 3
 1075              		.loc 1 387 21 is_stmt 0
 1076 0028 0420B1E5 		ldr	r2, [r1, #4]!
 386:./trace32/udmon3.c **** 		target[i] = source[i];
 1077              		.loc 1 386 16 discriminator 1
 1078 002c 030051E1 		cmp	r1, r3
 1079              		.loc 1 387 13
 1080 0030 0420A0E5 		str	r2, [r0, #4]!
 386:./trace32/udmon3.c **** 		target[i] = source[i];
 1081              		.loc 1 386 24 is_stmt 1 discriminator 3
 386:./trace32/udmon3.c **** 		target[i] = source[i];
 1082              		.loc 1 386 16 discriminator 1
 1083 0034 FBFFFF1A 		bne	.L71
 1084 0038 1EFF2FE1 		bx	lr
 1085              	.LVL45:
 1086              	.L67:
 382:./trace32/udmon3.c **** 		target[i] = 0xAA;
 1087              		.loc 1 382 16 discriminator 1
 1088 003c 000052E3 		cmp	r2, #0
 1089 0040 1EFF2FD1 		bxle	lr
 383:./trace32/udmon3.c ****   }
 1090              		.loc 1 383 13 is_stmt 0
 1091 0044 AA10A0E3 		mov	r1, #170
 1092              	.LVL46:
 1093 0048 023180E0 		add	r3, r0, r2, lsl #2
 1094 004c 043043E2 		sub	r3, r3, #4
 1095 0050 040040E2 		sub	r0, r0, #4
 1096              	.LVL47:
 1097              	.L70:
 383:./trace32/udmon3.c ****   }
 1098              		.loc 1 383 3 is_stmt 1
 383:./trace32/udmon3.c ****   }
 1099              		.loc 1 383 13 is_stmt 0
 1100 0054 0410A0E5 		str	r1, [r0, #4]!
 382:./trace32/udmon3.c **** 		target[i] = 0xAA;
 1101              		.loc 1 382 24 is_stmt 1 discriminator 3
 382:./trace32/udmon3.c **** 		target[i] = 0xAA;
 1102              		.loc 1 382 16 discriminator 1
 1103 0058 030050E1 		cmp	r0, r3
 1104 005c FCFFFF1A 		bne	.L70
 1105 0060 1EFF2FE1 		bx	lr
 1106              		.cfi_endproc
 1107              	.LFE14:
 1109              		.section	.text.Monitor_WriteByte,"ax",%progbits
 1110              		.align	2
 1111              		.syntax unified
 1112              		.arm
 1114              	Monitor_WriteByte:
 1115              	.LFB15:
 388:./trace32/udmon3.c **** 		
 389:./trace32/udmon3.c **** }
 390:./trace32/udmon3.c **** 
 391:./trace32/udmon3.c **** static void Monitor_WriteByte (void * buf, void * address, int len)
 392:./trace32/udmon3.c **** {
 1116              		.loc 1 392 1
 1117              		.cfi_startproc
 1118              		@ Function supports interworking.
 1119              		@ args = 0, pretend = 0, frame = 0
 1120              		@ frame_needed = 0, uses_anonymous_args = 0
 1121              		@ link register save eliminated.
 1122              	.LVL48:
 393:./trace32/udmon3.c ****   int i;
 1123              		.loc 1 393 3
 394:./trace32/udmon3.c ****   unsigned char *source = (unsigned char *) address;
 1124              		.loc 1 394 3
 395:./trace32/udmon3.c ****   unsigned char *target = (unsigned char *) buf;
 1125              		.loc 1 395 3
 396:./trace32/udmon3.c **** 
 397:./trace32/udmon3.c ****   if(!((int)target & 0xffC00000))
 1126              		.loc 1 397 3
 1127              		.loc 1 397 5 is_stmt 0
 1128 0000 010550E3 		cmp	r0, #4194304
 1129 0004 1EFF2F21 		bxcs	lr
 1130              	.LVL49:
 398:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1131              		.loc 1 398 16 is_stmt 1 discriminator 1
 1132 0008 000052E3 		cmp	r2, #0
 1133 000c 1EFF2FD1 		bxle	lr
 1134 0010 012042E2 		sub	r2, r2, #1
 1135              	.LVL50:
 1136 0014 013041E2 		sub	r3, r1, #1
 1137 0018 010040E2 		sub	r0, r0, #1
 1138              	.LVL51:
 1139 001c 021081E0 		add	r1, r1, r2
 1140              	.LVL52:
 1141              	.L78:
 399:./trace32/udmon3.c **** 		target[i] = source[i];
 1142              		.loc 1 399 3
 1143              		.loc 1 399 21 is_stmt 0
 1144 0020 0120F3E5 		ldrb	r2, [r3, #1]!	@ zero_extendqisi2
 1145              	.LVL53:
 398:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1146              		.loc 1 398 16 discriminator 1
 1147 0024 010053E1 		cmp	r3, r1
 1148              		.loc 1 399 13
 1149 0028 0120E0E5 		strb	r2, [r0, #1]!
 398:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1150              		.loc 1 398 24 is_stmt 1 discriminator 3
 1151              	.LVL54:
 398:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1152              		.loc 1 398 16 discriminator 1
 1153 002c FBFFFF1A 		bne	.L78
 1154 0030 1EFF2FE1 		bx	lr
 1155              		.cfi_endproc
 1156              	.LFE15:
 1158              		.section	.text.Monitor_WriteHalf,"ax",%progbits
 1159              		.align	2
 1160              		.syntax unified
 1161              		.arm
 1163              	Monitor_WriteHalf:
 1164              	.LFB16:
 400:./trace32/udmon3.c **** }
 401:./trace32/udmon3.c **** 
 402:./trace32/udmon3.c **** static void Monitor_WriteHalf (void * buf, void * address, int len)
 403:./trace32/udmon3.c **** {
 1165              		.loc 1 403 1
 1166              		.cfi_startproc
 1167              		@ Function supports interworking.
 1168              		@ args = 0, pretend = 0, frame = 0
 1169              		@ frame_needed = 0, uses_anonymous_args = 0
 1170              		@ link register save eliminated.
 1171              	.LVL55:
 404:./trace32/udmon3.c ****   int i;
 1172              		.loc 1 404 3
 405:./trace32/udmon3.c ****   unsigned short *source = (unsigned short *) address;
 1173              		.loc 1 405 3
 406:./trace32/udmon3.c ****   unsigned short *target = (unsigned short *) buf;
 1174              		.loc 1 406 3
 407:./trace32/udmon3.c **** 
 408:./trace32/udmon3.c ****   if(!((int)target & 0xffC00000))
 1175              		.loc 1 408 3
 1176              		.loc 1 408 5 is_stmt 0
 1177 0000 010550E3 		cmp	r0, #4194304
 1178 0004 1EFF2F21 		bxcs	lr
 1179              	.LVL56:
 409:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1180              		.loc 1 409 16 is_stmt 1 discriminator 1
 1181 0008 000052E3 		cmp	r2, #0
 1182 000c 1EFF2FD1 		bxle	lr
 1183 0010 822081E0 		add	r2, r1, r2, lsl #1
 1184              	.LVL57:
 1185 0014 020040E2 		sub	r0, r0, #2
 1186              	.LVL58:
 1187 0018 021041E2 		sub	r1, r1, #2
 1188              	.LVL59:
 1189 001c 023042E2 		sub	r3, r2, #2
 1190              	.LVL60:
 1191              	.L82:
 410:./trace32/udmon3.c **** 		target[i] = source[i];
 1192              		.loc 1 410 3
 1193              		.loc 1 410 21 is_stmt 0
 1194 0020 B220F1E1 		ldrh	r2, [r1, #2]!
 409:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1195              		.loc 1 409 16 discriminator 1
 1196 0024 030051E1 		cmp	r1, r3
 1197              		.loc 1 410 13
 1198 0028 B220E0E1 		strh	r2, [r0, #2]!	@ movhi
 409:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1199              		.loc 1 409 24 is_stmt 1 discriminator 3
 409:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1200              		.loc 1 409 16 discriminator 1
 1201 002c FBFFFF1A 		bne	.L82
 1202 0030 1EFF2FE1 		bx	lr
 1203              		.cfi_endproc
 1204              	.LFE16:
 1206              		.section	.text.Monitor_WriteWord,"ax",%progbits
 1207              		.align	2
 1208              		.syntax unified
 1209              		.arm
 1211              	Monitor_WriteWord:
 1212              	.LFB17:
 411:./trace32/udmon3.c **** }
 412:./trace32/udmon3.c **** 
 413:./trace32/udmon3.c **** static void Monitor_WriteWord (void * buf, void * address, int len)
 414:./trace32/udmon3.c **** {
 1213              		.loc 1 414 1
 1214              		.cfi_startproc
 1215              		@ Function supports interworking.
 1216              		@ args = 0, pretend = 0, frame = 0
 1217              		@ frame_needed = 0, uses_anonymous_args = 0
 1218              		@ link register save eliminated.
 1219              	.LVL61:
 415:./trace32/udmon3.c ****   int i;
 1220              		.loc 1 415 3
 416:./trace32/udmon3.c ****   unsigned int *source = (unsigned int *) address;
 1221              		.loc 1 416 3
 417:./trace32/udmon3.c ****   unsigned int *target = (unsigned int *) buf;
 1222              		.loc 1 417 3
 418:./trace32/udmon3.c **** 
 419:./trace32/udmon3.c ****   if(!((int)target & 0xffC00000))
 1223              		.loc 1 419 3
 1224              		.loc 1 419 5 is_stmt 0
 1225 0000 010550E3 		cmp	r0, #4194304
 1226 0004 1EFF2F21 		bxcs	lr
 1227              	.LVL62:
 420:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1228              		.loc 1 420 16 is_stmt 1 discriminator 1
 1229 0008 000052E3 		cmp	r2, #0
 1230 000c 1EFF2FD1 		bxle	lr
 1231 0010 022181E0 		add	r2, r1, r2, lsl #2
 1232              	.LVL63:
 1233 0014 040040E2 		sub	r0, r0, #4
 1234              	.LVL64:
 1235 0018 041041E2 		sub	r1, r1, #4
 1236              	.LVL65:
 1237 001c 043042E2 		sub	r3, r2, #4
 1238              	.LVL66:
 1239              	.L86:
 421:./trace32/udmon3.c **** 		target[i] = source[i];
 1240              		.loc 1 421 3
 1241              		.loc 1 421 21 is_stmt 0
 1242 0020 0420B1E5 		ldr	r2, [r1, #4]!
 420:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1243              		.loc 1 420 16 discriminator 1
 1244 0024 030051E1 		cmp	r1, r3
 1245              		.loc 1 421 13
 1246 0028 0420A0E5 		str	r2, [r0, #4]!
 420:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1247              		.loc 1 420 24 is_stmt 1 discriminator 3
 420:./trace32/udmon3.c **** 	for (i = 0; i < len; i++)
 1248              		.loc 1 420 16 discriminator 1
 1249 002c FBFFFF1A 		bne	.L86
 1250 0030 1EFF2FE1 		bx	lr
 1251              		.cfi_endproc
 1252              	.LFE17:
 1254              		.section	.text.udmon3_receive,"ax",%progbits
 1255              		.align	2
 1256              		.syntax unified
 1257              		.arm
 1259              	udmon3_receive:
 1260              	.LFB18:
 422:./trace32/udmon3.c **** }
 423:./trace32/udmon3.c **** #endif
 424:./trace32/udmon3.c **** 
 425:./trace32/udmon3.c **** /**************************************************************************
 426:./trace32/udmon3.c **** 
 427:./trace32/udmon3.c ****   Monitor
 428:./trace32/udmon3.c **** 
 429:./trace32/udmon3.c ****   When you put in your application make sure the Monitor_Handler() will be
 430:./trace32/udmon3.c ****   called periodically.
 431:./trace32/udmon3.c **** 
 432:./trace32/udmon3.c ****   Please note that also the monitor itself calls the Monitor_Handler().
 433:./trace32/udmon3.c ****   The monitor will fail if you try to debug this function, especially if
 434:./trace32/udmon3.c ****   you place software breakpoints there or if you single-step into this
 435:./trace32/udmon3.c ****   function or if you try to restart from an on-chip breakpoint in this function.
 436:./trace32/udmon3.c **** 
 437:./trace32/udmon3.c **** 	TSMON, UDMON:
 438:./trace32/udmon3.c **** 	The call is typically included in a periodic interrupt or in the idle
 439:./trace32/udmon3.c **** 	task of the kernel.
 440:./trace32/udmon3.c **** 	
 441:./trace32/udmon3.c **** 	PTMON: 
 442:./trace32/udmon3.c **** 	The call is typically included in the interrupt service routine which 
 443:./trace32/udmon3.c **** 	will be triggered by the trigger output signal coming from the debugger.
 444:./trace32/udmon3.c **** 
 445:./trace32/udmon3.c **** **************************************************************************/
 446:./trace32/udmon3.c **** 
 447:./trace32/udmon3.c **** // Receive data from debugger via DCC channel
 448:./trace32/udmon3.c **** static inline void udmon3_receive(void)
 449:./trace32/udmon3.c **** {
 1261              		.loc 1 449 1
 1262              		.cfi_startproc
 1263              		@ Function supports interworking.
 1264              		@ args = 0, pretend = 0, frame = 0
 1265              		@ frame_needed = 0, uses_anonymous_args = 0
 450:./trace32/udmon3.c ****     unsigned int data;
 1266              		.loc 1 450 5
 451:./trace32/udmon3.c **** 	#ifdef MODE_RAM
 452:./trace32/udmon3.c **** 			   int index;
 1267              		.loc 1 452 7
 453:./trace32/udmon3.c **** 			   int len;
 1268              		.loc 1 453 7
 454:./trace32/udmon3.c **** 	  unsigned int address;
 1269              		.loc 1 454 4
 455:./trace32/udmon3.c **** 	#endif
 456:./trace32/udmon3.c ****     data = DCC_ReceiveWord();
 1270              		.loc 1 456 5
 1271              	.LBB3:
 1272              		.loc 1 456 12
 1273              		.loc 1 456 12
 1274              	.LBE3:
 457:./trace32/udmon3.c **** 
 458:./trace32/udmon3.c ****     switch (data >> 28)
 1275              		.loc 1 458 5 is_stmt 0
 1276 0000 AC229FE5 		ldr	r2, .L110
 449:./trace32/udmon3.c ****     unsigned int data;
 1277              		.loc 1 449 1
 1278 0004 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 1279              		.cfi_def_cfa_offset 24
 1280              		.cfi_offset 4, -24
 1281              		.cfi_offset 5, -20
 1282              		.cfi_offset 6, -16
 1283              		.cfi_offset 7, -12
 1284              		.cfi_offset 8, -8
 1285              		.cfi_offset 14, -4
 1286              	.LBB4:
 456:./trace32/udmon3.c **** 
 1287              		.loc 1 456 12
 1288              		.syntax divided
 1289              	@ 456 "./trace32/udmon3.c" 1
 1290 0008 104E11EE 		mrc p14, 0, r4, c1, c0
 1291              	@ 0 "" 2
 1292              	.LVL67:
 456:./trace32/udmon3.c **** 
 1293              		.loc 1 456 12 is_stmt 1
 1294              		.arm
 1295              		.syntax unified
 1296              	.LBE4:
 1297              		.loc 1 458 5
 1298              		.loc 1 458 18 is_stmt 0
 1299 000c 243EA0E1 		lsr	r3, r4, #28
 1300              		.loc 1 458 5
 1301 0010 0F0053E3 		cmp	r3, #15
 1302 0014 0D00008A 		bhi	.L88
 1303 0018 0330D2E7 		ldrb	r3, [r2, r3]
 1304 001c 03F18FE0 		add	pc, pc, r3, lsl #2
 1305              	.Lrtx91:
 1306 0020 0000A0E1 		nop
 1307              		.section	.rodata
 1308              	.L91:
 1309 0000 1B       		.byte	(.L99-.Lrtx91-4)/4
 1310 0001 2A       		.byte	(.L98-.Lrtx91-4)/4
 1311 0002 3C       		.byte	(.L97-.Lrtx91-4)/4
 1312 0003 4F       		.byte	(.L96-.Lrtx91-4)/4
 1313 0004 62       		.byte	(.L95-.Lrtx91-4)/4
 1314 0005 71       		.byte	(.L94-.Lrtx91-4)/4
 1315 0006 82       		.byte	(.L93-.Lrtx91-4)/4
 1316 0007 0B       		.byte	(.L88-.Lrtx91-4)/4
 1317 0008 0B       		.byte	(.L88-.Lrtx91-4)/4
 1318 0009 0B       		.byte	(.L88-.Lrtx91-4)/4
 1319 000a 0B       		.byte	(.L88-.Lrtx91-4)/4
 1320 000b 0B       		.byte	(.L88-.Lrtx91-4)/4
 1321 000c 0B       		.byte	(.L88-.Lrtx91-4)/4
 1322 000d 00       		.byte	(.L92-.Lrtx91-4)/4
 1323 000e 0D       		.byte	(.L90-.Lrtx91-4)/4
 1324 000f 0D       		.byte	(.L90-.Lrtx91-4)/4
 1325              		.section	.text.udmon3_receive
 1326              		.p2align 2
 1327              	.L92:
 459:./trace32/udmon3.c ****     {
 460:./trace32/udmon3.c ****       case 0x00:
 461:./trace32/udmon3.c **** 	    if(udmon3.term_recv) {
 462:./trace32/udmon3.c ****           switch (data >> 24) {
 463:./trace32/udmon3.c ****             case 0x00: // reserved for terminal input in DCC3 protocol mode
 464:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>> 0)&0xff));
 465:./trace32/udmon3.c **** 			  break;
 466:./trace32/udmon3.c ****             case 0x01:
 467:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>> 0)&0xff));
 468:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>> 8)&0xff));
 469:./trace32/udmon3.c **** 			  break;
 470:./trace32/udmon3.c ****             case 0x02:
 471:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>> 0)&0xff));
 472:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>> 8)&0xff));
 473:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>>16)&0xff));
 474:./trace32/udmon3.c **** 			  break;
 475:./trace32/udmon3.c ****             case 0x04:
 476:./trace32/udmon3.c ****             case 0x05:
 477:./trace32/udmon3.c ****             case 0x06:
 478:./trace32/udmon3.c ****             case 0x07: // reserved for FDX transfer to buffer in DCC3 protocol mode
 479:./trace32/udmon3.c **** 		    case 0x08: // reserved for PTMON3
 480:./trace32/udmon3.c **** 		    case 0x09: // reserved for PTMON3
 481:./trace32/udmon3.c **** 		    case 0x0F: // reserved for PTMON3
 482:./trace32/udmon3.c **** 			  break;
 483:./trace32/udmon3.c **** 	      }
 484:./trace32/udmon3.c **** 		}
 485:./trace32/udmon3.c **** 
 486:./trace32/udmon3.c **** #ifdef PTMON3
 487:./trace32/udmon3.c ****         switch (data >> 24) {
 488:./trace32/udmon3.c ****           case 0x08: // get monitor data base
 489:./trace32/udmon3.c **** 			udmon3.monitor_index = 0;
 490:./trace32/udmon3.c **** 			udmon3.monitor_count = 4;
 491:./trace32/udmon3.c **** 			udmon3.monitor_buffer[0] = (unsigned int) udmon3.monitor_stackbase;
 492:./trace32/udmon3.c **** 			COMMTX_IRQ_ENABLE();
 493:./trace32/udmon3.c **** 			break;
 494:./trace32/udmon3.c **** 
 495:./trace32/udmon3.c ****           case 0x09: // set monitor data base
 496:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[4 - 1] = (data >> 16) & 0xff;
 497:./trace32/udmon3.c **** 			udmon3.monitor_stackbase = (unsigned int *) udmon3.monitor_buffer[0];
 498:./trace32/udmon3.c **** //Wenn das unterste Bit in dieser Adresse gesetzt wird, muss was gesendet werden
 499:./trace32/udmon3.c **** //			if(*udmon3.monitor_stackbase & 0x0001)
 500:./trace32/udmon3.c **** //				COMMTX_IRQ_ENABLE();
 501:./trace32/udmon3.c **** 			break;
 502:./trace32/udmon3.c **** 
 503:./trace32/udmon3.c ****           case 0x0f: // stop application (on UDMON this is done by a breakpoint range)
 504:./trace32/udmon3.c **** 			break;
 505:./trace32/udmon3.c **** 	    }
 506:./trace32/udmon3.c **** #endif
 507:./trace32/udmon3.c **** 	    break;
 508:./trace32/udmon3.c **** 		
 509:./trace32/udmon3.c **** #ifdef MODE_RAM
 510:./trace32/udmon3.c ****       case 0x01: // 8-bit read access
 511:./trace32/udmon3.c **** 		len = ((data >> 24) & 0x0f) + 1;
 512:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 513:./trace32/udmon3.c **** 		Monitor_ReadByte (udmon3.monitor_buffer, (void *) address, len);
 514:./trace32/udmon3.c **** 		udmon3.monitor_index = 0;
 515:./trace32/udmon3.c **** 		udmon3.monitor_count = len;
 516:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 517:./trace32/udmon3.c **** 		break;
 518:./trace32/udmon3.c ****       case 0x02: // 16-bit read access
 519:./trace32/udmon3.c **** 		len = ((data >> 24) & 0x0f) + 1;
 520:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 521:./trace32/udmon3.c **** 		Monitor_ReadHalf (udmon3.monitor_buffer, (void *) address, len);
 522:./trace32/udmon3.c **** 		udmon3.monitor_index = 0;
 523:./trace32/udmon3.c **** 		udmon3.monitor_count = len * 2;
 524:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 525:./trace32/udmon3.c **** 		break;
 526:./trace32/udmon3.c **** 
 527:./trace32/udmon3.c ****       case 0x03: // 32-bit read access
 528:./trace32/udmon3.c **** 		len = ((data >> 24) & 0x0f) + 1;
 529:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 530:./trace32/udmon3.c **** 		Monitor_ReadWord (udmon3.monitor_buffer, (void *) address, len);
 531:./trace32/udmon3.c **** 		udmon3.monitor_index = 0;
 532:./trace32/udmon3.c **** 		udmon3.monitor_count = len * 4;
 533:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 534:./trace32/udmon3.c **** 		break;
 535:./trace32/udmon3.c **** 
 536:./trace32/udmon3.c ****       case 0x04: // 8-bit write access
 537:./trace32/udmon3.c **** 		len = ((data >> 24) & 0x0f) + 1;
 538:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len - 1] = (data >> 16) & 0xff;
 539:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 540:./trace32/udmon3.c **** 		Monitor_WriteByte ((void *) address, udmon3.monitor_buffer, len);
 541:./trace32/udmon3.c **** 		break;
 542:./trace32/udmon3.c **** 
 543:./trace32/udmon3.c ****       case 0x05: // 16-bit write access
 544:./trace32/udmon3.c **** 		len = ((data >> 24) & 0x0f) + 1;
 545:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len * 2 - 1] = (data >> 16) & 0xff;
 546:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 547:./trace32/udmon3.c **** 		Monitor_WriteHalf ((void *) address, udmon3.monitor_buffer, len);
 548:./trace32/udmon3.c **** 		break;
 549:./trace32/udmon3.c **** 
 550:./trace32/udmon3.c ****       case 0x06: // 32-bit write access
 551:./trace32/udmon3.c **** 		len = ((data >> 24) & 0x0f) + 1;
 552:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len * 4 - 1] = (data >> 16) & 0xff;
 553:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 554:./trace32/udmon3.c **** 		Monitor_WriteWord ((void *) address, udmon3.monitor_buffer, len);
 555:./trace32/udmon3.c **** 		break;
 556:./trace32/udmon3.c **** 	
 557:./trace32/udmon3.c **** #if 0
 558:./trace32/udmon3.c ****       case 0x07: // 32-bit CP15 read access
 559:./trace32/udmon3.c **** 		udmon3.monitor_buffer[0] = Monitor_ReadCP15 (data & 0xffff);
 560:./trace32/udmon3.c **** 		udmon3.monitor_index = 0;
 561:./trace32/udmon3.c **** 		udmon3.monitor_count = 4;
 562:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 563:./trace32/udmon3.c **** 		break;
 564:./trace32/udmon3.c ****       case 0x08: // 32-bit CP15 write access
 565:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[4 - 1] = (data >> 16) & 0xff;
 566:./trace32/udmon3.c **** 		Monitor_WriteCP15 (data & 0xffff, udmon3.monitor_buffer[0]);
 567:./trace32/udmon3.c **** 		break;
 568:./trace32/udmon3.c **** #endif
 569:./trace32/udmon3.c ****       
 570:./trace32/udmon3.c **** 	  case 0x0d: // set (part of the) address e.g. for a memory write request
 571:./trace32/udmon3.c **** 		if ((data & 0x01000000) == 0)
 1328              		.loc 1 571 3 is_stmt 1
 572:./trace32/udmon3.c **** 		{
 573:./trace32/udmon3.c **** 			/* Bits 16..39 */
 574:./trace32/udmon3.c **** 			udmon3.monitor_address_low = (data << 16);
 1329              		.loc 1 574 4
 575:./trace32/udmon3.c **** 			udmon3.monitor_address_high = (udmon3.monitor_address_high & ~0xff) | ((data >> 16) & 0xff);
 576:./trace32/udmon3.c **** 		}
 577:./trace32/udmon3.c **** 		else
 578:./trace32/udmon3.c **** 		{
 579:./trace32/udmon3.c **** 			/* Bits 40..63 */
 580:./trace32/udmon3.c **** 			udmon3.monitor_address_high = (udmon3.monitor_address_high & ~0xffffff00) | ((data << 8) & 0xfff
 1330              		.loc 1 580 4
 575:./trace32/udmon3.c **** 			udmon3.monitor_address_high = (udmon3.monitor_address_high & ~0xff) | ((data >> 16) & 0xff);
 1331              		.loc 1 575 41 is_stmt 0
 1332 0024 8C229FE5 		ldr	r2, .L110+4
 1333 0028 143092E5 		ldr	r3, [r2, #20]
 571:./trace32/udmon3.c **** 		{
 1334              		.loc 1 571 6
 1335 002c 010414E3 		tst	r4, #16777216
 575:./trace32/udmon3.c **** 			udmon3.monitor_address_high = (udmon3.monitor_address_high & ~0xff) | ((data >> 16) & 0xff);
 1336              		.loc 1 575 88
 1337 0030 0414A001 		lsleq	r1, r4, #8
 575:./trace32/udmon3.c **** 			udmon3.monitor_address_high = (udmon3.monitor_address_high & ~0xff) | ((data >> 16) & 0xff);
 1338              		.loc 1 575 63
 1339 0034 FF30C303 		biceq	r3, r3, #255
 1340              		.loc 1 580 63
 1341 0038 FF300312 		andne	r3, r3, #255
 574:./trace32/udmon3.c **** 			udmon3.monitor_address_high = (udmon3.monitor_address_high & ~0xff) | ((data >> 16) & 0xff);
 1342              		.loc 1 574 39
 1343 003c 0448A001 		lsleq	r4, r4, #16
 1344              	.LVL68:
 575:./trace32/udmon3.c **** 			udmon3.monitor_address_high = (udmon3.monitor_address_high & ~0xff) | ((data >> 16) & 0xff);
 1345              		.loc 1 575 72
 1346 0040 213C8301 		orreq	r3, r3, r1, lsr #24
 1347              		.loc 1 580 78
 1348 0044 04348311 		orrne	r3, r3, r4, lsl #8
 574:./trace32/udmon3.c **** 			udmon3.monitor_address_high = (udmon3.monitor_address_high & ~0xff) | ((data >> 16) & 0xff);
 1349              		.loc 1 574 31
 1350 0048 18408205 		streq	r4, [r2, #24]
 1351              		.loc 1 580 32
 1352 004c 143082E5 		str	r3, [r2, #20]
 1353              	.L88:
 581:./trace32/udmon3.c **** 		}
 582:./trace32/udmon3.c **** 		break;
 583:./trace32/udmon3.c **** 		
 584:./trace32/udmon3.c ****       case 0x0e: // set (part of the) data to buffer e.g. for a memory write request
 585:./trace32/udmon3.c ****       case 0x0f:
 586:./trace32/udmon3.c **** 		index = ((data >> 24) & 0x1f) * 3;
 587:./trace32/udmon3.c **** 		if (index < 21)
 588:./trace32/udmon3.c **** 		{
 589:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[index + 0] =  data        & 0xff;
 590:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[index + 1] = (data >>  8) & 0xff;
 591:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[index + 2] = (data >> 16) & 0xff;
 592:./trace32/udmon3.c **** 		}
 593:./trace32/udmon3.c **** 		break;
 594:./trace32/udmon3.c **** #endif
 595:./trace32/udmon3.c ****     }
 596:./trace32/udmon3.c **** }
 1354              		.loc 1 596 1
 1355 0050 F041BDE8 		pop	{r4, r5, r6, r7, r8, lr}
 1356              		.cfi_remember_state
 1357              		.cfi_restore 14
 1358              		.cfi_restore 8
 1359              		.cfi_restore 7
 1360              		.cfi_restore 6
 1361              		.cfi_restore 5
 1362              		.cfi_restore 4
 1363              		.cfi_def_cfa_offset 0
 1364 0054 1EFF2FE1 		bx	lr
 1365              	.LVL69:
 1366              	.L90:
 1367              		.cfi_restore_state
 586:./trace32/udmon3.c **** 		if (index < 21)
 1368              		.loc 1 586 3 is_stmt 1
 586:./trace32/udmon3.c **** 		if (index < 21)
 1369              		.loc 1 586 18 is_stmt 0
 1370 0058 243CA0E1 		lsr	r3, r4, #24
 586:./trace32/udmon3.c **** 		if (index < 21)
 1371              		.loc 1 586 25
 1372 005c 1F3003E2 		and	r3, r3, #31
 586:./trace32/udmon3.c **** 		if (index < 21)
 1373              		.loc 1 586 33
 1374 0060 833083E0 		add	r3, r3, r3, lsl #1
 1375              	.LVL70:
 587:./trace32/udmon3.c **** 		{
 1376              		.loc 1 587 3 is_stmt 1
 587:./trace32/udmon3.c **** 		{
 1377              		.loc 1 587 6 is_stmt 0
 1378 0064 140053E3 		cmp	r3, #20
 1379 0068 F8FFFF8A 		bhi	.L88
 589:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[index + 1] = (data >>  8) & 0xff;
 1380              		.loc 1 589 4 is_stmt 1
 589:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[index + 1] = (data >>  8) & 0xff;
 1381              		.loc 1 589 57 is_stmt 0
 1382 006c 48229FE5 		ldr	r2, .L110+8
 590:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[index + 2] = (data >> 16) & 0xff;
 1383              		.loc 1 590 65
 1384 0070 2404A0E1 		lsr	r0, r4, #8
 589:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[index + 1] = (data >>  8) & 0xff;
 1385              		.loc 1 589 57
 1386 0074 0340C2E7 		strb	r4, [r2, r3]
 590:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[index + 2] = (data >> 16) & 0xff;
 1387              		.loc 1 590 4 is_stmt 1
 590:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[index + 2] = (data >> 16) & 0xff;
 1388              		.loc 1 590 57 is_stmt 0
 1389 0078 011082E2 		add	r1, r2, #1
 591:./trace32/udmon3.c **** 		}
 1390              		.loc 1 591 57
 1391 007c 02C082E2 		add	ip, r2, #2
 591:./trace32/udmon3.c **** 		}
 1392              		.loc 1 591 65
 1393 0080 2448A0E1 		lsr	r4, r4, #16
 1394              	.LVL71:
 591:./trace32/udmon3.c **** 		}
 1395              		.loc 1 591 57
 1396 0084 0340CCE7 		strb	r4, [ip, r3]
 590:./trace32/udmon3.c **** 			((unsigned char *) udmon3.monitor_buffer)[index + 2] = (data >> 16) & 0xff;
 1397              		.loc 1 590 57
 1398 0088 0300C1E7 		strb	r0, [r1, r3]
 591:./trace32/udmon3.c **** 		}
 1399              		.loc 1 591 4 is_stmt 1
 1400              		.loc 1 596 1 is_stmt 0
 1401 008c EFFFFFEA 		b	.L88
 1402              	.LVL72:
 1403              	.L99:
 461:./trace32/udmon3.c ****           switch (data >> 24) {
 1404              		.loc 1 461 6 is_stmt 1
 461:./trace32/udmon3.c ****           switch (data >> 24) {
 1405              		.loc 1 461 15 is_stmt 0
 1406 0090 20529FE5 		ldr	r5, .L110+4
 1407 0094 040095E5 		ldr	r0, [r5, #4]
 461:./trace32/udmon3.c ****           switch (data >> 24) {
 1408              		.loc 1 461 8
 1409 0098 000050E3 		cmp	r0, #0
 1410 009c EBFFFF0A 		beq	.L88
 462:./trace32/udmon3.c ****             case 0x00: // reserved for terminal input in DCC3 protocol mode
 1411              		.loc 1 462 11 is_stmt 1
 462:./trace32/udmon3.c ****             case 0x00: // reserved for terminal input in DCC3 protocol mode
 1412              		.loc 1 462 24 is_stmt 0
 1413 00a0 243CA0E1 		lsr	r3, r4, #24
 462:./trace32/udmon3.c ****             case 0x00: // reserved for terminal input in DCC3 protocol mode
 1414              		.loc 1 462 11
 1415 00a4 010053E3 		cmp	r3, #1
 1416 00a8 7B00000A 		beq	.L100
 1417 00ac 020053E3 		cmp	r3, #2
 1418 00b0 6A00000A 		beq	.L101
 1419 00b4 000053E3 		cmp	r3, #0
 1420 00b8 E4FFFF1A 		bne	.L88
 464:./trace32/udmon3.c **** 			  break;
 1421              		.loc 1 464 6 is_stmt 1
 1422 00bc FF1004E2 		and	r1, r4, #255
 1423 00c0 F8319FE5 		ldr	r3, .L110+12
 1424              		.loc 1 596 1 is_stmt 0
 1425 00c4 F041BDE8 		pop	{r4, r5, r6, r7, r8, lr}
 1426              		.cfi_remember_state
 1427              		.cfi_restore 14
 1428              		.cfi_restore 8
 1429              		.cfi_restore 7
 1430              		.cfi_restore 6
 1431              		.cfi_restore 5
 1432              		.cfi_restore 4
 1433              		.cfi_def_cfa_offset 0
 1434              	.LVL73:
 464:./trace32/udmon3.c **** 			  break;
 1435              		.loc 1 464 6
 1436 00c8 13FF2FE1 		bx	r3
 1437              	.LVL74:
 1438              	.L98:
 1439              		.cfi_restore_state
 511:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1440              		.loc 1 511 3 is_stmt 1
 512:./trace32/udmon3.c **** 		Monitor_ReadByte (udmon3.monitor_buffer, (void *) address, len);
 1441              		.loc 1 512 20 is_stmt 0
 1442 00cc E4619FE5 		ldr	r6, .L110+4
 511:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1443              		.loc 1 511 16
 1444 00d0 245CA0E1 		lsr	r5, r4, #24
 512:./trace32/udmon3.c **** 		Monitor_ReadByte (udmon3.monitor_buffer, (void *) address, len);
 1445              		.loc 1 512 41
 1446 00d4 183096E5 		ldr	r3, [r6, #24]
 511:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1447              		.loc 1 511 23
 1448 00d8 0F5005E2 		and	r5, r5, #15
 511:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1449              		.loc 1 511 31
 1450 00dc 015085E2 		add	r5, r5, #1
 1451              	.LVL75:
 512:./trace32/udmon3.c **** 		Monitor_ReadByte (udmon3.monitor_buffer, (void *) address, len);
 1452              		.loc 1 512 3 is_stmt 1
 513:./trace32/udmon3.c **** 		udmon3.monitor_index = 0;
 1453              		.loc 1 513 3
 512:./trace32/udmon3.c **** 		Monitor_ReadByte (udmon3.monitor_buffer, (void *) address, len);
 1454              		.loc 1 512 41 is_stmt 0
 1455 00e0 FF3403E2 		and	r3, r3, #-16777216
 1456              	.LVL76:
 512:./trace32/udmon3.c **** 		Monitor_ReadByte (udmon3.monitor_buffer, (void *) address, len);
 1457              		.loc 1 512 62
 1458 00e4 FF14C4E3 		bic	r1, r4, #-16777216
 513:./trace32/udmon3.c **** 		udmon3.monitor_index = 0;
 1459              		.loc 1 513 3
 1460 00e8 0520A0E1 		mov	r2, r5
 1461 00ec D0719FE5 		ldr	r7, .L110+16
 1462 00f0 011083E1 		orr	r1, r3, r1
 1463              	.LVL77:
 1464 00f4 1C0086E2 		add	r0, r6, #28
 1465 00f8 0FE0A0E1 		mov	lr, pc
 1466 00fc 17FF2FE1 		bx	r7
 1467              	.LVL78:
 514:./trace32/udmon3.c **** 		udmon3.monitor_count = len;
 1468              		.loc 1 514 3 is_stmt 1
 514:./trace32/udmon3.c **** 		udmon3.monitor_count = len;
 1469              		.loc 1 514 24 is_stmt 0
 1470 0100 0030A0E3 		mov	r3, #0
 515:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 1471              		.loc 1 515 24
 1472 0104 605086E5 		str	r5, [r6, #96]
 514:./trace32/udmon3.c **** 		udmon3.monitor_count = len;
 1473              		.loc 1 514 24
 1474 0108 5C3086E5 		str	r3, [r6, #92]
 515:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 1475              		.loc 1 515 3 is_stmt 1
 516:./trace32/udmon3.c **** 		break;
 1476              		.loc 1 516 22
 517:./trace32/udmon3.c ****       case 0x02: // 16-bit read access
 1477              		.loc 1 517 3
 1478              		.loc 1 596 1 is_stmt 0
 1479 010c F041BDE8 		pop	{r4, r5, r6, r7, r8, lr}
 1480              		.cfi_remember_state
 1481              		.cfi_restore 14
 1482              		.cfi_restore 8
 1483              		.cfi_restore 7
 1484              		.cfi_restore 6
 1485              		.cfi_restore 5
 1486              		.cfi_restore 4
 1487              		.cfi_def_cfa_offset 0
 1488              	.LVL79:
 1489 0110 1EFF2FE1 		bx	lr
 1490              	.LVL80:
 1491              	.L97:
 1492              		.cfi_restore_state
 519:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1493              		.loc 1 519 3 is_stmt 1
 520:./trace32/udmon3.c **** 		Monitor_ReadHalf (udmon3.monitor_buffer, (void *) address, len);
 1494              		.loc 1 520 20 is_stmt 0
 1495 0114 9C619FE5 		ldr	r6, .L110+4
 519:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1496              		.loc 1 519 16
 1497 0118 245CA0E1 		lsr	r5, r4, #24
 520:./trace32/udmon3.c **** 		Monitor_ReadHalf (udmon3.monitor_buffer, (void *) address, len);
 1498              		.loc 1 520 41
 1499 011c 183096E5 		ldr	r3, [r6, #24]
 519:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1500              		.loc 1 519 23
 1501 0120 0F5005E2 		and	r5, r5, #15
 520:./trace32/udmon3.c **** 		Monitor_ReadHalf (udmon3.monitor_buffer, (void *) address, len);
 1502              		.loc 1 520 41
 1503 0124 FF3403E2 		and	r3, r3, #-16777216
 519:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1504              		.loc 1 519 31
 1505 0128 015085E2 		add	r5, r5, #1
 1506              	.LVL81:
 520:./trace32/udmon3.c **** 		Monitor_ReadHalf (udmon3.monitor_buffer, (void *) address, len);
 1507              		.loc 1 520 3 is_stmt 1
 521:./trace32/udmon3.c **** 		udmon3.monitor_index = 0;
 1508              		.loc 1 521 3
 520:./trace32/udmon3.c **** 		Monitor_ReadHalf (udmon3.monitor_buffer, (void *) address, len);
 1509              		.loc 1 520 62 is_stmt 0
 1510 012c FF14C4E3 		bic	r1, r4, #-16777216
 521:./trace32/udmon3.c **** 		udmon3.monitor_index = 0;
 1511              		.loc 1 521 3
 1512 0130 0520A0E1 		mov	r2, r5
 1513 0134 8C719FE5 		ldr	r7, .L110+20
 1514 0138 011083E1 		orr	r1, r3, r1
 1515              	.LVL82:
 1516 013c 1C0086E2 		add	r0, r6, #28
 1517 0140 0FE0A0E1 		mov	lr, pc
 1518 0144 17FF2FE1 		bx	r7
 1519              	.LVL83:
 522:./trace32/udmon3.c **** 		udmon3.monitor_count = len * 2;
 1520              		.loc 1 522 3 is_stmt 1
 522:./trace32/udmon3.c **** 		udmon3.monitor_count = len * 2;
 1521              		.loc 1 522 24 is_stmt 0
 1522 0148 0030A0E3 		mov	r3, #0
 523:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 1523              		.loc 1 523 30
 1524 014c 8550A0E1 		lsl	r5, r5, #1
 1525              	.LVL84:
 522:./trace32/udmon3.c **** 		udmon3.monitor_count = len * 2;
 1526              		.loc 1 522 24
 1527 0150 5C3086E5 		str	r3, [r6, #92]
 523:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 1528              		.loc 1 523 3 is_stmt 1
 523:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 1529              		.loc 1 523 24 is_stmt 0
 1530 0154 605086E5 		str	r5, [r6, #96]
 524:./trace32/udmon3.c **** 		break;
 1531              		.loc 1 524 22 is_stmt 1
 525:./trace32/udmon3.c **** 
 1532              		.loc 1 525 3
 1533              		.loc 1 596 1 is_stmt 0
 1534 0158 F041BDE8 		pop	{r4, r5, r6, r7, r8, lr}
 1535              		.cfi_remember_state
 1536              		.cfi_restore 14
 1537              		.cfi_restore 8
 1538              		.cfi_restore 7
 1539              		.cfi_restore 6
 1540              		.cfi_restore 5
 1541              		.cfi_restore 4
 1542              		.cfi_def_cfa_offset 0
 1543              	.LVL85:
 1544 015c 1EFF2FE1 		bx	lr
 1545              	.LVL86:
 1546              	.L96:
 1547              		.cfi_restore_state
 528:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1548              		.loc 1 528 3 is_stmt 1
 529:./trace32/udmon3.c **** 		Monitor_ReadWord (udmon3.monitor_buffer, (void *) address, len);
 1549              		.loc 1 529 20 is_stmt 0
 1550 0160 50619FE5 		ldr	r6, .L110+4
 528:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1551              		.loc 1 528 16
 1552 0164 245CA0E1 		lsr	r5, r4, #24
 529:./trace32/udmon3.c **** 		Monitor_ReadWord (udmon3.monitor_buffer, (void *) address, len);
 1553              		.loc 1 529 41
 1554 0168 183096E5 		ldr	r3, [r6, #24]
 528:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1555              		.loc 1 528 23
 1556 016c 0F5005E2 		and	r5, r5, #15
 529:./trace32/udmon3.c **** 		Monitor_ReadWord (udmon3.monitor_buffer, (void *) address, len);
 1557              		.loc 1 529 41
 1558 0170 FF3403E2 		and	r3, r3, #-16777216
 528:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffffff) | (data & 0xffffff);
 1559              		.loc 1 528 31
 1560 0174 015085E2 		add	r5, r5, #1
 1561              	.LVL87:
 529:./trace32/udmon3.c **** 		Monitor_ReadWord (udmon3.monitor_buffer, (void *) address, len);
 1562              		.loc 1 529 3 is_stmt 1
 530:./trace32/udmon3.c **** 		udmon3.monitor_index = 0;
 1563              		.loc 1 530 3
 529:./trace32/udmon3.c **** 		Monitor_ReadWord (udmon3.monitor_buffer, (void *) address, len);
 1564              		.loc 1 529 62 is_stmt 0
 1565 0178 FF14C4E3 		bic	r1, r4, #-16777216
 530:./trace32/udmon3.c **** 		udmon3.monitor_index = 0;
 1566              		.loc 1 530 3
 1567 017c 0520A0E1 		mov	r2, r5
 1568 0180 44719FE5 		ldr	r7, .L110+24
 1569 0184 011083E1 		orr	r1, r3, r1
 1570              	.LVL88:
 1571 0188 1C0086E2 		add	r0, r6, #28
 1572 018c 0FE0A0E1 		mov	lr, pc
 1573 0190 17FF2FE1 		bx	r7
 1574              	.LVL89:
 531:./trace32/udmon3.c **** 		udmon3.monitor_count = len * 4;
 1575              		.loc 1 531 3 is_stmt 1
 531:./trace32/udmon3.c **** 		udmon3.monitor_count = len * 4;
 1576              		.loc 1 531 24 is_stmt 0
 1577 0194 0030A0E3 		mov	r3, #0
 532:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 1578              		.loc 1 532 30
 1579 0198 0551A0E1 		lsl	r5, r5, #2
 1580              	.LVL90:
 531:./trace32/udmon3.c **** 		udmon3.monitor_count = len * 4;
 1581              		.loc 1 531 24
 1582 019c 5C3086E5 		str	r3, [r6, #92]
 532:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 1583              		.loc 1 532 3 is_stmt 1
 532:./trace32/udmon3.c **** 		COMMTX_IRQ_ENABLE();
 1584              		.loc 1 532 24 is_stmt 0
 1585 01a0 605086E5 		str	r5, [r6, #96]
 533:./trace32/udmon3.c **** 		break;
 1586              		.loc 1 533 22 is_stmt 1
 534:./trace32/udmon3.c **** 
 1587              		.loc 1 534 3
 1588              		.loc 1 596 1 is_stmt 0
 1589 01a4 F041BDE8 		pop	{r4, r5, r6, r7, r8, lr}
 1590              		.cfi_remember_state
 1591              		.cfi_restore 14
 1592              		.cfi_restore 8
 1593              		.cfi_restore 7
 1594              		.cfi_restore 6
 1595              		.cfi_restore 5
 1596              		.cfi_restore 4
 1597              		.cfi_def_cfa_offset 0
 1598              	.LVL91:
 1599 01a8 1EFF2FE1 		bx	lr
 1600              	.LVL92:
 1601              	.L95:
 1602              		.cfi_restore_state
 537:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len - 1] = (data >> 16) & 0xff;
 1603              		.loc 1 537 3 is_stmt 1
 538:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1604              		.loc 1 538 54 is_stmt 0
 1605 01ac 08119FE5 		ldr	r1, .L110+8
 537:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len - 1] = (data >> 16) & 0xff;
 1606              		.loc 1 537 16
 1607 01b0 242CA0E1 		lsr	r2, r4, #24
 538:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1608              		.loc 1 538 62
 1609 01b4 2438A0E1 		lsr	r3, r4, #16
 537:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len - 1] = (data >> 16) & 0xff;
 1610              		.loc 1 537 23
 1611 01b8 0F2002E2 		and	r2, r2, #15
 1612              	.LVL93:
 538:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1613              		.loc 1 538 3 is_stmt 1
 538:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1614              		.loc 1 538 54 is_stmt 0
 1615 01bc 0230C1E7 		strb	r3, [r1, r2]
 539:./trace32/udmon3.c **** 		Monitor_WriteByte ((void *) address, udmon3.monitor_buffer, len);
 1616              		.loc 1 539 3 is_stmt 1
 1617              	.LVL94:
 540:./trace32/udmon3.c **** 		break;
 1618              		.loc 1 540 3
 539:./trace32/udmon3.c **** 		Monitor_WriteByte ((void *) address, udmon3.monitor_buffer, len);
 1619              		.loc 1 539 41 is_stmt 0
 1620 01c0 043011E5 		ldr	r3, [r1, #-4]
 539:./trace32/udmon3.c **** 		Monitor_WriteByte ((void *) address, udmon3.monitor_buffer, len);
 1621              		.loc 1 539 60
 1622 01c4 0408A0E1 		lsl	r0, r4, #16
 539:./trace32/udmon3.c **** 		Monitor_WriteByte ((void *) address, udmon3.monitor_buffer, len);
 1623              		.loc 1 539 41
 1624 01c8 2338A0E1 		lsr	r3, r3, #16
 1625 01cc 0338A0E1 		lsl	r3, r3, #16
 539:./trace32/udmon3.c **** 		Monitor_WriteByte ((void *) address, udmon3.monitor_buffer, len);
 1626              		.loc 1 539 60
 1627 01d0 2008A0E1 		lsr	r0, r0, #16
 540:./trace32/udmon3.c **** 		break;
 1628              		.loc 1 540 3
 1629 01d4 000083E1 		orr	r0, r3, r0
 1630              		.loc 1 596 1
 1631 01d8 F041BDE8 		pop	{r4, r5, r6, r7, r8, lr}
 1632              		.cfi_remember_state
 1633              		.cfi_restore 14
 1634              		.cfi_restore 8
 1635              		.cfi_restore 7
 1636              		.cfi_restore 6
 1637              		.cfi_restore 5
 1638              		.cfi_restore 4
 1639              		.cfi_def_cfa_offset 0
 1640              	.LVL95:
 540:./trace32/udmon3.c **** 		break;
 1641              		.loc 1 540 3
 1642 01dc EC309FE5 		ldr	r3, .L110+28
 1643 01e0 012082E2 		add	r2, r2, #1
 1644              	.LVL96:
 1645 01e4 13FF2FE1 		bx	r3	@ indirect register sibling call
 1646              	.LVL97:
 1647              	.L94:
 1648              		.cfi_restore_state
 544:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len * 2 - 1] = (data >> 16) & 0xff;
 1649              		.loc 1 544 3 is_stmt 1
 544:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len * 2 - 1] = (data >> 16) & 0xff;
 1650              		.loc 1 544 16 is_stmt 0
 1651 01e8 242CA0E1 		lsr	r2, r4, #24
 545:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1652              		.loc 1 545 58
 1653 01ec E0109FE5 		ldr	r1, .L110+32
 544:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len * 2 - 1] = (data >> 16) & 0xff;
 1654              		.loc 1 544 23
 1655 01f0 0F2002E2 		and	r2, r2, #15
 545:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1656              		.loc 1 545 66
 1657 01f4 2438A0E1 		lsr	r3, r4, #16
 544:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len * 2 - 1] = (data >> 16) & 0xff;
 1658              		.loc 1 544 31
 1659 01f8 012082E2 		add	r2, r2, #1
 1660              	.LVL98:
 545:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1661              		.loc 1 545 3 is_stmt 1
 545:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1662              		.loc 1 545 58 is_stmt 0
 1663 01fc 8230C1E7 		strb	r3, [r1, r2, lsl #1]
 546:./trace32/udmon3.c **** 		Monitor_WriteHalf ((void *) address, udmon3.monitor_buffer, len);
 1664              		.loc 1 546 3 is_stmt 1
 1665              	.LVL99:
 547:./trace32/udmon3.c **** 		break;
 1666              		.loc 1 547 3
 546:./trace32/udmon3.c **** 		Monitor_WriteHalf ((void *) address, udmon3.monitor_buffer, len);
 1667              		.loc 1 546 41 is_stmt 0
 1668 0200 033011E5 		ldr	r3, [r1, #-3]
 546:./trace32/udmon3.c **** 		Monitor_WriteHalf ((void *) address, udmon3.monitor_buffer, len);
 1669              		.loc 1 546 60
 1670 0204 0408A0E1 		lsl	r0, r4, #16
 546:./trace32/udmon3.c **** 		Monitor_WriteHalf ((void *) address, udmon3.monitor_buffer, len);
 1671              		.loc 1 546 41
 1672 0208 2338A0E1 		lsr	r3, r3, #16
 547:./trace32/udmon3.c **** 		break;
 1673              		.loc 1 547 3
 1674 020c C4E09FE5 		ldr	lr, .L110+36
 546:./trace32/udmon3.c **** 		Monitor_WriteHalf ((void *) address, udmon3.monitor_buffer, len);
 1675              		.loc 1 546 41
 1676 0210 0338A0E1 		lsl	r3, r3, #16
 546:./trace32/udmon3.c **** 		Monitor_WriteHalf ((void *) address, udmon3.monitor_buffer, len);
 1677              		.loc 1 546 60
 1678 0214 2008A0E1 		lsr	r0, r0, #16
 1679              	.LVL100:
 1680              	.L109:
 554:./trace32/udmon3.c **** 		break;
 1681              		.loc 1 554 3
 1682 0218 000083E1 		orr	r0, r3, r0
 1683 021c 011081E2 		add	r1, r1, #1
 1684 0220 0E30A0E1 		mov	r3, lr
 1685              		.loc 1 596 1
 1686 0224 F041BDE8 		pop	{r4, r5, r6, r7, r8, lr}
 1687              		.cfi_remember_state
 1688              		.cfi_restore 14
 1689              		.cfi_restore 8
 1690              		.cfi_restore 7
 1691              		.cfi_restore 6
 1692              		.cfi_restore 5
 1693              		.cfi_restore 4
 1694              		.cfi_def_cfa_offset 0
 1695              	.LVL101:
 554:./trace32/udmon3.c **** 		break;
 1696              		.loc 1 554 3
 1697 0228 13FF2FE1 		bx	r3	@ indirect register sibling call
 1698              	.LVL102:
 1699              	.L93:
 1700              		.cfi_restore_state
 551:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len * 4 - 1] = (data >> 16) & 0xff;
 1701              		.loc 1 551 3 is_stmt 1
 551:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len * 4 - 1] = (data >> 16) & 0xff;
 1702              		.loc 1 551 16 is_stmt 0
 1703 022c 242CA0E1 		lsr	r2, r4, #24
 552:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1704              		.loc 1 552 58
 1705 0230 9C109FE5 		ldr	r1, .L110+32
 551:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len * 4 - 1] = (data >> 16) & 0xff;
 1706              		.loc 1 551 23
 1707 0234 0F2002E2 		and	r2, r2, #15
 552:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1708              		.loc 1 552 66
 1709 0238 2438A0E1 		lsr	r3, r4, #16
 551:./trace32/udmon3.c **** 		((unsigned char *) udmon3.monitor_buffer)[len * 4 - 1] = (data >> 16) & 0xff;
 1710              		.loc 1 551 31
 1711 023c 012082E2 		add	r2, r2, #1
 1712              	.LVL103:
 552:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1713              		.loc 1 552 3 is_stmt 1
 552:./trace32/udmon3.c **** 		address = (udmon3.monitor_address_low & ~0xffff) | (data & 0xffff);
 1714              		.loc 1 552 58 is_stmt 0
 1715 0240 0231C1E7 		strb	r3, [r1, r2, lsl #2]
 553:./trace32/udmon3.c **** 		Monitor_WriteWord ((void *) address, udmon3.monitor_buffer, len);
 1716              		.loc 1 553 3 is_stmt 1
 1717              	.LVL104:
 554:./trace32/udmon3.c **** 		break;
 1718              		.loc 1 554 3
 553:./trace32/udmon3.c **** 		Monitor_WriteWord ((void *) address, udmon3.monitor_buffer, len);
 1719              		.loc 1 553 41 is_stmt 0
 1720 0244 033011E5 		ldr	r3, [r1, #-3]
 553:./trace32/udmon3.c **** 		Monitor_WriteWord ((void *) address, udmon3.monitor_buffer, len);
 1721              		.loc 1 553 60
 1722 0248 0408A0E1 		lsl	r0, r4, #16
 553:./trace32/udmon3.c **** 		Monitor_WriteWord ((void *) address, udmon3.monitor_buffer, len);
 1723              		.loc 1 553 41
 1724 024c 2338A0E1 		lsr	r3, r3, #16
 554:./trace32/udmon3.c **** 		break;
 1725              		.loc 1 554 3
 1726 0250 84E09FE5 		ldr	lr, .L110+40
 553:./trace32/udmon3.c **** 		Monitor_WriteWord ((void *) address, udmon3.monitor_buffer, len);
 1727              		.loc 1 553 41
 1728 0254 0338A0E1 		lsl	r3, r3, #16
 553:./trace32/udmon3.c **** 		Monitor_WriteWord ((void *) address, udmon3.monitor_buffer, len);
 1729              		.loc 1 553 60
 1730 0258 2008A0E1 		lsr	r0, r0, #16
 1731 025c EDFFFFEA 		b	.L109
 1732              	.LVL105:
 1733              	.L101:
 471:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>> 8)&0xff));
 1734              		.loc 1 471 6 is_stmt 1
 1735 0260 58609FE5 		ldr	r6, .L110+12
 1736 0264 FF1004E2 		and	r1, r4, #255
 1737 0268 0FE0A0E1 		mov	lr, pc
 1738 026c 16FF2FE1 		bx	r6
 1739              	.LVL106:
 472:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>>16)&0xff));
 1740              		.loc 1 472 6
 472:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>>16)&0xff));
 1741              		.loc 1 472 61 is_stmt 0
 1742 0270 2414A0E1 		lsr	r1, r4, #8
 472:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>>16)&0xff));
 1743              		.loc 1 472 6
 1744 0274 FF1001E2 		and	r1, r1, #255
 1745 0278 040095E5 		ldr	r0, [r5, #4]
 1746 027c 0FE0A0E1 		mov	lr, pc
 1747 0280 16FF2FE1 		bx	r6
 1748              	.LVL107:
 473:./trace32/udmon3.c **** 			  break;
 1749              		.loc 1 473 6 is_stmt 1
 473:./trace32/udmon3.c **** 			  break;
 1750              		.loc 1 473 61 is_stmt 0
 1751 0284 2418A0E1 		lsr	r1, r4, #16
 1752              	.L108:
 473:./trace32/udmon3.c **** 			  break;
 1753              		.loc 1 473 6
 1754 0288 0630A0E1 		mov	r3, r6
 1755 028c 040095E5 		ldr	r0, [r5, #4]
 1756 0290 FF1001E2 		and	r1, r1, #255
 1757              		.loc 1 596 1
 1758 0294 F041BDE8 		pop	{r4, r5, r6, r7, r8, lr}
 1759              		.cfi_remember_state
 1760              		.cfi_restore 14
 1761              		.cfi_restore 8
 1762              		.cfi_restore 7
 1763              		.cfi_restore 6
 1764              		.cfi_restore 5
 1765              		.cfi_restore 4
 1766              		.cfi_def_cfa_offset 0
 1767              	.LVL108:
 473:./trace32/udmon3.c **** 			  break;
 1768              		.loc 1 473 6
 1769 0298 13FF2FE1 		bx	r3
 1770              	.LVL109:
 1771              	.L100:
 1772              		.cfi_restore_state
 467:./trace32/udmon3.c **** 			  byte_fifo_cb_put(udmon3.term_recv,(unsigned char)((data>> 8)&0xff));
 1773              		.loc 1 467 6 is_stmt 1
 1774 029c FF1004E2 		and	r1, r4, #255
 1775 02a0 18609FE5 		ldr	r6, .L110+12
 1776 02a4 0FE0A0E1 		mov	lr, pc
 1777 02a8 16FF2FE1 		bx	r6
 1778              	.LVL110:
 468:./trace32/udmon3.c **** 			  break;
 1779              		.loc 1 468 6
 468:./trace32/udmon3.c **** 			  break;
 1780              		.loc 1 468 61 is_stmt 0
 1781 02ac 2414A0E1 		lsr	r1, r4, #8
 1782 02b0 F4FFFFEA 		b	.L108
 1783              	.L111:
 1784              		.align	2
 1785              	.L110:
 1786 02b4 00000000 		.word	.L91
 1787 02b8 00000000 		.word	udmon3
 1788 02bc 1C000000 		.word	udmon3+28
 1789 02c0 00000000 		.word	byte_fifo_cb_put
 1790 02c4 00000000 		.word	Monitor_ReadByte
 1791 02c8 00000000 		.word	Monitor_ReadHalf
 1792 02cc 00000000 		.word	Monitor_ReadWord
 1793 02d0 00000000 		.word	Monitor_WriteByte
 1794 02d4 1B000000 		.word	udmon3+27
 1795 02d8 00000000 		.word	Monitor_WriteHalf
 1796 02dc 00000000 		.word	Monitor_WriteWord
 1797              		.cfi_endproc
 1798              	.LFE18:
 1800              		.section	.text.udmon3_transmit,"ax",%progbits
 1801              		.align	2
 1802              		.syntax unified
 1803              		.arm
 1805              	udmon3_transmit:
 1806              	.LFB19:
 597:./trace32/udmon3.c **** 
 598:./trace32/udmon3.c **** static inline void udmon3_transmit(void)
 599:./trace32/udmon3.c **** {
 1807              		.loc 1 599 1 is_stmt 1
 1808              		.cfi_startproc
 1809              		@ Function supports interworking.
 1810              		@ args = 0, pretend = 0, frame = 8
 1811              		@ frame_needed = 0, uses_anonymous_args = 0
 600:./trace32/udmon3.c **** 	unsigned int data;
 1812              		.loc 1 600 2
 601:./trace32/udmon3.c **** 	data=0x0;
 1813              		.loc 1 601 2
 1814              		.loc 1 601 6 is_stmt 0
 1815 0000 0020A0E3 		mov	r2, #0
 599:./trace32/udmon3.c **** 	unsigned int data;
 1816              		.loc 1 599 1
 1817 0004 30402DE9 		push	{r4, r5, lr}
 1818              		.cfi_def_cfa_offset 12
 1819              		.cfi_offset 4, -12
 1820              		.cfi_offset 5, -8
 1821              		.cfi_offset 14, -4
 602:./trace32/udmon3.c **** 	
 603:./trace32/udmon3.c **** #ifdef MODE_RAM
 604:./trace32/udmon3.c **** 	// send data e.g. of a memory read request to TRACE32 GUI via DCC channel
 605:./trace32/udmon3.c **** 	if (udmon3.monitor_index < udmon3.monitor_count)
 1822              		.loc 1 605 12
 1823 0008 C4409FE5 		ldr	r4, .L123
 1824 000c 5C3094E5 		ldr	r3, [r4, #92]
 1825              		.loc 1 605 5
 1826 0010 601094E5 		ldr	r1, [r4, #96]
 599:./trace32/udmon3.c **** 	unsigned int data;
 1827              		.loc 1 599 1
 1828 0014 0CD04DE2 		sub	sp, sp, #12
 1829              		.cfi_def_cfa_offset 24
 1830              		.loc 1 605 5
 1831 0018 010053E1 		cmp	r3, r1
 601:./trace32/udmon3.c **** 	
 1832              		.loc 1 601 6
 1833 001c 04208DE5 		str	r2, [sp, #4]
 1834              		.loc 1 605 2 is_stmt 1
 1835              		.loc 1 605 5 is_stmt 0
 1836 0020 0F0000AA 		bge	.L113
 606:./trace32/udmon3.c **** 	{
 607:./trace32/udmon3.c **** 		data = (((unsigned char *) udmon3.monitor_buffer)[udmon3.monitor_index    ]      ) | 
 1837              		.loc 1 607 3 is_stmt 1
 608:./trace32/udmon3.c **** 			   (((unsigned char *) udmon3.monitor_buffer)[udmon3.monitor_index + 1] << 8 ) | 
 609:./trace32/udmon3.c **** 		       (((unsigned char *) udmon3.monitor_buffer)[udmon3.monitor_index + 2] << 16) | 
 610:./trace32/udmon3.c **** 		        0x10000000;
 611:./trace32/udmon3.c **** 		DCC_SendWord(data);
 1838              		.loc 1 611 3
 609:./trace32/udmon3.c **** 		        0x10000000;
 1839              		.loc 1 609 52 is_stmt 0
 1840 0024 1E2084E2 		add	r2, r4, #30
 608:./trace32/udmon3.c **** 			   (((unsigned char *) udmon3.monitor_buffer)[udmon3.monitor_index + 1] << 8 ) | 
 1841              		.loc 1 608 49
 1842 0028 1D1084E2 		add	r1, r4, #29
 609:./trace32/udmon3.c **** 		        0x10000000;
 1843              		.loc 1 609 52
 1844 002c 0320D2E7 		ldrb	r2, [r2, r3]	@ zero_extendqisi2
 608:./trace32/udmon3.c **** 			   (((unsigned char *) udmon3.monitor_buffer)[udmon3.monitor_index + 1] << 8 ) | 
 1845              		.loc 1 608 49
 1846 0030 0300D1E7 		ldrb	r0, [r1, r3]	@ zero_extendqisi2
 607:./trace32/udmon3.c **** 			   (((unsigned char *) udmon3.monitor_buffer)[udmon3.monitor_index + 1] << 8 ) | 
 1847              		.loc 1 607 52
 1848 0034 1C1084E2 		add	r1, r4, #28
 1849 0038 0310D1E7 		ldrb	r1, [r1, r3]	@ zero_extendqisi2
 609:./trace32/udmon3.c **** 		        0x10000000;
 1850              		.loc 1 609 79
 1851 003c 0228A0E1 		lsl	r2, r2, #16
 608:./trace32/udmon3.c **** 			   (((unsigned char *) udmon3.monitor_buffer)[udmon3.monitor_index + 1] << 8 ) | 
 1852              		.loc 1 608 83
 1853 0040 002482E1 		orr	r2, r2, r0, lsl #8
 1854 0044 012082E1 		orr	r2, r2, r1
 609:./trace32/udmon3.c **** 		        0x10000000;
 1855              		.loc 1 609 86
 1856 0048 012282E3 		orr	r2, r2, #268435456
 1857              		.loc 1 611 3
 1858              		.syntax divided
 1859              	@ 611 "./trace32/udmon3.c" 1
 1860 004c 102E01EE 		mcr p14, 0, r2, c1, c0
 1861              	@ 0 "" 2
 1862              		.loc 1 611 21 is_stmt 1
 612:./trace32/udmon3.c **** 		udmon3.monitor_index += 3;	
 1863              		.loc 1 612 3
 1864              		.loc 1 612 24 is_stmt 0
 1865              		.arm
 1866              		.syntax unified
 1867 0050 033083E2 		add	r3, r3, #3
 1868 0054 5C3084E5 		str	r3, [r4, #92]
 1869              	.L112:
 613:./trace32/udmon3.c **** 	}
 614:./trace32/udmon3.c **** 	else 
 615:./trace32/udmon3.c **** #endif
 616:./trace32/udmon3.c **** #ifdef PTMON3
 617:./trace32/udmon3.c **** 	// send word to host if monitor has been entered due to a debug event
 618:./trace32/udmon3.c **** 	if(*udmon3.monitor_stackbase & 0x0001)
 619:./trace32/udmon3.c **** 	{
 620:./trace32/udmon3.c **** 		*udmon3.monitor_stackbase &= ~0x0001;
 621:./trace32/udmon3.c **** 		data = (*udmon3.monitor_stackbase & 0xffff) | 0x0f000000;
 622:./trace32/udmon3.c **** 		DCC_SendWord(data);
 623:./trace32/udmon3.c **** 	}
 624:./trace32/udmon3.c **** 	else 
 625:./trace32/udmon3.c **** #endif
 626:./trace32/udmon3.c **** 	if(udmon3.term_send) {
 627:./trace32/udmon3.c **** 	    if(byte_fifo_cb_get(udmon3.term_send,((unsigned char *)&data)+0) != -1) {
 628:./trace32/udmon3.c **** 		    if(byte_fifo_cb_get(udmon3.term_send, ((unsigned char *)&data)+1) != -1) {
 629:./trace32/udmon3.c **** 			    if(byte_fifo_cb_get(udmon3.term_send, ((unsigned char *)&data)+2) != -1) {
 630:./trace32/udmon3.c **** 				    DCC_SendWord(data | 0x2000000); //3 Bytes
 631:./trace32/udmon3.c **** 			    }
 632:./trace32/udmon3.c **** 			    else {
 633:./trace32/udmon3.c **** 				    DCC_SendWord(data | 0x1000000); //2 Bytes
 634:./trace32/udmon3.c **** 			    }
 635:./trace32/udmon3.c **** 		    }
 636:./trace32/udmon3.c **** 		    else {
 637:./trace32/udmon3.c **** 		  	  DCC_SendWord(data | 0x0000000); //1 Bytes
 638:./trace32/udmon3.c **** 		    }
 639:./trace32/udmon3.c **** 	    }
 640:./trace32/udmon3.c **** 	}
 641:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_IRQ
 642:./trace32/udmon3.c ****   //Weitere Daten zum Senden vorhanden, wenn nein, dann COMM-TX Deaktivieren
 643:./trace32/udmon3.c ****   #ifdef MODE_RAM
 644:./trace32/udmon3.c **** 	if((udmon3.monitor_index >= udmon3.monitor_count) && (byte_fifo_cb_get_possible(udmon3.term_send) 
 645:./trace32/udmon3.c **** 	{
 646:./trace32/udmon3.c **** 		COMMTX_IRQ_DISABLE();
 647:./trace32/udmon3.c **** 	}
 648:./trace32/udmon3.c ****   #else
 649:./trace32/udmon3.c **** 	if(byte_fifo_cb_get_possible(udmon3.term_send) == -1)
 650:./trace32/udmon3.c **** 	{
 651:./trace32/udmon3.c **** 		COMMTX_IRQ_DISABLE();
 652:./trace32/udmon3.c **** 	}
 653:./trace32/udmon3.c ****   #endif
 654:./trace32/udmon3.c **** #endif	
 655:./trace32/udmon3.c **** }
 1870              		.loc 1 655 1
 1871 0058 0CD08DE2 		add	sp, sp, #12
 1872              		.cfi_remember_state
 1873              		.cfi_def_cfa_offset 12
 1874              		@ sp needed
 1875 005c 3040BDE8 		pop	{r4, r5, lr}
 1876              		.cfi_restore 14
 1877              		.cfi_restore 5
 1878              		.cfi_restore 4
 1879              		.cfi_def_cfa_offset 0
 1880 0060 1EFF2FE1 		bx	lr
 1881              	.L113:
 1882              		.cfi_restore_state
 626:./trace32/udmon3.c **** 	    if(byte_fifo_cb_get(udmon3.term_send,((unsigned char *)&data)+0) != -1) {
 1883              		.loc 1 626 2 is_stmt 1
 626:./trace32/udmon3.c **** 	    if(byte_fifo_cb_get(udmon3.term_send,((unsigned char *)&data)+0) != -1) {
 1884              		.loc 1 626 11 is_stmt 0
 1885 0064 000094E5 		ldr	r0, [r4]
 626:./trace32/udmon3.c **** 	    if(byte_fifo_cb_get(udmon3.term_send,((unsigned char *)&data)+0) != -1) {
 1886              		.loc 1 626 4
 1887 0068 000050E3 		cmp	r0, #0
 1888 006c F9FFFF0A 		beq	.L112
 627:./trace32/udmon3.c **** 		    if(byte_fifo_cb_get(udmon3.term_send, ((unsigned char *)&data)+1) != -1) {
 1889              		.loc 1 627 6 is_stmt 1
 627:./trace32/udmon3.c **** 		    if(byte_fifo_cb_get(udmon3.term_send, ((unsigned char *)&data)+1) != -1) {
 1890              		.loc 1 627 9 is_stmt 0
 1891 0070 60509FE5 		ldr	r5, .L123+4
 1892 0074 04108DE2 		add	r1, sp, #4
 1893 0078 0FE0A0E1 		mov	lr, pc
 1894 007c 15FF2FE1 		bx	r5
 1895              	.LVL111:
 627:./trace32/udmon3.c **** 		    if(byte_fifo_cb_get(udmon3.term_send, ((unsigned char *)&data)+1) != -1) {
 1896              		.loc 1 627 8 discriminator 1
 1897 0080 010070E3 		cmn	r0, #1
 1898 0084 F3FFFF0A 		beq	.L112
 628:./trace32/udmon3.c **** 			    if(byte_fifo_cb_get(udmon3.term_send, ((unsigned char *)&data)+2) != -1) {
 1899              		.loc 1 628 7 is_stmt 1
 628:./trace32/udmon3.c **** 			    if(byte_fifo_cb_get(udmon3.term_send, ((unsigned char *)&data)+2) != -1) {
 1900              		.loc 1 628 10 is_stmt 0
 1901 0088 000094E5 		ldr	r0, [r4]
 1902 008c 05108DE2 		add	r1, sp, #5
 1903 0090 0FE0A0E1 		mov	lr, pc
 1904 0094 15FF2FE1 		bx	r5
 1905              	.LVL112:
 628:./trace32/udmon3.c **** 			    if(byte_fifo_cb_get(udmon3.term_send, ((unsigned char *)&data)+2) != -1) {
 1906              		.loc 1 628 9 discriminator 1
 1907 0098 010070E3 		cmn	r0, #1
 1908 009c 0900000A 		beq	.L117
 629:./trace32/udmon3.c **** 				    DCC_SendWord(data | 0x2000000); //3 Bytes
 1909              		.loc 1 629 8 is_stmt 1
 629:./trace32/udmon3.c **** 				    DCC_SendWord(data | 0x2000000); //3 Bytes
 1910              		.loc 1 629 11 is_stmt 0
 1911 00a0 000094E5 		ldr	r0, [r4]
 1912 00a4 06108DE2 		add	r1, sp, #6
 1913 00a8 0FE0A0E1 		mov	lr, pc
 1914 00ac 15FF2FE1 		bx	r5
 1915              	.LVL113:
 630:./trace32/udmon3.c **** 			    }
 1916              		.loc 1 630 9
 1917 00b0 04309DE5 		ldr	r3, [sp, #4]
 629:./trace32/udmon3.c **** 				    DCC_SendWord(data | 0x2000000); //3 Bytes
 1918              		.loc 1 629 10 discriminator 1
 1919 00b4 010070E3 		cmn	r0, #1
 630:./trace32/udmon3.c **** 			    }
 1920              		.loc 1 630 9 is_stmt 1
 1921 00b8 02348313 		orrne	r3, r3, #33554432
 633:./trace32/udmon3.c **** 			    }
 1922              		.loc 1 633 9
 1923 00bc 01348303 		orreq	r3, r3, #16777216
 1924              		.syntax divided
 1925              	@ 633 "./trace32/udmon3.c" 1
 1926 00c0 103E01EE 		mcr p14, 0, r3, c1, c0
 1927              	@ 0 "" 2
 1928              		.arm
 1929              		.syntax unified
 1930 00c4 E3FFFFEA 		b	.L112
 1931              	.L117:
 637:./trace32/udmon3.c **** 		    }
 1932              		.loc 1 637 8
 1933 00c8 04309DE5 		ldr	r3, [sp, #4]
 1934              		.syntax divided
 1935              	@ 637 "./trace32/udmon3.c" 1
 1936 00cc 103E01EE 		mcr p14, 0, r3, c1, c0
 1937              	@ 0 "" 2
 637:./trace32/udmon3.c **** 		    }
 1938              		.loc 1 637 38
 1939              		.loc 1 655 1 is_stmt 0
 1940              		.arm
 1941              		.syntax unified
 1942 00d0 E0FFFFEA 		b	.L112
 1943              	.L124:
 1944              		.align	2
 1945              	.L123:
 1946 00d4 00000000 		.word	udmon3
 1947 00d8 00000000 		.word	byte_fifo_cb_get
 1948              		.cfi_endproc
 1949              	.LFE19:
 1951              		.section	.text.fastcode,"ax",%progbits
 1952              		.align	2
 1953              		.global	udmon3_handler
 1954              		.syntax unified
 1955              		.arm
 1957              	udmon3_handler:
 1958              	.LFB20:
 656:./trace32/udmon3.c **** 
 657:./trace32/udmon3.c **** //The bits COMMRX and COMMTX, which indicates, respectively, 
 658:./trace32/udmon3.c **** //- that the read register has been written by the debugger but not yet read by the processor, 
 659:./trace32/udmon3.c **** //- and that the write register has been written bei the processor and not yet read by the debugger
 660:./trace32/udmon3.c **** //are wired on the two highest bits of the status register DBGU_SR. 
 661:./trace32/udmon3.c **** 
 662:./trace32/udmon3.c **** __attribute__ ((section (".text.fastcode")))
 663:./trace32/udmon3.c **** void udmon3_handler(void)
 664:./trace32/udmon3.c **** {
 1959              		.loc 1 664 1 is_stmt 1
 1960              		.cfi_startproc
 1961              		@ Function supports interworking.
 1962              		@ args = 0, pretend = 0, frame = 0
 1963              		@ frame_needed = 0, uses_anonymous_args = 0
 665:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_ZYKLISCH
 666:./trace32/udmon3.c **** 	if (DCC_ReceiveStatus())   //Zeichen vom Debugger bereitgestellt?
 1964              		.loc 1 666 2
 1965              	.LBB5:
 1966              		.loc 1 666 6
 1967              		.loc 1 666 6
 1968              		.syntax divided
 1969              	@ 666 "./trace32/udmon3.c" 1
 1970 0000 103E10EE 		mrc p14, 0, r3, c0, c0
 1971              	@ 0 "" 2
 1972              	.LVL114:
 1973              		.loc 1 666 6
 1974              		.arm
 1975              		.syntax unified
 1976              	.LBE5:
 1977              		.loc 1 666 5 is_stmt 0
 1978 0004 010013E3 		tst	r3, #1
 1979 0008 0400001A 		bne	.L137
 667:./trace32/udmon3.c **** 		udmon3_receive();
 668:./trace32/udmon3.c **** 
 669:./trace32/udmon3.c **** 	if(!DCC_SendStatus())      //Debugger Empfangsbereit?
 1980              		.loc 1 669 2 is_stmt 1
 1981              	.LBB6:
 1982              		.loc 1 669 6
 1983              		.loc 1 669 6
 1984              		.syntax divided
 1985              	@ 669 "./trace32/udmon3.c" 1
 1986 000c 103E10EE 		mrc p14, 0, r3, c0, c0
 1987              	@ 0 "" 2
 1988              	.LVL115:
 1989              		.loc 1 669 6
 1990              		.arm
 1991              		.syntax unified
 1992              	.LBE6:
 1993              		.loc 1 669 4 is_stmt 0
 1994 0010 020013E3 		tst	r3, #2
 1995 0014 1EFF2F11 		bxne	lr
 670:./trace32/udmon3.c **** 		udmon3_transmit();
 1996              		.loc 1 670 3 is_stmt 1
 1997 0018 30309FE5 		ldr	r3, .L139
 1998              	.LVL116:
 1999 001c 13FF2FE1 		bx	r3	@ indirect register sibling call
 2000              	.LVL117:
 2001              	.L137:
 667:./trace32/udmon3.c **** 		udmon3_receive();
 2002              		.loc 1 667 3
 664:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_ZYKLISCH
 2003              		.loc 1 664 1 is_stmt 0
 2004 0020 10402DE9 		push	{r4, lr}
 2005              		.cfi_def_cfa_offset 8
 2006              		.cfi_offset 4, -8
 2007              		.cfi_offset 14, -4
 667:./trace32/udmon3.c **** 		udmon3_receive();
 2008              		.loc 1 667 3
 2009 0024 28309FE5 		ldr	r3, .L139+4
 2010              	.LVL118:
 2011 0028 0FE0A0E1 		mov	lr, pc
 2012 002c 13FF2FE1 		bx	r3
 2013              	.LVL119:
 669:./trace32/udmon3.c **** 		udmon3_transmit();
 2014              		.loc 1 669 2 is_stmt 1
 2015              	.LBB7:
 669:./trace32/udmon3.c **** 		udmon3_transmit();
 2016              		.loc 1 669 6
 669:./trace32/udmon3.c **** 		udmon3_transmit();
 2017              		.loc 1 669 6
 2018              		.syntax divided
 2019              	@ 669 "./trace32/udmon3.c" 1
 2020 0030 103E10EE 		mrc p14, 0, r3, c0, c0
 2021              	@ 0 "" 2
 2022              	.LVL120:
 669:./trace32/udmon3.c **** 		udmon3_transmit();
 2023              		.loc 1 669 6
 2024              		.arm
 2025              		.syntax unified
 2026              	.LBE7:
 669:./trace32/udmon3.c **** 		udmon3_transmit();
 2027              		.loc 1 669 4 is_stmt 0
 2028 0034 020013E3 		tst	r3, #2
 2029 0038 0100000A 		beq	.L138
 671:./trace32/udmon3.c **** #endif
 672:./trace32/udmon3.c **** #if UDMON3_MODE == UDMON3_IRQ
 673:./trace32/udmon3.c **** 	
 674:./trace32/udmon3.c **** //	do {  So schnell ist der Debugger leider nicht
 675:./trace32/udmon3.c **** //        Stattdessen wird erst die ISR Verlassen um diese unmittelbar wieder
 676:./trace32/udmon3.c **** //        aufzurufen!
 677:./trace32/udmon3.c **** 		if(*AT91C_DBGU_CSR & *AT91C_DBGU_IMR & AT91C_US_COMM_RX)
 678:./trace32/udmon3.c **** 			udmon3_receive();
 679:./trace32/udmon3.c **** 		if(*AT91C_DBGU_CSR & *AT91C_DBGU_IMR & AT91C_US_COMM_TX)
 680:./trace32/udmon3.c **** 			udmon3_transmit();
 681:./trace32/udmon3.c **** //	} while(*AT91C_DBGU_CSR & *AT91C_DBGU_IMR & (AT91C_US_COMM_TX | AT91C_US_COMM_RX));
 682:./trace32/udmon3.c **** #endif
 683:./trace32/udmon3.c **** }
 2030              		.loc 1 683 1
 2031 003c 1040BDE8 		pop	{r4, lr}
 2032              		.cfi_remember_state
 2033              		.cfi_restore 14
 2034              		.cfi_restore 4
 2035              		.cfi_def_cfa_offset 0
 2036 0040 1EFF2FE1 		bx	lr
 2037              	.L138:
 2038              		.cfi_restore_state
 670:./trace32/udmon3.c **** #endif
 2039              		.loc 1 670 3 is_stmt 1
 2040 0044 04309FE5 		ldr	r3, .L139
 2041              	.LVL121:
 2042              		.loc 1 683 1 is_stmt 0
 2043 0048 1040BDE8 		pop	{r4, lr}
 2044              		.cfi_restore 14
 2045              		.cfi_restore 4
 2046              		.cfi_def_cfa_offset 0
 670:./trace32/udmon3.c **** #endif
 2047              		.loc 1 670 3
 2048 004c 13FF2FE1 		bx	r3	@ indirect register sibling call
 2049              	.LVL122:
 2050              	.L140:
 2051              		.align	2
 2052              	.L139:
 2053 0050 00000000 		.word	udmon3_transmit
 2054 0054 00000000 		.word	udmon3_receive
 2055              		.cfi_endproc
 2056              	.LFE20:
 2058              		.text
 2059              	.Letext0:
 2060              		.file 4 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/machi
 2061              		.file 5 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/_
 2062              		.file 6 "./trace32/../lib/aic.h"
 2063              		.file 7 "./trace32/../lib/display.h"
DEFINED SYMBOLS
                            *ABS*:00000000 udmon3.c
     /tmp/ccjiv7fx.s:19     .text.byte_fifo_put_possible:00000000 $a
     /tmp/ccjiv7fx.s:23     .text.byte_fifo_put_possible:00000000 byte_fifo_put_possible
     /tmp/ccjiv7fx.s:75     .text.byte_fifo_remain:00000000 $a
     /tmp/ccjiv7fx.s:79     .text.byte_fifo_remain:00000000 byte_fifo_remain
     /tmp/ccjiv7fx.s:133    .text.byte_fifo_used:00000000 $a
     /tmp/ccjiv7fx.s:137    .text.byte_fifo_used:00000000 byte_fifo_used
     /tmp/ccjiv7fx.s:188    .text.byte_fifo_put:00000000 $a
     /tmp/ccjiv7fx.s:192    .text.byte_fifo_put:00000000 byte_fifo_put
     /tmp/ccjiv7fx.s:277    .text.byte_fifo_get_possible:00000000 $a
     /tmp/ccjiv7fx.s:281    .text.byte_fifo_get_possible:00000000 byte_fifo_get_possible
     /tmp/ccjiv7fx.s:325    .text.byte_fifo_get:00000000 $a
     /tmp/ccjiv7fx.s:329    .text.byte_fifo_get:00000000 byte_fifo_get
     /tmp/ccjiv7fx.s:408    .text.byte_fifo_cb_put_possible:00000000 $a
     /tmp/ccjiv7fx.s:412    .text.byte_fifo_cb_put_possible:00000000 byte_fifo_cb_put_possible
     /tmp/ccjiv7fx.s:450    .text.byte_fifo_cb_put_possible:0000003c $d
     /tmp/ccjiv7fx.s:455    .text.byte_fifo_cb_put:00000000 $a
     /tmp/ccjiv7fx.s:459    .text.byte_fifo_cb_put:00000000 byte_fifo_cb_put
     /tmp/ccjiv7fx.s:520    .text.byte_fifo_cb_put:0000007c $d
     /tmp/ccjiv7fx.s:525    .text.byte_fifo_cb_get_possible:00000000 $a
     /tmp/ccjiv7fx.s:529    .text.byte_fifo_cb_get_possible:00000000 byte_fifo_cb_get_possible
     /tmp/ccjiv7fx.s:566    .text.byte_fifo_cb_get_possible:0000003c $d
     /tmp/ccjiv7fx.s:571    .text.byte_fifo_cb_get:00000000 $a
     /tmp/ccjiv7fx.s:575    .text.byte_fifo_cb_get:00000000 byte_fifo_cb_get
     /tmp/ccjiv7fx.s:614    .text.byte_fifo_cb_get:00000044 $d
     /tmp/ccjiv7fx.s:623    .bss:00000000 udmon3
     /tmp/ccjiv7fx.s:620    .bss:00000000 $d
     /tmp/ccjiv7fx.s:626    .text.udmon3_init:00000000 $a
     /tmp/ccjiv7fx.s:631    .text.udmon3_init:00000000 udmon3_init
     /tmp/ccjiv7fx.s:660    .text.udmon3_init:00000020 $d
     /tmp/ccjiv7fx.s:1957   .text.fastcode:00000000 udmon3_handler
     /tmp/ccjiv7fx.s:667    .text.udmon3_term_init:00000000 $a
     /tmp/ccjiv7fx.s:672    .text.udmon3_term_init:00000000 udmon3_term_init
     /tmp/ccjiv7fx.s:699    .text.udmon3_term_init:00000018 $d
     /tmp/ccjiv7fx.s:704    .text.Monitor_ReadByte:00000000 $a
     /tmp/ccjiv7fx.s:708    .text.Monitor_ReadByte:00000000 Monitor_ReadByte
     /tmp/ccjiv7fx.s:961    .text.Monitor_ReadByte:0000019c $d
     /tmp/ccjiv7fx.s:968    .text.Monitor_ReadHalf:00000000 $a
     /tmp/ccjiv7fx.s:972    .text.Monitor_ReadHalf:00000000 Monitor_ReadHalf
     /tmp/ccjiv7fx.s:1039   .text.Monitor_ReadWord:00000000 $a
     /tmp/ccjiv7fx.s:1043   .text.Monitor_ReadWord:00000000 Monitor_ReadWord
     /tmp/ccjiv7fx.s:1110   .text.Monitor_WriteByte:00000000 $a
     /tmp/ccjiv7fx.s:1114   .text.Monitor_WriteByte:00000000 Monitor_WriteByte
     /tmp/ccjiv7fx.s:1159   .text.Monitor_WriteHalf:00000000 $a
     /tmp/ccjiv7fx.s:1163   .text.Monitor_WriteHalf:00000000 Monitor_WriteHalf
     /tmp/ccjiv7fx.s:1207   .text.Monitor_WriteWord:00000000 $a
     /tmp/ccjiv7fx.s:1211   .text.Monitor_WriteWord:00000000 Monitor_WriteWord
     /tmp/ccjiv7fx.s:1255   .text.udmon3_receive:00000000 $a
     /tmp/ccjiv7fx.s:1259   .text.udmon3_receive:00000000 udmon3_receive
     /tmp/ccjiv7fx.s:1786   .text.udmon3_receive:000002b4 $d
     /tmp/ccjiv7fx.s:1801   .text.udmon3_transmit:00000000 $a
     /tmp/ccjiv7fx.s:1805   .text.udmon3_transmit:00000000 udmon3_transmit
     /tmp/ccjiv7fx.s:1946   .text.udmon3_transmit:000000d4 $d
     /tmp/ccjiv7fx.s:1952   .text.fastcode:00000000 $a
     /tmp/ccjiv7fx.s:2053   .text.fastcode:00000050 $d

UNDEFINED SYMBOLS
aic_sys_register_pit
display_get_buffer
