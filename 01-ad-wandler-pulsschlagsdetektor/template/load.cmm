//========================================================================
;  Configuration File (do load)
;  - Debugger Init
;  - Processor Init
;  - Processor Hardware Init
;  - Programmdownload to RAM/FLASH
;
; See also:
;  __TRACE32_INSTALL_DIR__/pdf/ide_user.pdf      //IDE Beschreibung
;  __TRACE32_INSTALL_DIR__/pdf/practice_user.pdf //Practice Grundlagen
;  __TRACE32_INSTALL_DIR__/pdf/practice_ref.pdf  //Befehlsbeschreibung
;  __TRACE32_INSTALL_DIR__/pdf/debugger_arm.pdf  
//========================================================================
; Practice Grundlagen (aus OneNotes ETC/Lauterbach/Debuggen)
; - Um Änderungen einfacher verfolgen zu können, bieten einige Fenster eine Spotlight Funktion an. Änderungen in einzelnen Bereich werden Farbig markiert. Ein schönes Beispiel ist das Register-Fenster, welches wie folgt gestartet wurde 'R.view /SPOTLIGHT '. 
; - Über die Track Funktion können Fenster 'synchronisiert' werden. 
;   d.dump /track -> zeigt den Speicherdump des im List-Fenster aktivierten Bereiches an
; - Durch eine Rechtsklick auf ein Fenster können die 'Aufrufparameter' des Fenster nachträglich geändert werden
; - Zahleneingabe 
; 	- Default im HEX-Format. Bei Zahlen beginnend mit a-d muss jedoch 0x vorangestellt werden
; 	- Binährzahlen      0y01X01
; 	- Dezimalzahlen   100.
; 	- Adressbereiche  start..stop   start--stop   start++laenge
; - Symboleingabe
; 	- Globale Symbole über deren Namen
; 	- Lokale Symbole über \dateiname(ohne Extension)\Funktionsname\Variablenname
; 	     v.view \udmon3\_term_hex\x
; 	- Lokale Symbole über Funktionsname\Variablenname
; 	     v.view task_idle\string
; 	- Bei Variablen können auch C-Ausdrücke zur Anzeige genutzt werden
; 	     v.view (SYSTICK_VL *)vl_head
;       v.view ((SYSTICK_VL *)vl_head)->next
; 	- d.dump reigster(r13)
; - Variablen Registeränderung -> doppelklick
; - Practice Macros basieren auf Textersetzung (ähnlich C-Makros)
; 	- Macros können nur innerhalb von Scripts und nicht in der CLI genutzt werden; 	- Ausdrücke
; 	- {} -> Entspricht () mit dem Unterschied, dass der Ausdruck in eine Konstante gewandelt wird
; 	- () -> Berechnet den Ausdruck mit der Besonderheit, dass bei Änderung einer Parameters der Ausdruck auch neu berechnet wird
; 		- Data.dump Register(PC)  --> Wenn PC sich ändert, wird der dumpberech angepasst
; - Sonstige Befehle
; 	- edit / pedit
; 	- dir / ls / pwd / dir / copy / mv / del / rm /  mkdir
; 	- type  / pack / tar / zip /  UNARchive / UNPACK / UNZIP
; - Import / Export von Fenster/Variablen in Dateien
; 	- Variable Speichern
; 		- var.export test.csv %hex %type trace_buf0 trace_buf1
; 	- Fensterinhalt speichern
; 		- Register.view ;optional step: open the window 
; 		- PRinTer.FILE ~~~\test.txt ;create and open a file for writing 
; 		- WinPrint.Register.view ;print the window contents to file 
; 		- TYPE ~~~\test.txt /LineNumbers ;open the file in the TYPE window
; - Profile (Grafische Ansicht von Variablen Historie)
; 	- Variable anzeigen über v.view %e systick_ms   
; 	- RechtsKlick -> Other -> profile
; - OS
; 	- os.command  zum Ausführen eines OS-Befehls
; 	- OS.Window dir /s &files
; - Bitmap Editor
; 	- BITMATEDIT
; - Pfadangaben
; 	- ./   .\   --> Aktuelles Arbeitsverzeichnis
; 	- ../ ..\  --> Parentverzeichnis
; 	- ~/  ~\  --> Home Directory of the User
; 	- ~~/ ~~\    --> System directory of TRACE32. 
; 	- ~~~/  +++\  --> Temporary directory for TRACE32 
; 	- ~~~~/  ~~~~\  --> Directory where the currently executed PRACTICE script is located


//========================================================================
; Variablen/Makro setzen

; Quelle: DVD\files\demo\arm\at91sam7s.cmm entnommen
; $Author: mobermeir $
; $Date: 2013-07-02 15:31:50 +0200 (Di, 02 Jul 2013) $
; $Rev: 2308 $
;----------------------------------------------------------------------
; Example for flash declaration of Atmel AT91SAM7S internal flash. 
; List of AT91SAM7S derivatives and their configuration:
; CPU-Type        FlashSize   Pagesize  SRAM size  Algorithm
;                  (Byte)      (Byte)     (Byte)
; -----------------------------------------------------------
; AT91SAM7S32      0x8000       0x80      0x2000   efcs.bin
; AT91SAM7S321     0x8000       0x80      0x2000   efcs.bin
; AT91SAM7S64     0x10000       0x80      0x4000   efcs.bin
; AT91SAM7S128    0x20000      0x100      0x8000   efcs2.bin
; AT91SAM7S256    0x40000      0x100     0x10000   efcs2.bin
; AT91SAM7S512    0x80000      0x100     0x10000   efcs2.bin
;
; The flash is divided into pages of 128 or 256 Byte. For derivatives 
; with 128 Byte sectors the flash algorithm binary efcs.bin has to be 
; used. For derivatives with 256 Byte sectors the flash algorithm 
; binary efcs2.bin has to be used.
;
; Internal flash is mirrowed to address 0x0 before remap command. 
; After remap command internal SRAM is mirrowed to address 0x0.

&ramstart=0x00200000
&flashstart=0x00100000
&flashsize=0x40000
&pagesize=0x100
;&flashalgorithm="~~/demo/arm/flash/long/efcs2.bin"
&flashalgorithm="__TRACE32_PATH__/efcs2.bin"

//========================================================================

SYStem.RESet

//========================================================================
; Debugger-Init

;Specify the CPU specific settings
;RAM_ONLY SYStem.CPU AT91SAM7S256
;ROM_ONLY SYStem.CPU AT91SAM7S256
;SIM_ONLY SYStem.CPU ARM7TDMI

;Set Memory Access during runtime via DCC
;RAM_ONLY SYStem.MemAccess TSMON3
;ROM_ONLY SYStem.MemAccess TSMON3

;Disable interrupts while single stepping
;If enabled, the interrupt mask bits of the CPU will be set during assembler single-step operations. 
;The interrupt routine is not executed during single-step operations. 
;After single step the interrupt mask bits are restored to the value before the step
;SYStem.Option IMASKASM [ON | OFF] (Default Off)

;Disable interrupts while HLL single stepping
;If enabled, the interrupt mask bits of the cpu will be set during HLL single-step operations. 
;The interrupt routine is not executed during single-step operations. 
;After single step the interrupt mask bits are restored to the value before the step.
;SYStem.Option IMASKHLL [ON | OFF]  (Default Off)

//========================================================================
; Processor-Init

;Use on-chip breakpoints
;Any breakpoints that touch the defined area will be implemented using on-chip resources. 
;This allows program breakpoints in read only memories or data breakpoints that also
;consider CPU internal operations. The capabilities of the on-chip breakpoints are CPU dependent.
;Inform the debugger about read only address ranges (ROM, FLASH).
MAP.BOnchip 0x00++0x1F   ;Softwarebreakpoints im Bereich der IVT funktionieren nicht!
;RAM_ONLY MAP.BOnchip &flashstart++(&flashsize-1)
;ROM_ONLY MAP.BOnchip &flashstart++(&flashsize-1)

;Sets/resets the corresponding bits in the vector catch register of the core. If the
;bit of a vector is set and the corresponding exception occurs, the processor
;enters debug state as if there had been a breakpoint set on an instruction fetch
;from that exception vector.
;ARM7TDMI unterstützt nachfolgende Option leider nicht, daher nur in Simulationsmode
;SIM_ONLY System.Option Alignment ON
;SIM_ONLY ;TrOnchip.Set RESET ON
;SIM_ONLY TrOnchip.Set DABORT ON
;SIM_ONLY TrOnchip.Set PABORT ON
;SIM_ONLY TrOnchip.Set SWI    ON
;SIM_ONLY TrOnchip.Set UNDEF  ON
;SIM_ONLY ;TrOnchip.Set FIQ ON
;SIM_ONLY ;TrOnchip.Set IRQ ON
;SIM_ONLY tronchip.set Alignment ON

//========================================================================
;Breakpoint bug fix required on ARM7TDMI-S Rev2:
;You need to activate this option when having an ARM7TDMI-S Rev2. The bug is fixed on Rev3 and
;following. With this option activated and ARM7TDMIS selected as CPU type, we enable the software
;breakpoint work around as described in the ARM errata of ARM7TDMI-S Rev2 (“consecutive breakpoint”
;bug). Software breakpoints are set as undefined opcodes that cause the core to enter the undefined opcode
;handler. The debugger tries to set a breakpoint at the undef vector (either software or on-chip). When a
;breakpoint is reached the core will take the undefined exception and stop at the vector. The debugger
;detects this state and displays the correct registers and cpu state. This work around is only suitable where
;undefined instruction trap handling is not being used.
;SYStem.Option BUGFIX

//========================================================================
// Terminal-Init

;Set Terminal Mode via DCC3
;RAM_ONLY TERM.METHOD DCC3	
;RAM_ONLY term.mode VT100
;ROM_ONLY TERM.METHOD DCC3	
;ROM_ONLY term.mode VT100
;SIM_ONLY TERM.METHOD DCC3	
;SIM_ONLY term.mode VT100

;Terminal display
;Opens the terminal emulation window. The protocol of the terminal is defined through TERM.METHOD
;term.view -> erfolgt in window.cmm

TERM.SIZE   120. 25. 100.
TERM.SCROLL ON   ;Enable automatic scrolling for terminal window

;Send data to virtual terminal
;TERM.Out [<channel>] <string> …

;Connect terminal to named pipe
;TERM.PIPE [<channel>] <pipename>

;Route terminal input/output to TCP port
;TERM.TCP [<channel>] <port>

;Trigger on string in terminal window
;Sets a trigger for the occurrence of a specific string in the terminal window. 
;The function TERM.TRIGGERED() returns if the trigger has occurred or not.
;TERM.TRIGGER [<channel>] <message_string>

//========================================================================
;Ports dienen zur Darstellung von Prozessorsignale im InCircuitEmulator und 
;im Simulator. Ports haben eine Ähnlichkeit zur TraceSignalen,
;bei welchen über einen LogicAnalyser digitale Signale mitgeschnitten werden können.
;(Letzter fallen jedoch unter die Kategorie Trace) (Defintion Justen)
;Im Simulator werden Ports zur Darstellung der Hardware genutzt, so dass
;- über diese die Ein-/Ausgabe simuliert werden kann 
;- die Kommunikation zwischen der den Peripherie-Bausteinen erfolgen kann
;- Lesen/Schreiben der Ports über port.get
;Ports werden über Nummern von p.0 bis p.511 angesprochen. Über NAME können
;den Ports (und external Probes, State Analyser und Port Analyser) Alias-Namen vergeben werden.

;Konfigurationsdatei (mit Namensauflösung) laden
;SIM_ONLY do __TRACE32_PATH__/sim_NXT/sim_NXT.cmm
;RAM_ONLY ;Keine Port-Einheit verfügbar, so dass hier nichts definiert werden muss
;ROM_ONLY ;Keine Port-Einheit verfügbar, so dass hier nichts definiert werden muss

;Beispiele für Nutzung der Ports
;SIM_ONLY port.arm          //Zum Starten der Aufzeichnung
;port.timing g.NXT_SENSOR   //-> erfolgt in window.cmm
;port.set  p.PA18 High|Low  //Setzen/Löschen von Leitungen

//========================================================================
;Im Simulationsmode wird nur der Prozessor simuliert. Die Perpherie 
;und das Board (hier NXT) sind nicht Betandteil der Simulationsumgebung. 
;Passendes Simulationsmodell hierfür nachladen (Inhalt vom sim_NXT Verzeichnis)
;SIM_ONLY sim.res
;SIMWINDOWS_ONLY sim.load __TRACE32_PATH__/sim_NXT/sim_NXT.dll 20000 0
;SIMLINUX_ONLY sim.load __TRACE32_PATH__/sim_NXT/sim_NXT.so 20000 0
;SIMMACOS_ONLY sim.load __TRACE32_PATH__/sim_NXT/sim_NXT.so 20000 0

;Beschreibungsdatei für Peripherie nachladen
;SIM_ONLY per.reprogram __TRACE32_PATH__/sim_NXT/sim_NXT.per
;RAM_ONLY per.reprogram __TRACE32_PATH__/perat91sam7sx.per
;ROM_ONLY per.reprogram __TRACE32_PATH__/perat91sam7sx.per

//========================================================================
; Verbindung mit dem Prozessor herstellen
SYStem.Up

//========================================================================
; Prozessor Hardware Initialisieren, so das Debugger Vollzugriff hat
; (entspricht u.A. dem, was in low_level_init() getätigt wird)
;- Speicher Zugriff aktivieren, so dass Debugger Programm in diesen Bereich laden kann
;- Notwendige Peripherie initialisieren
;- Watchdog deaktivieren

;RAM Zugriff setzen
;- RAM steht bereits im Vollzugriff, so dass hier nichts gemacht werden muss

;FLASH Zugriff setzen
;- Flash steht bereits im Vollzugriff, allerdings aufgrund der Waitstates sehr langsam
;  Da Flash-Brenner die Zugriffszeit ggf. anpasst, erfolgt hier keine Änderung

;Prozessortakt hochsetzen
;- Zum Übertragen von max. 64kByte ist die JTAG Übertragungszeit größer als 
;  die Prozessorzugriffszeit. Daher keine Anpassung

;Disable watchdog for flash programming if watchdog may be used in window mode.
;ROM_ONLY DATA.SET 0xFFFFFD44 %LONG DATA.LONG(ASD:0xFFFFFD44)|0x00008000

; Disable TICK (PA17 PULL Up)
;RAM_ONLY PER.SET C:0xFFFFF460 %LONG 0x00020000
;ROM_ONLY PER.SET C:0xFFFFF460 %LONG 0x00020000

//========================================================================
; Programmdownload to RAM/FLASH Vorbereitung (insb. für Flash)

;Zum Übertragen ins den Flash muss dieser zunächst 'vorbereitet' werden
;  Quelle: DVD\files\demo\arm\at91sam7s.cmm
;- Locked pages can be unlocked with FLASH.UNLOCK command and can be 
;  locked again with FLASH.LOCK command.
;- Watchdog is critical for flash programming. The flash algorithm is 
;  serving the watchdog if the watchdog is not used in window mode.
;- If the watchdog is setup to window mode by a running application 
;  the watchdog should be either disbaled after first power-up or the 
;  board should be power-up before every flash programming. If the 
;  watchdog is disabled after power-up it cannot be enabled again by 
;  the application because WDT_MR register is write once. Please see 
;  below the command to disable the watchdog.
;ROM_ONLY FLASH.RESet
;ROM_ONLY IF &flashsize<=0x40000
;ROM_ONLY (
;ROM_ONLY   FLASH.Create 1. &flashstart++(&flashsize-1) &pagesize TARGET Long
;ROM_ONLY )
;ROM_ONLY ELSE
;ROM_ONLY (
;ROM_ONLY   ; Bank EFC0
;ROM_ONLY   FLASH.Create 1. &flashstart++0x3ffff &pagesize TARGET Long 0.
;ROM_ONLY   ; Bank EFC1
;ROM_ONLY   FLASH.Create 2. (&flashstart+0x40000)++(&flashsize-0x40000-1) &pagesize TARGET Long 1.
;ROM_ONLY )
;ROM_ONLY ;flash.target <code_range> <ata_range> <buffer_size> <file>
;ROM_ONLY FLASH.TARGET &ramstart &ramstart+0x800 0x1000 &flashalgorithm
;ROM_ONLY ;FLASH.TARGET 0x00200000 0x00200800 0x1000 &flashalgorithm

;Flash NVM bit programming example
;ROM_ONLY ;DIALOG.YESNO "Program flash NVM bits"
;ROM_ONLY ;ENTRY &prognvm
;ROM_ONLY ;IF &prognvm 
;ROM_ONLY ;(
;ROM_ONLY ;  DO __TRACE32_PATH__/at91sam7-nvm
;ROM_ONLY ;)

;Unlock locked pages if necessary
;ROM_ONLY ;FLASH.UNLOCK ALL

;ROM_ONLY FLASH.Erase.ALL
;ROM_ONLY FLASH.Program.ALL

; Programmdownload to RAM/FLASH 
;- Wenn unter Linux compiliert wird, der Debugger jedoch unter Windows
;  läuft, sind im ELF File ungültige absolute Pathangaben enthalten,
;  die beim Laden korrigiert werden müssen
;- NewLib wurde ggf. mit -g compiliert, so dass Debug-Informationen enthalten sind
;  Pfadangaben sind jedoch die des Erstellrechners, so dass diese ebenfalls 
;  beim Laden korrigiert werden müssen
;  ftp://sourceware.org/pub/newlib/
;- siehe >>symbol.list.source
;- siehe auch: https://www2.lauterbach.com/pdf/training_hll.pdf
Data.LOAD  __INPUT_FILE__  /STRIPPART "__WORKING_DIR__" /PATH . 
;Data.LOAD __INPUT_FILE__  /STRIPPART "__WORKING_DIR__" /PATH . /STRIPPART "\build\newlib-CVVEyx" /PATH ..


; Programmdownload to RAM/FLASH Nachbereitung (insb. für Flash)
;ROM_ONLY FLASH.Program.off

; ProgrammCounter setzen
;Register.Set pc ivt_boot ;Nicht nötigt, da trace32 den PC entsprechend 
                          ;dem Eintrag 'ENTRY(ivt_boot)' aus dem LinkerScript setzt

;========================================================================
;Zur Simulation eines Parameterspeichers, der nach PowerOn seinen alten Wert beibehält 
;RAM_ONLY if File.Exist(data.bin)
;RAM_ONLY    (
;RAM_ONLY    d.load.BINARY data.bin 0x20ff00 /nosymbol
;RAM_ONLY    print "ParameterRAM mit 'do save' speichern nicht vergessen"
;RAM_ONLY    )
;SIM_ONLY if File.Exist(data.bin)
;SIM_ONLY    (
;SIM_ONLY    d.load.BINARY data.bin 0x20ff00 /nosymbol
;SIM_ONLY    print "ParameterRAM mit 'do save' speichern nicht vergessen"
;SIM_ONLY    )

ENDDO
