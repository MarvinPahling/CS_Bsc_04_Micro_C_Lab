   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"low_level_init.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "low_level_init.c"
  18              		.section	.text.low_level_init,"ax",%progbits
  19              		.align	2
  20              		.global	low_level_init
  21              		.syntax unified
  22              		.arm
  24              	low_level_init:
  25              	.LFB2:
   1:low_level_init.c **** /*****************************************************************************
   2:low_level_init.c **** * Product: QDK/C_ARM-GNU_AT91SAM7S-EK
   3:low_level_init.c **** * Last Updated for Version: 4.4.00
   4:low_level_init.c **** * Date of the Last Update:  Feb 26, 2012
   5:low_level_init.c **** *
   6:low_level_init.c **** *                    Q u a n t u m     L e a P s
   7:low_level_init.c **** *                    ---------------------------
   8:low_level_init.c **** *                    innovating embedded systems
   9:low_level_init.c **** *
  10:low_level_init.c **** * Copyright (C) 2002-2012 Quantum Leaps, LLC. All rights reserved.
  11:low_level_init.c **** *
  12:low_level_init.c **** * This software may be distributed and modified under the terms of the GNU
  13:low_level_init.c **** * General Public License version 2 (GPL) as published by the Free Software
  14:low_level_init.c **** * Foundation and appearing in the file GPL.TXT included in the packaging of
  15:low_level_init.c **** * this file. Please note that GPL Section 2[b] requires that all works based
  16:low_level_init.c **** * on this software must also be made publicly available under the terms of
  17:low_level_init.c **** * the GPL ("Copyleft").
  18:low_level_init.c **** *
  19:low_level_init.c **** * Alternatively, this software may be distributed and modified under the
  20:low_level_init.c **** * terms of Quantum Leaps commercial licenses, which expressly supersede
  21:low_level_init.c **** * the GPL and are specifically designed for licensees interested in
  22:low_level_init.c **** * retaining the proprietary status of their code.
  23:low_level_init.c **** *
  24:low_level_init.c **** * Contact information:
  25:low_level_init.c **** * Quantum Leaps Web site:  http://www.quantum-leaps.com
  26:low_level_init.c **** * e-mail:                  info@quantum-leaps.com
  27:low_level_init.c **** *****************************************************************************/
  28:low_level_init.c **** #include <stdint.h>
  29:low_level_init.c **** #include "AT91SAM7S64.h"                        /* AT91SAMT7S64 definitions */
  30:low_level_init.c **** #include "main.h"
  31:low_level_init.c **** 
  32:low_level_init.c **** #define LDR_PC_PC  0xE59FF000U   //LDR pc,[pc,#xxx]
  33:low_level_init.c **** #define MAGIC      0xDEADBEEFU
  34:low_level_init.c **** 
  35:low_level_init.c **** /*..........................................................................*/
  36:low_level_init.c **** /* low_level_init() is invoked by the startup sequence after initializing
  37:low_level_init.c **** * the C stack, but before initializing the segments in RAM.
  38:low_level_init.c **** *
  39:low_level_init.c **** * low_level_init() is invoked in the ARM state. The function gives the
  40:low_level_init.c **** * application a chance to perform early initializations of the hardware.
  41:low_level_init.c **** * This function cannot rely on initialization of any static variables,
  42:low_level_init.c **** * because these have not yet been initialized in RAM.
  43:low_level_init.c **** */
  44:low_level_init.c **** void low_level_init(void (*reset_addr)()) 
  45:low_level_init.c **** {
  26              		.loc 1 45 1
  27              		.cfi_startproc
  28              		@ Function supports interworking.
  29              		@ args = 0, pretend = 0, frame = 16
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 04B02DE5 		str	fp, [sp, #-4]!
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 11, -4
  35 0004 00B08DE2 		add	fp, sp, #0
  36              		.cfi_def_cfa_register 11
  37 0008 14D04DE2 		sub	sp, sp, #20
  38 000c 10000BE5 		str	r0, [fp, #-16]
  46:low_level_init.c **** 	
  47:low_level_init.c **** #ifndef MODE_SIM
  48:low_level_init.c **** /* Bei Samba ist der Prozessor schon auf 48MHz gestellt (andernfalls */
  49:low_level_init.c **** /* würde USB nicht laufen). Allerdings läuft der Timer nicht mit der */
  50:low_level_init.c **** /* erwarteten Frequenz, so dass diese Initialisierung durchgeführt wird */
  51:low_level_init.c **** /* #ifndef MODE_SAMBA */
  52:low_level_init.c ****     AT91PS_PMC pPMC;
  53:low_level_init.c **** 
  54:low_level_init.c ****     /* Set flash wait sate FWS and FMCN 
  55:low_level_init.c **** 	* MCK=47923200 (wird in bsp.h gesetzt)
  56:low_level_init.c **** 	* 2 cycles for Read, 3 for Write operations
  57:low_level_init.c **** 	*/	
  58:low_level_init.c ****     AT91C_BASE_MC->MC_FMR = ((AT91C_MC_FMCN) & ((MCK + 500000)/1000000 << 16))
  39              		.loc 1 58 18
  40 0010 FF30E0E3 		mvn	r3, #255
  41              		.loc 1 58 27
  42 0014 B4219FE5 		ldr	r2, .L9
  43 0018 602083E5 		str	r2, [r3, #96]
  59:low_level_init.c ****                              | AT91C_MC_FWS_1FWS;
  60:low_level_init.c **** 
  61:low_level_init.c ****     /* Enable External Reset */
  62:low_level_init.c ****     AT91C_BASE_RSTC->RSTC_RMR = 0xA5000001;
  44              		.loc 1 62 20
  45 001c B0319FE5 		ldr	r3, .L9+4
  46              		.loc 1 62 31
  47 0020 B0219FE5 		ldr	r2, .L9+8
  48 0024 082083E5 		str	r2, [r3, #8]
  63:low_level_init.c **** 	
  64:low_level_init.c ****     /* Enable the Main Oscillator:
  65:low_level_init.c ****     * set OSCOUNT to 6, which gives Start up time = 8 * 6 / SCK = 1.4ms
  66:low_level_init.c ****     * (SCK = 32768Hz)
  67:low_level_init.c ****     */
  68:low_level_init.c ****     pPMC = AT91C_BASE_PMC;
  49              		.loc 1 68 10
  50 0028 AC319FE5 		ldr	r3, .L9+12
  51 002c 08300BE5 		str	r3, [fp, #-8]
  69:low_level_init.c ****     pPMC->PMC_MOR = ((6 << 8) & AT91C_CKGR_OSCOUNT) | AT91C_CKGR_MOSCEN;
  52              		.loc 1 69 19
  53 0030 08301BE5 		ldr	r3, [fp, #-8]
  54 0034 A4219FE5 		ldr	r2, .L9+16
  55 0038 202083E5 		str	r2, [r3, #32]
  70:low_level_init.c ****     while ((pPMC->PMC_SR & AT91C_PMC_MOSCS) == 0); /* Wait the startup time */
  56              		.loc 1 70 11
  57 003c 0000A0E1 		nop
  58              	.L2:
  59              		.loc 1 70 17 discriminator 1
  60 0040 08301BE5 		ldr	r3, [fp, #-8]
  61 0044 683093E5 		ldr	r3, [r3, #104]
  62              		.loc 1 70 26 discriminator 1
  63 0048 013003E2 		and	r3, r3, #1
  64              		.loc 1 70 45 discriminator 1
  65 004c 000053E3 		cmp	r3, #0
  66 0050 FAFFFF0A 		beq	.L2
  71:low_level_init.c **** 
  72:low_level_init.c ****     /* Set the PLL and Divider:
  73:low_level_init.c ****     * - div by 5 Fin = 3,6864 =(18,432 / 5)
  74:low_level_init.c ****     * - Mul 25+1: Fout = 95,8464 =(3,6864 *26)
  75:low_level_init.c ****     * for 96 MHz the error is 0.16%
  76:low_level_init.c ****     * Field out NOT USED = 0
  77:low_level_init.c ****     * PLLCOUNT pll startup time estimate at : 0.844 ms
  78:low_level_init.c ****     * PLLCOUNT 28 = 0.000844 /(1/32768)
  79:low_level_init.c ****     */
  80:low_level_init.c ****     pPMC->PMC_PLLR = ((AT91C_CKGR_DIV & 0x05)
  67              		.loc 1 80 20
  68 0054 08301BE5 		ldr	r3, [fp, #-8]
  69 0058 84219FE5 		ldr	r2, .L9+20
  70 005c 2C2083E5 		str	r2, [r3, #44]
  81:low_level_init.c ****                       | (AT91C_CKGR_PLLCOUNT & (28 << 8))
  82:low_level_init.c ****                       | (AT91C_CKGR_MUL & (25 << 16)));
  83:low_level_init.c ****     while ((pPMC->PMC_SR & AT91C_PMC_LOCK) == 0); /* Wait the startup time */
  71              		.loc 1 83 11
  72 0060 0000A0E1 		nop
  73              	.L3:
  74              		.loc 1 83 17 discriminator 1
  75 0064 08301BE5 		ldr	r3, [fp, #-8]
  76 0068 683093E5 		ldr	r3, [r3, #104]
  77              		.loc 1 83 26 discriminator 1
  78 006c 043003E2 		and	r3, r3, #4
  79              		.loc 1 83 44 discriminator 1
  80 0070 000053E3 		cmp	r3, #0
  81 0074 FAFFFF0A 		beq	.L3
  84:low_level_init.c ****     while ((pPMC->PMC_SR & AT91C_PMC_MCKRDY) == 0);
  82              		.loc 1 84 11
  83 0078 0000A0E1 		nop
  84              	.L4:
  85              		.loc 1 84 17 discriminator 1
  86 007c 08301BE5 		ldr	r3, [fp, #-8]
  87 0080 683093E5 		ldr	r3, [r3, #104]
  88              		.loc 1 84 26 discriminator 1
  89 0084 083003E2 		and	r3, r3, #8
  90              		.loc 1 84 46 discriminator 1
  91 0088 000053E3 		cmp	r3, #0
  92 008c FAFFFF0A 		beq	.L4
  85:low_level_init.c **** 
  86:low_level_init.c ****     /* Select Master Clock and CPU Clock select the PLL clock / 2 */
  87:low_level_init.c ****     pPMC->PMC_MCKR =  AT91C_PMC_PRES_CLK_2;
  93              		.loc 1 87 20
  94 0090 08301BE5 		ldr	r3, [fp, #-8]
  95 0094 0420A0E3 		mov	r2, #4
  96 0098 302083E5 		str	r2, [r3, #48]
  88:low_level_init.c ****     while ((pPMC->PMC_SR & AT91C_PMC_MCKRDY) == 0);
  97              		.loc 1 88 11
  98 009c 0000A0E1 		nop
  99              	.L5:
 100              		.loc 1 88 17 discriminator 1
 101 00a0 08301BE5 		ldr	r3, [fp, #-8]
 102 00a4 683093E5 		ldr	r3, [r3, #104]
 103              		.loc 1 88 26 discriminator 1
 104 00a8 083003E2 		and	r3, r3, #8
 105              		.loc 1 88 46 discriminator 1
 106 00ac 000053E3 		cmp	r3, #0
 107 00b0 FAFFFF0A 		beq	.L5
  89:low_level_init.c **** 
  90:low_level_init.c ****     pPMC->PMC_MCKR |= AT91C_PMC_CSS_PLL_CLK;
 108              		.loc 1 90 9
 109 00b4 08301BE5 		ldr	r3, [fp, #-8]
 110 00b8 303093E5 		ldr	r3, [r3, #48]
 111              		.loc 1 90 20
 112 00bc 032083E3 		orr	r2, r3, #3
 113 00c0 08301BE5 		ldr	r3, [fp, #-8]
 114 00c4 302083E5 		str	r2, [r3, #48]
  91:low_level_init.c ****     while ((pPMC->PMC_SR & AT91C_PMC_MCKRDY) == 0);
 115              		.loc 1 91 11
 116 00c8 0000A0E1 		nop
 117              	.L6:
 118              		.loc 1 91 17 discriminator 1
 119 00cc 08301BE5 		ldr	r3, [fp, #-8]
 120 00d0 683093E5 		ldr	r3, [r3, #104]
 121              		.loc 1 91 26 discriminator 1
 122 00d4 083003E2 		and	r3, r3, #8
 123              		.loc 1 91 46 discriminator 1
 124 00d8 000053E3 		cmp	r3, #0
 125 00dc FAFFFF0A 		beq	.L6
  92:low_level_init.c **** 	
  93:low_level_init.c **** #endif
  94:low_level_init.c **** 
  95:low_level_init.c ****     /* Initialsisierung der Applikations-IVT */
  96:low_level_init.c **** 	
  97:low_level_init.c ****     extern uint32_t ivt_app[2][8];  //Wird wahlweise über link.ld oder startup.s gesezt
  98:low_level_init.c **** 	                                //Zeigt auf die Startadresse der IVT, welche zur 
  99:low_level_init.c **** 						    	    //Laufzeit beschrieben werden kann
 100:low_level_init.c ****  
 101:low_level_init.c ****     /* setup the primary vector table in RAM */
 102:low_level_init.c ****     //*((uint32_t *) 0x00) = LDR_PC_PC | 0x18;   Andernfalls baut der Compiler hier 
 103:low_level_init.c **** 	//                                           ein 'breapoint' ein
 104:low_level_init.c ****     ivt_app[0][0] = LDR_PC_PC | 0x18;
 126              		.loc 1 104 19
 127 00e0 00319FE5 		ldr	r3, .L9+24
 128 00e4 00219FE5 		ldr	r2, .L9+28
 129 00e8 002083E5 		str	r2, [r3]
 105:low_level_init.c ****     ivt_app[0][1] = LDR_PC_PC | 0x18;
 130              		.loc 1 105 19
 131 00ec F4309FE5 		ldr	r3, .L9+24
 132 00f0 F4209FE5 		ldr	r2, .L9+28
 133 00f4 042083E5 		str	r2, [r3, #4]
 106:low_level_init.c ****     ivt_app[0][2] = LDR_PC_PC | 0x18;
 134              		.loc 1 106 19
 135 00f8 E8309FE5 		ldr	r3, .L9+24
 136 00fc E8209FE5 		ldr	r2, .L9+28
 137 0100 082083E5 		str	r2, [r3, #8]
 107:low_level_init.c ****     ivt_app[0][3] = LDR_PC_PC | 0x18;
 138              		.loc 1 107 19
 139 0104 DC309FE5 		ldr	r3, .L9+24
 140 0108 DC209FE5 		ldr	r2, .L9+28
 141 010c 0C2083E5 		str	r2, [r3, #12]
 108:low_level_init.c ****     ivt_app[0][4] = LDR_PC_PC | 0x18;
 142              		.loc 1 108 19
 143 0110 D0309FE5 		ldr	r3, .L9+24
 144 0114 D0209FE5 		ldr	r2, .L9+28
 145 0118 102083E5 		str	r2, [r3, #16]
 109:low_level_init.c ****     ivt_app[0][5] = MAGIC;
 146              		.loc 1 109 19
 147 011c C4309FE5 		ldr	r3, .L9+24
 148 0120 C8209FE5 		ldr	r2, .L9+32
 149 0124 142083E5 		str	r2, [r3, #20]
 110:low_level_init.c ****     ivt_app[0][6] = LDR_PC_PC | 0x18;
 150              		.loc 1 110 19
 151 0128 B8309FE5 		ldr	r3, .L9+24
 152 012c B8209FE5 		ldr	r2, .L9+28
 153 0130 182083E5 		str	r2, [r3, #24]
 111:low_level_init.c ****     ivt_app[0][7] = LDR_PC_PC | 0x18;
 154              		.loc 1 111 19
 155 0134 AC309FE5 		ldr	r3, .L9+24
 156 0138 AC209FE5 		ldr	r2, .L9+28
 157 013c 1C2083E5 		str	r2, [r3, #28]
 112:low_level_init.c **** 
 113:low_level_init.c ****     /* setup the secondary vector table in RAM */
 114:low_level_init.c ****     ivt_app[1][0] = (uint32_t)reset_addr;
 158              		.loc 1 114 21
 159 0140 10301BE5 		ldr	r3, [fp, #-16]
 160              		.loc 1 114 19
 161 0144 9C209FE5 		ldr	r2, .L9+24
 162 0148 203082E5 		str	r3, [r2, #32]
 115:low_level_init.c ****     ivt_app[1][1] = 0x04U;  //Hier Sprung zu sich selbst <-> while(1)
 163              		.loc 1 115 19
 164 014c 94309FE5 		ldr	r3, .L9+24
 165 0150 0420A0E3 		mov	r2, #4
 166 0154 242083E5 		str	r2, [r3, #36]
 116:low_level_init.c ****     ivt_app[1][2] = 0x08U;  //Eigentliche Einträge erfolgen durch aic.c
 167              		.loc 1 116 19
 168 0158 88309FE5 		ldr	r3, .L9+24
 169 015c 0820A0E3 		mov	r2, #8
 170 0160 282083E5 		str	r2, [r3, #40]
 117:low_level_init.c ****     ivt_app[1][3] = 0x0CU;  
 171              		.loc 1 117 19
 172 0164 7C309FE5 		ldr	r3, .L9+24
 173 0168 0C20A0E3 		mov	r2, #12
 174 016c 2C2083E5 		str	r2, [r3, #44]
 118:low_level_init.c ****     ivt_app[1][4] = 0x10U;
 175              		.loc 1 118 19
 176 0170 70309FE5 		ldr	r3, .L9+24
 177 0174 1020A0E3 		mov	r2, #16
 178 0178 302083E5 		str	r2, [r3, #48]
 119:low_level_init.c ****     ivt_app[1][5] = MAGIC;
 179              		.loc 1 119 19
 180 017c 64309FE5 		ldr	r3, .L9+24
 181 0180 68209FE5 		ldr	r2, .L9+32
 182 0184 342083E5 		str	r2, [r3, #52]
 120:low_level_init.c ****     ivt_app[1][6] = 0x18U;
 183              		.loc 1 120 19
 184 0188 58309FE5 		ldr	r3, .L9+24
 185 018c 1820A0E3 		mov	r2, #24
 186 0190 382083E5 		str	r2, [r3, #56]
 121:low_level_init.c ****     ivt_app[1][7] = 0x1CU;
 187              		.loc 1 121 19
 188 0194 4C309FE5 		ldr	r3, .L9+24
 189 0198 1C20A0E3 		mov	r2, #28
 190 019c 3C2083E5 		str	r2, [r3, #60]
 122:low_level_init.c **** 
 123:low_level_init.c **** #ifndef MODE_SIM
 124:low_level_init.c ****     /* check if the Memory Controller has been remapped already */
 125:low_level_init.c **** 	/* Wird benötigt, da später die Vector-Tabelle auf Adresse 0 überschrieben wird */
 126:low_level_init.c ****     if (MAGIC != (*(uint32_t volatile *)0x14)) {
 191              		.loc 1 126 19
 192 01a0 1430A0E3 		mov	r3, #20
 193 01a4 003093E5 		ldr	r3, [r3]
 194              		.loc 1 126 8
 195 01a8 40209FE5 		ldr	r2, .L9+32
 196 01ac 020053E1 		cmp	r3, r2
 197 01b0 0200000A 		beq	.L8
 127:low_level_init.c ****         AT91C_BASE_MC->MC_RCR = 1;   /* perform Memory Controller remapping */
 198              		.loc 1 127 22
 199 01b4 FF30E0E3 		mvn	r3, #255
 200              		.loc 1 127 31
 201 01b8 0120A0E3 		mov	r2, #1
 202 01bc 002083E5 		str	r2, [r3]
 203              	.L8:
 128:low_level_init.c ****     }
 129:low_level_init.c **** #endif
 130:low_level_init.c **** }
 204              		.loc 1 130 1
 205 01c0 0000A0E1 		nop
 206 01c4 00D08BE2 		add	sp, fp, #0
 207              		.cfi_def_cfa_register 13
 208              		@ sp needed
 209 01c8 04B09DE4 		ldr	fp, [sp], #4
 210              		.cfi_restore 11
 211              		.cfi_def_cfa_offset 0
 212 01cc 1EFF2FE1 		bx	lr
 213              	.L10:
 214              		.align	2
 215              	.L9:
 216 01d0 00013000 		.word	3145984
 217 01d4 00FDFFFF 		.word	-768
 218 01d8 010000A5 		.word	-1526726655
 219 01dc 00FCFFFF 		.word	-1024
 220 01e0 01060000 		.word	1537
 221 01e4 051C1900 		.word	1645573
 222 01e8 00000000 		.word	ivt_app
 223 01ec 18F09FE5 		.word	-442503144
 224 01f0 EFBEADDE 		.word	-559038737
 225              		.cfi_endproc
 226              	.LFE2:
 228              		.text
 229              	.Letext0:
 230              		.file 2 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/machi
 231              		.file 3 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/_
 232              		.file 4 "AT91SAM7S64.h"
DEFINED SYMBOLS
                            *ABS*:00000000 low_level_init.c
     /tmp/ccPA8J0r.s:19     .text.low_level_init:00000000 $a
     /tmp/ccPA8J0r.s:24     .text.low_level_init:00000000 low_level_init
     /tmp/ccPA8J0r.s:216    .text.low_level_init:000001d0 $d

UNDEFINED SYMBOLS
ivt_app
