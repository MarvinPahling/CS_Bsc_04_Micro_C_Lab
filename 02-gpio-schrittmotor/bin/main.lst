   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "main.c"
  18              		.section	.text.byte_fifo_put_possible,"ax",%progbits
  19              		.align	2
  20              		.syntax unified
  21              		.arm
  23              	byte_fifo_put_possible:
  24              	.LFB5:
  25              		.file 2 "trace32/../lib/byte_fifo.h"
   1:trace32/../lib/byte_fifo.h **** /* Byte FIFO queue implementation.
   2:trace32/../lib/byte_fifo.h ****  *
   3:trace32/../lib/byte_fifo.h ****  * Implements a simple reader/write save byte FIFO on top of a data buffer, that lets
   4:trace32/../lib/byte_fifo.h ****  * you enqueue and dequeue single bytes.
   5:trace32/../lib/byte_fifo.h ****  */
   6:trace32/../lib/byte_fifo.h **** 
   7:trace32/../lib/byte_fifo.h **** #ifndef __BYTE_FIFO_H__
   8:trace32/../lib/byte_fifo.h **** #define __BYTE_FIFO_H__
   9:trace32/../lib/byte_fifo.h **** 
  10:trace32/../lib/byte_fifo.h **** 
  11:trace32/../lib/byte_fifo.h **** typedef struct
  12:trace32/../lib/byte_fifo.h **** {
  13:trace32/../lib/byte_fifo.h **** 	unsigned short rd;
  14:trace32/../lib/byte_fifo.h **** 	unsigned short wr;
  15:trace32/../lib/byte_fifo.h ****     unsigned short mask;
  16:trace32/../lib/byte_fifo.h **** 	unsigned char  buf[];
  17:trace32/../lib/byte_fifo.h **** } byte_fifo_t;
  18:trace32/../lib/byte_fifo.h **** 
  19:trace32/../lib/byte_fifo.h **** #define TEST_2erPOTENZ(x) (((x) & ((x) - 1))?0:(x))
  20:trace32/../lib/byte_fifo.h **** #define TEST_64k(x)       ((x)>0x10000?0:(x))
  21:trace32/../lib/byte_fifo.h **** #define TEST_SIZE(x)      (TEST_64k(TEST_2erPOTENZ(x)))
  22:trace32/../lib/byte_fifo.h **** 
  23:trace32/../lib/byte_fifo.h **** //size muss einer 2er Potenzzahl sein, andernfalls gibt der Compiler
  24:trace32/../lib/byte_fifo.h **** //die Fehlermeldung aus, dass die Array-Größe (hier -1) ungültit ist
  25:trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_INIT(size)  (byte_fifo_t) {.rd=0,\
  26:trace32/../lib/byte_fifo.h ****                                              .wr=0,\
  27:trace32/../lib/byte_fifo.h **** 						        	         .mask=TEST_SIZE(size)-1,\
  28:trace32/../lib/byte_fifo.h **** 								    		 .buf={[TEST_SIZE(size)-1]=0}\
  29:trace32/../lib/byte_fifo.h **** 									    	}
  30:trace32/../lib/byte_fifo.h **** 
  31:trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_TYPEOF_RDWR typeof (((byte_fifo_t *)0)->rd)
  32:trace32/../lib/byte_fifo.h **** 
  33:trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic push
  34:trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  35:trace32/../lib/byte_fifo.h **** 
  36:trace32/../lib/byte_fifo.h **** static int byte_fifo_put_possible(byte_fifo_t *fifo)
  37:trace32/../lib/byte_fifo.h **** {
  26              		.loc 2 37 1
  27              		.cfi_startproc
  28              		@ Function supports interworking.
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 04B02DE5 		str	fp, [sp, #-4]!
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 11, -4
  35 0004 00B08DE2 		add	fp, sp, #0
  36              		.cfi_def_cfa_register 11
  37 0008 0CD04DE2 		sub	sp, sp, #12
  38 000c 08000BE5 		str	r0, [fp, #-8]
  38:trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
  39              		.loc 2 38 11
  40 0010 08301BE5 		ldr	r3, [fp, #-8]
  41 0014 B230D3E1 		ldrh	r3, [r3, #2]
  42              		.loc 2 38 15
  43 0018 013083E2 		add	r3, r3, #1
  44              		.loc 2 38 24
  45 001c 08201BE5 		ldr	r2, [fp, #-8]
  46 0020 B420D2E1 		ldrh	r2, [r2, #4]
  47              		.loc 2 38 18
  48 0024 023003E0 		and	r3, r3, r2
  49              		.loc 2 38 40
  50 0028 08201BE5 		ldr	r2, [fp, #-8]
  51 002c B020D2E1 		ldrh	r2, [r2]
  52              		.loc 2 38 4
  53 0030 020053E1 		cmp	r3, r2
  54 0034 0100001A 		bne	.L2
  39:trace32/../lib/byte_fifo.h **** 		return -1;
  55              		.loc 2 39 10
  56 0038 0030E0E3 		mvn	r3, #0
  57 003c 000000EA 		b	.L3
  58              	.L2:
  40:trace32/../lib/byte_fifo.h **** 	
  41:trace32/../lib/byte_fifo.h **** 	return 0;
  59              		.loc 2 41 9
  60 0040 0030A0E3 		mov	r3, #0
  61              	.L3:
  42:trace32/../lib/byte_fifo.h **** }
  62              		.loc 2 42 1
  63 0044 0300A0E1 		mov	r0, r3
  64 0048 00D08BE2 		add	sp, fp, #0
  65              		.cfi_def_cfa_register 13
  66              		@ sp needed
  67 004c 04B09DE4 		ldr	fp, [sp], #4
  68              		.cfi_restore 11
  69              		.cfi_def_cfa_offset 0
  70 0050 1EFF2FE1 		bx	lr
  71              		.cfi_endproc
  72              	.LFE5:
  74              		.section	.text.byte_fifo_remain,"ax",%progbits
  75              		.align	2
  76              		.syntax unified
  77              		.arm
  79              	byte_fifo_remain:
  80              	.LFB6:
  43:trace32/../lib/byte_fifo.h **** 
  44:trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_remain(byte_fifo_t *fifo)
  45:trace32/../lib/byte_fifo.h **** {
  81              		.loc 2 45 1
  82              		.cfi_startproc
  83              		@ Function supports interworking.
  84              		@ args = 0, pretend = 0, frame = 8
  85              		@ frame_needed = 1, uses_anonymous_args = 0
  86              		@ link register save eliminated.
  87 0000 04B02DE5 		str	fp, [sp, #-4]!
  88              		.cfi_def_cfa_offset 4
  89              		.cfi_offset 11, -4
  90 0004 00B08DE2 		add	fp, sp, #0
  91              		.cfi_def_cfa_register 11
  92 0008 0CD04DE2 		sub	sp, sp, #12
  93 000c 08000BE5 		str	r0, [fp, #-8]
  46:trace32/../lib/byte_fifo.h **** 	return fifo->mask - ((fifo->wr-fifo->rd)&fifo->mask);
  94              		.loc 2 46 37
  95 0010 08301BE5 		ldr	r3, [fp, #-8]
  96 0014 B020D3E1 		ldrh	r2, [r3]
  97              		.loc 2 46 28
  98 0018 08301BE5 		ldr	r3, [fp, #-8]
  99 001c B230D3E1 		ldrh	r3, [r3, #2]
 100              		.loc 2 46 20
 101 0020 033042E0 		sub	r3, r2, r3
 102 0024 0338A0E1 		lsl	r3, r3, #16
 103 0028 2338A0E1 		lsr	r3, r3, #16
 104 002c 013043E2 		sub	r3, r3, #1
 105 0030 0338A0E1 		lsl	r3, r3, #16
 106 0034 2338A0E1 		lsr	r3, r3, #16
 107 0038 0338A0E1 		lsl	r3, r3, #16
 108 003c 4328A0E1 		asr	r2, r3, #16
 109              		.loc 2 46 47
 110 0040 08301BE5 		ldr	r3, [fp, #-8]
 111 0044 B430D3E1 		ldrh	r3, [r3, #4]
 112 0048 0338A0E1 		lsl	r3, r3, #16
 113 004c 4338A0E1 		asr	r3, r3, #16
 114              		.loc 2 46 20
 115 0050 023003E0 		and	r3, r3, r2
 116 0054 0338A0E1 		lsl	r3, r3, #16
 117 0058 4338A0E1 		asr	r3, r3, #16
 118 005c 0338A0E1 		lsl	r3, r3, #16
 119 0060 2338A0E1 		lsr	r3, r3, #16
  47:trace32/../lib/byte_fifo.h **** }
 120              		.loc 2 47 1
 121 0064 0300A0E1 		mov	r0, r3
 122 0068 00D08BE2 		add	sp, fp, #0
 123              		.cfi_def_cfa_register 13
 124              		@ sp needed
 125 006c 04B09DE4 		ldr	fp, [sp], #4
 126              		.cfi_restore 11
 127              		.cfi_def_cfa_offset 0
 128 0070 1EFF2FE1 		bx	lr
 129              		.cfi_endproc
 130              	.LFE6:
 132              		.section	.text.byte_fifo_used,"ax",%progbits
 133              		.align	2
 134              		.syntax unified
 135              		.arm
 137              	byte_fifo_used:
 138              	.LFB7:
  48:trace32/../lib/byte_fifo.h **** 	
  49:trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_used(byte_fifo_t *fifo)
  50:trace32/../lib/byte_fifo.h **** {
 139              		.loc 2 50 1
 140              		.cfi_startproc
 141              		@ Function supports interworking.
 142              		@ args = 0, pretend = 0, frame = 8
 143              		@ frame_needed = 1, uses_anonymous_args = 0
 144              		@ link register save eliminated.
 145 0000 04B02DE5 		str	fp, [sp, #-4]!
 146              		.cfi_def_cfa_offset 4
 147              		.cfi_offset 11, -4
 148 0004 00B08DE2 		add	fp, sp, #0
 149              		.cfi_def_cfa_register 11
 150 0008 0CD04DE2 		sub	sp, sp, #12
 151 000c 08000BE5 		str	r0, [fp, #-8]
  51:trace32/../lib/byte_fifo.h **** 	return (fifo->wr-fifo->rd)&fifo->mask;
 152              		.loc 2 51 14
 153 0010 08301BE5 		ldr	r3, [fp, #-8]
 154 0014 B220D3E1 		ldrh	r2, [r3, #2]
 155              		.loc 2 51 23
 156 0018 08301BE5 		ldr	r3, [fp, #-8]
 157 001c B030D3E1 		ldrh	r3, [r3]
 158              		.loc 2 51 18
 159 0020 033042E0 		sub	r3, r2, r3
 160 0024 0338A0E1 		lsl	r3, r3, #16
 161 0028 2338A0E1 		lsr	r3, r3, #16
 162 002c 0338A0E1 		lsl	r3, r3, #16
 163 0030 4328A0E1 		asr	r2, r3, #16
 164              		.loc 2 51 33
 165 0034 08301BE5 		ldr	r3, [fp, #-8]
 166 0038 B430D3E1 		ldrh	r3, [r3, #4]
 167 003c 0338A0E1 		lsl	r3, r3, #16
 168 0040 4338A0E1 		asr	r3, r3, #16
 169              		.loc 2 51 28
 170 0044 023003E0 		and	r3, r3, r2
 171 0048 0338A0E1 		lsl	r3, r3, #16
 172 004c 4338A0E1 		asr	r3, r3, #16
 173 0050 0338A0E1 		lsl	r3, r3, #16
 174 0054 2338A0E1 		lsr	r3, r3, #16
  52:trace32/../lib/byte_fifo.h **** }
 175              		.loc 2 52 1
 176 0058 0300A0E1 		mov	r0, r3
 177 005c 00D08BE2 		add	sp, fp, #0
 178              		.cfi_def_cfa_register 13
 179              		@ sp needed
 180 0060 04B09DE4 		ldr	fp, [sp], #4
 181              		.cfi_restore 11
 182              		.cfi_def_cfa_offset 0
 183 0064 1EFF2FE1 		bx	lr
 184              		.cfi_endproc
 185              	.LFE7:
 187              		.section	.text.byte_fifo_put,"ax",%progbits
 188              		.align	2
 189              		.syntax unified
 190              		.arm
 192              	byte_fifo_put:
 193              	.LFB8:
  53:trace32/../lib/byte_fifo.h **** 	
  54:trace32/../lib/byte_fifo.h **** static int byte_fifo_put(byte_fifo_t *fifo,unsigned char val)
  55:trace32/../lib/byte_fifo.h **** {
 194              		.loc 2 55 1
 195              		.cfi_startproc
 196              		@ Function supports interworking.
 197              		@ args = 0, pretend = 0, frame = 8
 198              		@ frame_needed = 1, uses_anonymous_args = 0
 199              		@ link register save eliminated.
 200 0000 04B02DE5 		str	fp, [sp, #-4]!
 201              		.cfi_def_cfa_offset 4
 202              		.cfi_offset 11, -4
 203 0004 00B08DE2 		add	fp, sp, #0
 204              		.cfi_def_cfa_register 11
 205 0008 0CD04DE2 		sub	sp, sp, #12
 206 000c 08000BE5 		str	r0, [fp, #-8]
 207 0010 0130A0E1 		mov	r3, r1
 208 0014 09304BE5 		strb	r3, [fp, #-9]
  56:trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
 209              		.loc 2 56 11
 210 0018 08301BE5 		ldr	r3, [fp, #-8]
 211 001c B230D3E1 		ldrh	r3, [r3, #2]
 212              		.loc 2 56 15
 213 0020 013083E2 		add	r3, r3, #1
 214              		.loc 2 56 24
 215 0024 08201BE5 		ldr	r2, [fp, #-8]
 216 0028 B420D2E1 		ldrh	r2, [r2, #4]
 217              		.loc 2 56 18
 218 002c 023003E0 		and	r3, r3, r2
 219              		.loc 2 56 40
 220 0030 08201BE5 		ldr	r2, [fp, #-8]
 221 0034 B020D2E1 		ldrh	r2, [r2]
 222              		.loc 2 56 4
 223 0038 020053E1 		cmp	r3, r2
 224 003c 0100001A 		bne	.L9
  57:trace32/../lib/byte_fifo.h **** 		return -1;
 225              		.loc 2 57 10
 226 0040 0030E0E3 		mvn	r3, #0
 227 0044 190000EA 		b	.L10
 228              	.L9:
  58:trace32/../lib/byte_fifo.h **** 	
  59:trace32/../lib/byte_fifo.h **** 	fifo->buf[fifo->wr]=val;
 229              		.loc 2 59 16
 230 0048 08301BE5 		ldr	r3, [fp, #-8]
 231 004c B230D3E1 		ldrh	r3, [r3, #2]
 232 0050 0320A0E1 		mov	r2, r3
 233              		.loc 2 59 21
 234 0054 08301BE5 		ldr	r3, [fp, #-8]
 235 0058 023083E0 		add	r3, r3, r2
 236 005c 09205BE5 		ldrb	r2, [fp, #-9]
 237 0060 0620C3E5 		strb	r2, [r3, #6]
  60:trace32/../lib/byte_fifo.h **** 	fifo->wr=(fifo->wr+1)&(fifo->mask);
 238              		.loc 2 60 16
 239 0064 08301BE5 		ldr	r3, [fp, #-8]
 240 0068 B230D3E1 		ldrh	r3, [r3, #2]
 241              		.loc 2 60 20
 242 006c 013083E2 		add	r3, r3, #1
 243 0070 0338A0E1 		lsl	r3, r3, #16
 244 0074 2338A0E1 		lsr	r3, r3, #16
 245 0078 0338A0E1 		lsl	r3, r3, #16
 246 007c 4328A0E1 		asr	r2, r3, #16
 247              		.loc 2 60 29
 248 0080 08301BE5 		ldr	r3, [fp, #-8]
 249 0084 B430D3E1 		ldrh	r3, [r3, #4]
 250 0088 0338A0E1 		lsl	r3, r3, #16
 251 008c 4338A0E1 		asr	r3, r3, #16
 252              		.loc 2 60 23
 253 0090 023003E0 		and	r3, r3, r2
 254 0094 0338A0E1 		lsl	r3, r3, #16
 255 0098 4338A0E1 		asr	r3, r3, #16
 256 009c 0338A0E1 		lsl	r3, r3, #16
 257 00a0 2328A0E1 		lsr	r2, r3, #16
 258              		.loc 2 60 10
 259 00a4 08301BE5 		ldr	r3, [fp, #-8]
 260 00a8 B220C3E1 		strh	r2, [r3, #2]	@ movhi
  61:trace32/../lib/byte_fifo.h **** 	return 0;
 261              		.loc 2 61 9
 262 00ac 0030A0E3 		mov	r3, #0
 263              	.L10:
  62:trace32/../lib/byte_fifo.h **** }
 264              		.loc 2 62 1
 265 00b0 0300A0E1 		mov	r0, r3
 266 00b4 00D08BE2 		add	sp, fp, #0
 267              		.cfi_def_cfa_register 13
 268              		@ sp needed
 269 00b8 04B09DE4 		ldr	fp, [sp], #4
 270              		.cfi_restore 11
 271              		.cfi_def_cfa_offset 0
 272 00bc 1EFF2FE1 		bx	lr
 273              		.cfi_endproc
 274              	.LFE8:
 276              		.section	.text.byte_fifo_get_possible,"ax",%progbits
 277              		.align	2
 278              		.syntax unified
 279              		.arm
 281              	byte_fifo_get_possible:
 282              	.LFB9:
  63:trace32/../lib/byte_fifo.h **** 
  64:trace32/../lib/byte_fifo.h **** static int byte_fifo_get_possible(byte_fifo_t *fifo)
  65:trace32/../lib/byte_fifo.h **** {
 283              		.loc 2 65 1
 284              		.cfi_startproc
 285              		@ Function supports interworking.
 286              		@ args = 0, pretend = 0, frame = 8
 287              		@ frame_needed = 1, uses_anonymous_args = 0
 288              		@ link register save eliminated.
 289 0000 04B02DE5 		str	fp, [sp, #-4]!
 290              		.cfi_def_cfa_offset 4
 291              		.cfi_offset 11, -4
 292 0004 00B08DE2 		add	fp, sp, #0
 293              		.cfi_def_cfa_register 11
 294 0008 0CD04DE2 		sub	sp, sp, #12
 295 000c 08000BE5 		str	r0, [fp, #-8]
  66:trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 296              		.loc 2 66 9
 297 0010 08301BE5 		ldr	r3, [fp, #-8]
 298 0014 B020D3E1 		ldrh	r2, [r3]
 299              		.loc 2 66 21
 300 0018 08301BE5 		ldr	r3, [fp, #-8]
 301 001c B230D3E1 		ldrh	r3, [r3, #2]
 302              		.loc 2 66 4
 303 0020 030052E1 		cmp	r2, r3
 304 0024 0100001A 		bne	.L12
  67:trace32/../lib/byte_fifo.h **** 		return -1;
 305              		.loc 2 67 10
 306 0028 0030E0E3 		mvn	r3, #0
 307 002c 000000EA 		b	.L13
 308              	.L12:
  68:trace32/../lib/byte_fifo.h **** 		
  69:trace32/../lib/byte_fifo.h **** 	return 0;
 309              		.loc 2 69 9
 310 0030 0030A0E3 		mov	r3, #0
 311              	.L13:
  70:trace32/../lib/byte_fifo.h **** }
 312              		.loc 2 70 1
 313 0034 0300A0E1 		mov	r0, r3
 314 0038 00D08BE2 		add	sp, fp, #0
 315              		.cfi_def_cfa_register 13
 316              		@ sp needed
 317 003c 04B09DE4 		ldr	fp, [sp], #4
 318              		.cfi_restore 11
 319              		.cfi_def_cfa_offset 0
 320 0040 1EFF2FE1 		bx	lr
 321              		.cfi_endproc
 322              	.LFE9:
 324              		.section	.text.byte_fifo_get,"ax",%progbits
 325              		.align	2
 326              		.syntax unified
 327              		.arm
 329              	byte_fifo_get:
 330              	.LFB10:
  71:trace32/../lib/byte_fifo.h **** 
  72:trace32/../lib/byte_fifo.h **** static int byte_fifo_get(byte_fifo_t *fifo,unsigned char *val)
  73:trace32/../lib/byte_fifo.h **** {
 331              		.loc 2 73 1
 332              		.cfi_startproc
 333              		@ Function supports interworking.
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 1, uses_anonymous_args = 0
 336              		@ link register save eliminated.
 337 0000 04B02DE5 		str	fp, [sp, #-4]!
 338              		.cfi_def_cfa_offset 4
 339              		.cfi_offset 11, -4
 340 0004 00B08DE2 		add	fp, sp, #0
 341              		.cfi_def_cfa_register 11
 342 0008 0CD04DE2 		sub	sp, sp, #12
 343 000c 08000BE5 		str	r0, [fp, #-8]
 344 0010 0C100BE5 		str	r1, [fp, #-12]
  74:trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 345              		.loc 2 74 9
 346 0014 08301BE5 		ldr	r3, [fp, #-8]
 347 0018 B020D3E1 		ldrh	r2, [r3]
 348              		.loc 2 74 21
 349 001c 08301BE5 		ldr	r3, [fp, #-8]
 350 0020 B230D3E1 		ldrh	r3, [r3, #2]
 351              		.loc 2 74 4
 352 0024 030052E1 		cmp	r2, r3
 353 0028 0100001A 		bne	.L15
  75:trace32/../lib/byte_fifo.h **** 		return -1;
 354              		.loc 2 75 10
 355 002c 0030E0E3 		mvn	r3, #0
 356 0030 1A0000EA 		b	.L16
 357              	.L15:
  76:trace32/../lib/byte_fifo.h **** 		
  77:trace32/../lib/byte_fifo.h **** 	*val=fifo->buf[fifo->rd];
 358              		.loc 2 77 21
 359 0034 08301BE5 		ldr	r3, [fp, #-8]
 360 0038 B030D3E1 		ldrh	r3, [r3]
 361 003c 0320A0E1 		mov	r2, r3
 362              		.loc 2 77 16
 363 0040 08301BE5 		ldr	r3, [fp, #-8]
 364 0044 023083E0 		add	r3, r3, r2
 365 0048 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 366              		.loc 2 77 6
 367 004c 0C301BE5 		ldr	r3, [fp, #-12]
 368 0050 0020C3E5 		strb	r2, [r3]
  78:trace32/../lib/byte_fifo.h **** 	fifo->rd=(fifo->rd+1)&(fifo->mask);
 369              		.loc 2 78 16
 370 0054 08301BE5 		ldr	r3, [fp, #-8]
 371 0058 B030D3E1 		ldrh	r3, [r3]
 372              		.loc 2 78 20
 373 005c 013083E2 		add	r3, r3, #1
 374 0060 0338A0E1 		lsl	r3, r3, #16
 375 0064 2338A0E1 		lsr	r3, r3, #16
 376 0068 0338A0E1 		lsl	r3, r3, #16
 377 006c 4328A0E1 		asr	r2, r3, #16
 378              		.loc 2 78 29
 379 0070 08301BE5 		ldr	r3, [fp, #-8]
 380 0074 B430D3E1 		ldrh	r3, [r3, #4]
 381 0078 0338A0E1 		lsl	r3, r3, #16
 382 007c 4338A0E1 		asr	r3, r3, #16
 383              		.loc 2 78 23
 384 0080 023003E0 		and	r3, r3, r2
 385 0084 0338A0E1 		lsl	r3, r3, #16
 386 0088 4338A0E1 		asr	r3, r3, #16
 387 008c 0338A0E1 		lsl	r3, r3, #16
 388 0090 2328A0E1 		lsr	r2, r3, #16
 389              		.loc 2 78 10
 390 0094 08301BE5 		ldr	r3, [fp, #-8]
 391 0098 B020C3E1 		strh	r2, [r3]	@ movhi
  79:trace32/../lib/byte_fifo.h **** 	return 0;
 392              		.loc 2 79 9
 393 009c 0030A0E3 		mov	r3, #0
 394              	.L16:
  80:trace32/../lib/byte_fifo.h **** }
 395              		.loc 2 80 1
 396 00a0 0300A0E1 		mov	r0, r3
 397 00a4 00D08BE2 		add	sp, fp, #0
 398              		.cfi_def_cfa_register 13
 399              		@ sp needed
 400 00a8 04B09DE4 		ldr	fp, [sp], #4
 401              		.cfi_restore 11
 402              		.cfi_def_cfa_offset 0
 403 00ac 1EFF2FE1 		bx	lr
 404              		.cfi_endproc
 405              	.LFE10:
 407              		.section	.text.byte_fifo_cb_put_possible,"ax",%progbits
 408              		.align	2
 409              		.syntax unified
 410              		.arm
 412              	byte_fifo_cb_put_possible:
 413              	.LFB11:
 414              		.file 3 "trace32/../lib/byte_fifo_cb.h"
   1:trace32/../lib/byte_fifo_cb.h **** /* Byte FIFO with CallBack
   2:trace32/../lib/byte_fifo_cb.h ****  *
   3:trace32/../lib/byte_fifo_cb.h ****  * Appends the Byte_Fifo with a callback function, which is called
   4:trace32/../lib/byte_fifo_cb.h ****  * when putting some stuff into the fifo (e.g. Enable transmitting interrupt)
   5:trace32/../lib/byte_fifo_cb.h ****  */
   6:trace32/../lib/byte_fifo_cb.h **** 
   7:trace32/../lib/byte_fifo_cb.h **** #ifndef __BYTE_FIFO_CB_H__
   8:trace32/../lib/byte_fifo_cb.h **** #define __BYTE_FIFO_CB_H__
   9:trace32/../lib/byte_fifo_cb.h **** 
  10:trace32/../lib/byte_fifo_cb.h **** #include "byte_fifo.h"
  11:trace32/../lib/byte_fifo_cb.h **** 
  12:trace32/../lib/byte_fifo_cb.h **** typedef void (*byte_fifo_cb)(void);
  13:trace32/../lib/byte_fifo_cb.h **** 
  14:trace32/../lib/byte_fifo_cb.h **** typedef struct {
  15:trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_cb cb;
  16:trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_t  byte_fifo; //Aufgrund des Flexible Array Member hier hinter keine weiteren Strukturel
  17:trace32/../lib/byte_fifo_cb.h **** } byte_fifo_cb_t;
  18:trace32/../lib/byte_fifo_cb.h **** 
  19:trace32/../lib/byte_fifo_cb.h **** #define BYTE_FIFO_CB_INIT(size,func)  (byte_fifo_cb_t) {.cb=func, \
  20:trace32/../lib/byte_fifo_cb.h ****                                                         .byte_fifo=BYTE_FIFO_INIT(size) \
  21:trace32/../lib/byte_fifo_cb.h **** 									    			   }
  22:trace32/../lib/byte_fifo_cb.h **** 
  23:trace32/../lib/byte_fifo_cb.h **** size_t byte_fifo_cb_putsize(byte_fifo_cb_t *fifo,const unsigned char *start,size_t len);
  24:trace32/../lib/byte_fifo_cb.h **** 
  25:trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic push
  26:trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  27:trace32/../lib/byte_fifo_cb.h **** 
  28:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put_possible(byte_fifo_cb_t *fifo)
  29:trace32/../lib/byte_fifo_cb.h **** {
 415              		.loc 3 29 1
 416              		.cfi_startproc
 417              		@ Function supports interworking.
 418              		@ args = 0, pretend = 0, frame = 8
 419              		@ frame_needed = 1, uses_anonymous_args = 0
 420 0000 00482DE9 		push	{fp, lr}
 421              		.cfi_def_cfa_offset 8
 422              		.cfi_offset 11, -8
 423              		.cfi_offset 14, -4
 424 0004 04B08DE2 		add	fp, sp, #4
 425              		.cfi_def_cfa 11, 4
 426 0008 08D04DE2 		sub	sp, sp, #8
 427 000c 08000BE5 		str	r0, [fp, #-8]
  30:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_put_possible(&fifo->byte_fifo);
 428              		.loc 3 30 9
 429 0010 08301BE5 		ldr	r3, [fp, #-8]
 430 0014 043083E2 		add	r3, r3, #4
 431 0018 0300A0E1 		mov	r0, r3
 432 001c 18309FE5 		ldr	r3, .L19
 433 0020 0FE0A0E1 		mov	lr, pc
 434 0024 13FF2FE1 		bx	r3
 435              	.LVL0:
 436 0028 0030A0E1 		mov	r3, r0
  31:trace32/../lib/byte_fifo_cb.h **** }
 437              		.loc 3 31 1
 438 002c 0300A0E1 		mov	r0, r3
 439 0030 04D04BE2 		sub	sp, fp, #4
 440              		.cfi_def_cfa 13, 8
 441              		@ sp needed
 442 0034 0048BDE8 		pop	{fp, lr}
 443              		.cfi_restore 14
 444              		.cfi_restore 11
 445              		.cfi_def_cfa_offset 0
 446 0038 1EFF2FE1 		bx	lr
 447              	.L20:
 448              		.align	2
 449              	.L19:
 450 003c 00000000 		.word	byte_fifo_put_possible
 451              		.cfi_endproc
 452              	.LFE11:
 454              		.section	.text.byte_fifo_cb_put,"ax",%progbits
 455              		.align	2
 456              		.syntax unified
 457              		.arm
 459              	byte_fifo_cb_put:
 460              	.LFB12:
  32:trace32/../lib/byte_fifo_cb.h **** 	
  33:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put(byte_fifo_cb_t *fifo,unsigned char val)
  34:trace32/../lib/byte_fifo_cb.h **** {
 461              		.loc 3 34 1
 462              		.cfi_startproc
 463              		@ Function supports interworking.
 464              		@ args = 0, pretend = 0, frame = 16
 465              		@ frame_needed = 1, uses_anonymous_args = 0
 466 0000 00482DE9 		push	{fp, lr}
 467              		.cfi_def_cfa_offset 8
 468              		.cfi_offset 11, -8
 469              		.cfi_offset 14, -4
 470 0004 04B08DE2 		add	fp, sp, #4
 471              		.cfi_def_cfa 11, 4
 472 0008 10D04DE2 		sub	sp, sp, #16
 473 000c 10000BE5 		str	r0, [fp, #-16]
 474 0010 0130A0E1 		mov	r3, r1
 475 0014 11304BE5 		strb	r3, [fp, #-17]
  35:trace32/../lib/byte_fifo_cb.h **** 	int ret=byte_fifo_put(&fifo->byte_fifo,val);
 476              		.loc 3 35 10
 477 0018 10301BE5 		ldr	r3, [fp, #-16]
 478 001c 043083E2 		add	r3, r3, #4
 479 0020 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 480 0024 0210A0E1 		mov	r1, r2
 481 0028 0300A0E1 		mov	r0, r3
 482 002c 48309FE5 		ldr	r3, .L24
 483 0030 0FE0A0E1 		mov	lr, pc
 484 0034 13FF2FE1 		bx	r3
 485              	.LVL1:
 486 0038 08000BE5 		str	r0, [fp, #-8]
  36:trace32/../lib/byte_fifo_cb.h **** 	if( !ret && fifo->cb)
 487              		.loc 3 36 4
 488 003c 08301BE5 		ldr	r3, [fp, #-8]
 489 0040 000053E3 		cmp	r3, #0
 490 0044 0700001A 		bne	.L22
 491              		.loc 3 36 18 discriminator 1
 492 0048 10301BE5 		ldr	r3, [fp, #-16]
 493 004c 003093E5 		ldr	r3, [r3]
 494              		.loc 3 36 11 discriminator 1
 495 0050 000053E3 		cmp	r3, #0
 496 0054 0300000A 		beq	.L22
  37:trace32/../lib/byte_fifo_cb.h **** 		fifo->cb();
 497              		.loc 3 37 7
 498 0058 10301BE5 		ldr	r3, [fp, #-16]
 499 005c 003093E5 		ldr	r3, [r3]
 500              		.loc 3 37 3
 501 0060 0FE0A0E1 		mov	lr, pc
 502 0064 13FF2FE1 		bx	r3
 503              	.LVL2:
 504              	.L22:
  38:trace32/../lib/byte_fifo_cb.h **** 	return ret;
 505              		.loc 3 38 9
 506 0068 08301BE5 		ldr	r3, [fp, #-8]
  39:trace32/../lib/byte_fifo_cb.h **** }
 507              		.loc 3 39 1
 508 006c 0300A0E1 		mov	r0, r3
 509 0070 04D04BE2 		sub	sp, fp, #4
 510              		.cfi_def_cfa 13, 8
 511              		@ sp needed
 512 0074 0048BDE8 		pop	{fp, lr}
 513              		.cfi_restore 14
 514              		.cfi_restore 11
 515              		.cfi_def_cfa_offset 0
 516 0078 1EFF2FE1 		bx	lr
 517              	.L25:
 518              		.align	2
 519              	.L24:
 520 007c 00000000 		.word	byte_fifo_put
 521              		.cfi_endproc
 522              	.LFE12:
 524              		.section	.text.byte_fifo_cb_get_possible,"ax",%progbits
 525              		.align	2
 526              		.syntax unified
 527              		.arm
 529              	byte_fifo_cb_get_possible:
 530              	.LFB13:
  40:trace32/../lib/byte_fifo_cb.h **** 
  41:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get_possible(byte_fifo_cb_t *fifo)
  42:trace32/../lib/byte_fifo_cb.h **** {
 531              		.loc 3 42 1
 532              		.cfi_startproc
 533              		@ Function supports interworking.
 534              		@ args = 0, pretend = 0, frame = 8
 535              		@ frame_needed = 1, uses_anonymous_args = 0
 536 0000 00482DE9 		push	{fp, lr}
 537              		.cfi_def_cfa_offset 8
 538              		.cfi_offset 11, -8
 539              		.cfi_offset 14, -4
 540 0004 04B08DE2 		add	fp, sp, #4
 541              		.cfi_def_cfa 11, 4
 542 0008 08D04DE2 		sub	sp, sp, #8
 543 000c 08000BE5 		str	r0, [fp, #-8]
  43:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get_possible(&fifo->byte_fifo);
 544              		.loc 3 43 9
 545 0010 08301BE5 		ldr	r3, [fp, #-8]
 546 0014 043083E2 		add	r3, r3, #4
 547 0018 0300A0E1 		mov	r0, r3
 548 001c 18309FE5 		ldr	r3, .L28
 549 0020 0FE0A0E1 		mov	lr, pc
 550 0024 13FF2FE1 		bx	r3
 551              	.LVL3:
 552 0028 0030A0E1 		mov	r3, r0
  44:trace32/../lib/byte_fifo_cb.h **** }
 553              		.loc 3 44 1
 554 002c 0300A0E1 		mov	r0, r3
 555 0030 04D04BE2 		sub	sp, fp, #4
 556              		.cfi_def_cfa 13, 8
 557              		@ sp needed
 558 0034 0048BDE8 		pop	{fp, lr}
 559              		.cfi_restore 14
 560              		.cfi_restore 11
 561              		.cfi_def_cfa_offset 0
 562 0038 1EFF2FE1 		bx	lr
 563              	.L29:
 564              		.align	2
 565              	.L28:
 566 003c 00000000 		.word	byte_fifo_get_possible
 567              		.cfi_endproc
 568              	.LFE13:
 570              		.section	.text.byte_fifo_cb_get,"ax",%progbits
 571              		.align	2
 572              		.syntax unified
 573              		.arm
 575              	byte_fifo_cb_get:
 576              	.LFB14:
  45:trace32/../lib/byte_fifo_cb.h **** 
  46:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get(byte_fifo_cb_t *fifo,unsigned char *val)
  47:trace32/../lib/byte_fifo_cb.h **** {
 577              		.loc 3 47 1
 578              		.cfi_startproc
 579              		@ Function supports interworking.
 580              		@ args = 0, pretend = 0, frame = 8
 581              		@ frame_needed = 1, uses_anonymous_args = 0
 582 0000 00482DE9 		push	{fp, lr}
 583              		.cfi_def_cfa_offset 8
 584              		.cfi_offset 11, -8
 585              		.cfi_offset 14, -4
 586 0004 04B08DE2 		add	fp, sp, #4
 587              		.cfi_def_cfa 11, 4
 588 0008 08D04DE2 		sub	sp, sp, #8
 589 000c 08000BE5 		str	r0, [fp, #-8]
 590 0010 0C100BE5 		str	r1, [fp, #-12]
  48:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get(&fifo->byte_fifo,val);
 591              		.loc 3 48 9
 592 0014 08301BE5 		ldr	r3, [fp, #-8]
 593 0018 043083E2 		add	r3, r3, #4
 594 001c 0C101BE5 		ldr	r1, [fp, #-12]
 595 0020 0300A0E1 		mov	r0, r3
 596 0024 18309FE5 		ldr	r3, .L32
 597 0028 0FE0A0E1 		mov	lr, pc
 598 002c 13FF2FE1 		bx	r3
 599              	.LVL4:
 600 0030 0030A0E1 		mov	r3, r0
  49:trace32/../lib/byte_fifo_cb.h **** }
 601              		.loc 3 49 1
 602 0034 0300A0E1 		mov	r0, r3
 603 0038 04D04BE2 		sub	sp, fp, #4
 604              		.cfi_def_cfa 13, 8
 605              		@ sp needed
 606 003c 0048BDE8 		pop	{fp, lr}
 607              		.cfi_restore 14
 608              		.cfi_restore 11
 609              		.cfi_def_cfa_offset 0
 610 0040 1EFF2FE1 		bx	lr
 611              	.L33:
 612              		.align	2
 613              	.L32:
 614 0044 00000000 		.word	byte_fifo_get
 615              		.cfi_endproc
 616              	.LFE14:
 618              		.global	main_data
 619              		.bss
 620              		.align	2
 623              	main_data:
 624 0000 000000   		.space	3
 625              		.section	.text._exit,"ax",%progbits
 626              		.align	2
 627              		.global	_exit
 628              		.syntax unified
 629              		.arm
 631              	_exit:
 632              	.LFB15:
   1:main.c        **** #include <math.h>
   2:main.c        **** #include <stdint.h>
   3:main.c        **** #include <stdio.h>
   4:main.c        **** #include <string.h>
   5:main.c        **** #include <unistd.h> //fuer _exit()
   6:main.c        **** 
   7:main.c        **** #include "AT91SAM7S64.h"
   8:main.c        **** #include "lib/aic.h"
   9:main.c        **** #include "lib/display.h"
  10:main.c        **** #include "lib/nxt_avr.h"
  11:main.c        **** #include "lib/systick.h"
  12:main.c        **** #include "lib/term.h"
  13:main.c        **** #include "main.h"
  14:main.c        **** // #include "lib/adc.h"
  15:main.c        **** #if defined(MODE_RAM) || defined(MODE_SIM)
  16:main.c        **** #include "trace32/udmon3.h"
  17:main.c        **** #endif
  18:main.c        **** 
  19:main.c        **** #define ZYKLUS_MS 2
  20:main.c        **** #define IDLE_MS 1
  21:main.c        **** 
  22:main.c        **** #if IDLE_MS >= ZYKLUS_MS
  23:main.c        **** #error "Idle_ms muss kleiner als zyklus_ms sein"
  24:main.c        **** #endif
  25:main.c        **** 
  26:main.c        **** /*****************************************************************************/
  27:main.c        **** /*   Globale Variablen                                                       */
  28:main.c        **** /*****************************************************************************/
  29:main.c        **** struct {
  30:main.c        ****   signed char term_status; // 0->false->Alles Bestens   -1->true->Overflow
  31:main.c        ****   unsigned char term_cnt;
  32:main.c        ****   unsigned char lowbat_cnt;
  33:main.c        **** } main_data = {
  34:main.c        ****     .term_status = 0,
  35:main.c        ****     .term_cnt = 0,
  36:main.c        ****     .lowbat_cnt = 0,
  37:main.c        **** };
  38:main.c        **** 
  39:main.c        **** /*****************************************************************************/
  40:main.c        **** /*   Hilfsroutinen                                                           */
  41:main.c        **** /*   Standard-C-Library (weitere befinden sich in newlib_syscalls.c)         */
  42:main.c        **** /*****************************************************************************/
  43:main.c        **** // Routine wird von C-Lib aufgerufen (bspw. printf() abort())
  44:main.c        **** void _exit(int status) {
 633              		.loc 1 44 24
 634              		.cfi_startproc
 635              		@ Function supports interworking.
 636              		@ args = 0, pretend = 0, frame = 8
 637              		@ frame_needed = 1, uses_anonymous_args = 0
 638              		@ link register save eliminated.
 639 0000 04B02DE5 		str	fp, [sp, #-4]!
 640              		.cfi_def_cfa_offset 4
 641              		.cfi_offset 11, -4
 642 0004 00B08DE2 		add	fp, sp, #0
 643              		.cfi_def_cfa_register 11
 644 0008 0CD04DE2 		sub	sp, sp, #12
 645 000c 08000BE5 		str	r0, [fp, #-8]
 646              	.L35:
  45:main.c        ****   (void)status;
  46:main.c        ****   // LED-Blinken lassen
  47:main.c        ****   // Breakpoint setzen
  48:main.c        ****   while (1)
 647              		.loc 1 48 9
 648 0010 0000A0E1 		nop
 649 0014 FDFFFFEA 		b	.L35
 650              		.cfi_endproc
 651              	.LFE15:
 653              		.global	trace_buf0
 654              		.bss
 655 0003 00       		.align	2
 658              	trace_buf0:
 659 0004 00000000 		.space	400
 659      00000000 
 659      00000000 
 659      00000000 
 659      00000000 
 660              		.global	trace_buf1
 661              		.align	2
 664              	trace_buf1:
 665 0194 00000000 		.space	400
 665      00000000 
 665      00000000 
 665      00000000 
 665      00000000 
 666              		.section	.text.trace_scope,"ax",%progbits
 667              		.align	2
 668              		.global	trace_scope
 669              		.syntax unified
 670              		.arm
 672              	trace_scope:
 673              	.LFB16:
  49:main.c        ****     ;
  50:main.c        **** }
  51:main.c        **** 
  52:main.c        **** /************************************************************************/
  53:main.c        **** /*   Hilfsroutine zur Darstellung eines analogen Verlaufes entsprechend */
  54:main.c        **** /*   einem Oszillosop                                                   */
  55:main.c        **** /************************************************************************/
  56:main.c        **** #define TRACE_SIZE 200
  57:main.c        **** int16_t trace_buf0[TRACE_SIZE];
  58:main.c        **** int16_t trace_buf1[TRACE_SIZE];
  59:main.c        **** // Darstellung des Puffers über 'v.draw %e trace_buf0 trace_buf1'
  60:main.c        **** void trace_scope(int channel, int16_t value) {
 674              		.loc 1 60 46
 675              		.cfi_startproc
 676              		@ Function supports interworking.
 677              		@ args = 0, pretend = 0, frame = 8
 678              		@ frame_needed = 1, uses_anonymous_args = 0
 679              		@ link register save eliminated.
 680 0000 04B02DE5 		str	fp, [sp, #-4]!
 681              		.cfi_def_cfa_offset 4
 682              		.cfi_offset 11, -4
 683 0004 00B08DE2 		add	fp, sp, #0
 684              		.cfi_def_cfa_register 11
 685 0008 0CD04DE2 		sub	sp, sp, #12
 686 000c 08000BE5 		str	r0, [fp, #-8]
 687 0010 0130A0E1 		mov	r3, r1
 688 0014 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
  61:main.c        ****   // #define TRACE_ROLL
  62:main.c        **** #ifdef TRACE_ROLL
  63:main.c        ****   if (channel == 0) {
  64:main.c        ****     for (int lauf = 0; lauf < (TRACE_SIZE - 1); lauf++)
  65:main.c        ****       trace_buf0[lauf] = trace_buf0[lauf + 1];
  66:main.c        ****     trace_buf0[TRACE_SIZE - 1] = value;
  67:main.c        ****   } else {
  68:main.c        ****     for (int lauf = 0; lauf < (TRACE_SIZE - 1); lauf++)
  69:main.c        ****       trace_buf1[lauf] = trace_buf1[lauf + 1];
  70:main.c        ****     trace_buf1[TRACE_SIZE - 1] = value;
  71:main.c        ****   }
  72:main.c        **** #else
  73:main.c        ****   static int trace_index = 0;
  74:main.c        ****   if (trace_index < TRACE_SIZE) {
 689              		.loc 1 74 19
 690 0018 A8309FE5 		ldr	r3, .L43
 691 001c 003093E5 		ldr	r3, [r3]
 692              		.loc 1 74 6
 693 0020 C70053E3 		cmp	r3, #199
 694 0024 110000CA 		bgt	.L37
  75:main.c        ****     if (channel == 0)
 695              		.loc 1 75 8
 696 0028 08301BE5 		ldr	r3, [fp, #-8]
 697 002c 000053E3 		cmp	r3, #0
 698 0030 0700001A 		bne	.L38
  76:main.c        ****       trace_buf0[trace_index] = value;
 699              		.loc 1 76 17
 700 0034 8C309FE5 		ldr	r3, .L43
 701 0038 003093E5 		ldr	r3, [r3]
 702              		.loc 1 76 31
 703 003c 88209FE5 		ldr	r2, .L43+4
 704 0040 8330A0E1 		lsl	r3, r3, #1
 705 0044 033082E0 		add	r3, r2, r3
 706 0048 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 707 004c B020C3E1 		strh	r2, [r3]	@ movhi
 708 0050 060000EA 		b	.L37
 709              	.L38:
  77:main.c        ****     else
  78:main.c        ****       trace_buf1[trace_index] = value;
 710              		.loc 1 78 17
 711 0054 6C309FE5 		ldr	r3, .L43
 712 0058 003093E5 		ldr	r3, [r3]
 713              		.loc 1 78 31
 714 005c 6C209FE5 		ldr	r2, .L43+8
 715 0060 8330A0E1 		lsl	r3, r3, #1
 716 0064 033082E0 		add	r3, r2, r3
 717 0068 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 718 006c B020C3E1 		strh	r2, [r3]	@ movhi
 719              	.L37:
  79:main.c        ****   } else {
  80:main.c        ****     // Pause, damit der Debugger in 'Ruhe' den gesamten Speicher auslesen kann
  81:main.c        ****   }
  82:main.c        ****   if (channel == 1) {
 720              		.loc 1 82 6
 721 0070 08301BE5 		ldr	r3, [fp, #-8]
 722 0074 010053E3 		cmp	r3, #1
 723 0078 0E00001A 		bne	.L42
  83:main.c        ****     trace_index++;
 724              		.loc 1 83 16
 725 007c 44309FE5 		ldr	r3, .L43
 726 0080 003093E5 		ldr	r3, [r3]
 727 0084 013083E2 		add	r3, r3, #1
 728 0088 38209FE5 		ldr	r2, .L43
 729 008c 003082E5 		str	r3, [r2]
  84:main.c        ****     trace_index = trace_index >= (3 * TRACE_SIZE) ? 0 : trace_index;
 730              		.loc 1 84 31
 731 0090 30309FE5 		ldr	r3, .L43
 732 0094 003093E5 		ldr	r3, [r3]
 733              		.loc 1 84 55
 734 0098 960F53E3 		cmp	r3, #600
 735 009c 020000AA 		bge	.L40
 736              		.loc 1 84 55 is_stmt 0 discriminator 1
 737 00a0 20309FE5 		ldr	r3, .L43
 738 00a4 003093E5 		ldr	r3, [r3]
 739 00a8 000000EA 		b	.L41
 740              	.L40:
 741              		.loc 1 84 55 discriminator 2
 742 00ac 0030A0E3 		mov	r3, #0
 743              	.L41:
 744              		.loc 1 84 17 is_stmt 1 discriminator 4
 745 00b0 10209FE5 		ldr	r2, .L43
 746 00b4 003082E5 		str	r3, [r2]
 747              	.L42:
  85:main.c        ****   }
  86:main.c        **** #endif
  87:main.c        **** }
 748              		.loc 1 87 1
 749 00b8 0000A0E1 		nop
 750 00bc 00D08BE2 		add	sp, fp, #0
 751              		.cfi_def_cfa_register 13
 752              		@ sp needed
 753 00c0 04B09DE4 		ldr	fp, [sp], #4
 754              		.cfi_restore 11
 755              		.cfi_def_cfa_offset 0
 756 00c4 1EFF2FE1 		bx	lr
 757              	.L44:
 758              		.align	2
 759              	.L43:
 760 00c8 24030000 		.word	trace_index.3
 761 00cc 00000000 		.word	trace_buf0
 762 00d0 00000000 		.word	trace_buf1
 763              		.cfi_endproc
 764              	.LFE16:
 766              		.global	pio
 767              		.data
 768              		.align	2
 771              	pio:
 772 0000 00F4FFFF 		.word	-3072
 773              		.global	pmc
 774              		.align	2
 777              	pmc:
 778 0004 00FCFFFF 		.word	-1024
 779              		.global	pwm_ctl
 780              		.align	2
 783              	pwm_ctl:
 784 0008 00C0FCFF 		.word	-212992
 785              		.global	schritt_mode2str
 786              		.section	.rodata
 787              		.align	2
 788              	.LC0:
 789 0000 566F6C6C 		.ascii	"Vollschritt 1\000"
 789      73636872 
 789      69747420 
 789      3100
 790 000e 0000     		.align	2
 791              	.LC1:
 792 0010 566F6C6C 		.ascii	"Vollschritt 2\000"
 792      73636872 
 792      69747420 
 792      3200
 793 001e 0000     		.align	2
 794              	.LC2:
 795 0020 48616C62 		.ascii	"Halbschritt\000"
 795      73636872 
 795      69747400 
 796              		.align	2
 797              	.LC3:
 798 002c 53696E75 		.ascii	"SinusSchritt\000"
 798      73536368 
 798      72697474 
 798      00
 799              		.data
 800              		.align	2
 803              	schritt_mode2str:
 804 000c 00000000 		.word	.LC0
 805 0010 10000000 		.word	.LC1
 806 0014 20000000 		.word	.LC2
 807 0018 2C000000 		.word	.LC3
 808              		.global	schrittmotor_data
 809              		.align	2
 812              	schrittmotor_data:
 813 001c 00       		.space	1
 814 001d 00       		.byte	0
 815 001e 00       		.byte	0
 816 001f 00       		.byte	0
 817 0020 00       		.byte	0
 818 0021 000000   		.space	3
 819 0024 00000000 		.word	0
 820 0028 00       		.byte	0
 821 0029 00       		.space	1
 822 002a 0001     		.short	256
 823 002c 8000     		.short	128
 824 002e 4000     		.short	64
 825 0030 2000     		.short	32
 826 0032 0100     		.short	1
 827 0034 0000     		.short	0
 828 0036 0000     		.short	0
 829 0038 01000000 		.word	1
 830 003c 4A120000 		.word	4682
 831 0040 E0230000 		.word	9184
 832 0044 16340000 		.word	13334
 833 0048 4B420000 		.word	16971
 834 004c F34D0000 		.word	19955
 835 0050 9D560000 		.word	22173
 836 0054 F35B0000 		.word	23539
 837 0058 BF5D0000 		.word	23999
 838 005c F35B0000 		.word	23539
 839 0060 9D560000 		.word	22173
 840 0064 F34D0000 		.word	19955
 841 0068 4B420000 		.word	16971
 842 006c 16340000 		.word	13334
 843 0070 E0230000 		.word	9184
 844 0074 4A120000 		.word	4682
 845 0078 01000000 		.word	1
 846 007c B6EDFFFF 		.word	-4682
 847 0080 20DCFFFF 		.word	-9184
 848 0084 EACBFFFF 		.word	-13334
 849 0088 B5BDFFFF 		.word	-16971
 850 008c 0DB2FFFF 		.word	-19955
 851 0090 63A9FFFF 		.word	-22173
 852 0094 0DA4FFFF 		.word	-23539
 853 0098 41A2FFFF 		.word	-23999
 854 009c 0DA4FFFF 		.word	-23539
 855 00a0 63A9FFFF 		.word	-22173
 856 00a4 0DB2FFFF 		.word	-19955
 857 00a8 B5BDFFFF 		.word	-16971
 858 00ac EACBFFFF 		.word	-13334
 859 00b0 20DCFFFF 		.word	-9184
 860 00b4 B6EDFFFF 		.word	-4682
 861 00b8 01       		.byte	1
 862 00b9 000000   		.space	3
 863              		.section	.text.schrittmotor_init,"ax",%progbits
 864              		.align	2
 865              		.global	schrittmotor_init
 866              		.syntax unified
 867              		.arm
 869              	schrittmotor_init:
 870              	.LFB17:
  88:main.c        **** 
  89:main.c        **** /*****************************************************************************/
  90:main.c        **** /*   Ihr Programm                                                            */
  91:main.c        **** /*****************************************************************************/
  92:main.c        **** // AT91S_PIO, *AT91PS_PIO
  93:main.c        **** #define SPULE1_PWM (1 << 23)
  94:main.c        **** #define SPULE2_PWM (1 << 2)
  95:main.c        **** #define SPULE1_DIR (1 << 18)
  96:main.c        **** #define SPULE2_DIR (1 << 30)
  97:main.c        **** #define NXT_PORT4_ENABLE (1 << 7)
  98:main.c        **** #define ALL                                                                    \
  99:main.c        ****   (SPULE1_DIR | SPULE2_DIR | SPULE1_PWM | SPULE2_PWM | NXT_PORT4_ENABLE)
 100:main.c        **** #define SPULE1_PWM_BASE AT91C_BASE_PWMC_CH2
 101:main.c        **** #define SPULE2_PWM_BASE AT91C_BASE_PWMC_CH0
 102:main.c        **** 
 103:main.c        **** #define PA30 SPULE2_DIR
 104:main.c        **** #define PA2  SPULE2_PWM
 105:main.c        **** #define PA18 SPULE1_DIR
 106:main.c        **** #define PA23 SPULE1_PWM
 107:main.c        **** #define PA7 NXT_PORT4_ENABLE
 108:main.c        **** 
 109:main.c        **** #define MASK_FULL1   3
 110:main.c        **** #define MASK_FULL2   3
 111:main.c        **** #define MASK_HALF    7
 112:main.c        **** #define MASK_MICRO   31
 113:main.c        **** 
 114:main.c        **** #define PWM_FREQ_HZ   2000
 115:main.c        **** #define MCK_HZ        48000000
 116:main.c        **** #define CPRD_2KHZ     (MCK_HZ / PWM_FREQ_HZ) // = 24000 
 117:main.c        **** #define STEPS_MICRO   32
 118:main.c        **** 
 119:main.c        **** 
 120:main.c        **** 
 121:main.c        **** AT91PS_PIO pio = (AT91PS_PIO)AT91C_BASE_PIOA;
 122:main.c        **** AT91PS_PMC pmc = (AT91PS_PMC)AT91C_BASE_PMC;
 123:main.c        **** AT91PS_PWMC pwm_ctl = (AT91PS_PWMC)AT91C_BASE_PWMC;
 124:main.c        **** 
 125:main.c        **** 
 126:main.c        **** typedef enum {
 127:main.c        ****   SCHRITT_VOLL_1,
 128:main.c        ****   SCHRITT_VOLL_2,
 129:main.c        ****   SCHRITT_HALB,
 130:main.c        ****   SCHRITT_SINUS,
 131:main.c        ****   SCHRITT_END
 132:main.c        **** } SCHRITT_MODE;
 133:main.c        **** typedef enum {
 134:main.c        ****   POSITION_MANUELL,
 135:main.c        ****   POSITION_KONTINUIERLICH,
 136:main.c        ****   POSITION_END
 137:main.c        **** } POSITION_MODE;
 138:main.c        **** const char *schritt_mode2str[] = {
 139:main.c        ****     [SCHRITT_VOLL_1] = "Vollschritt 1",
 140:main.c        ****     [SCHRITT_VOLL_2] = "Vollschritt 2",
 141:main.c        ****     [SCHRITT_HALB] = "Halbschritt",
 142:main.c        ****     [SCHRITT_SINUS] = "SinusSchritt",
 143:main.c        **** };
 144:main.c        **** 
 145:main.c        **** struct {
 146:main.c        ****   button_t button_old;
 147:main.c        ****   SCHRITT_MODE schritt_mode;
 148:main.c        ****   POSITION_MODE position_mode;
 149:main.c        ****   int8_t pos;
 150:main.c        ****   uint8_t speed;
 151:main.c        ****   uint32_t mode;
 152:main.c        ****   uint8_t step;
 153:main.c        ****   uint16_t reload_table[5];
 154:main.c        ****   uint16_t current_reload;
 155:main.c        ****   uint16_t counter;
 156:main.c        ****   int32_t micro[32];
 157:main.c        ****   int8_t dir;            
 158:main.c        **** 
 159:main.c        **** } schrittmotor_data = {
 160:main.c        ****     .schritt_mode = SCHRITT_VOLL_1,
 161:main.c        ****     .position_mode = POSITION_MANUELL,
 162:main.c        ****     .pos = 0,
 163:main.c        ****     .speed = 0,
 164:main.c        ****     .mode = 0,
 165:main.c        ****     .step = 0,
 166:main.c        ****     .current_reload = 0,
 167:main.c        ****     .dir = 1,
 168:main.c        ****     .counter = 0,
 169:main.c        ****     .reload_table = {
 170:main.c        ****       256, // speed 0 -> 256*4ms = 1024 ms 
 171:main.c        ****       128, // speed 1 -> 512 ms 
 172:main.c        ****       64, // speed 2 -> 256 ms 
 173:main.c        ****       32, // speed 3 -> 128 ms 
 174:main.c        ****       1  // speed 4 -> 4 ms 
 175:main.c        ****     },
 176:main.c        ****     .micro = {
 177:main.c        ****       1,
 178:main.c        ****       4682,
 179:main.c        ****       9184,
 180:main.c        ****       13334,
 181:main.c        ****       16971,
 182:main.c        ****       19955,
 183:main.c        ****       22173,
 184:main.c        ****       23539,
 185:main.c        ****       23999,
 186:main.c        ****       23539,
 187:main.c        ****       22173,
 188:main.c        ****       19955,
 189:main.c        ****       16971,
 190:main.c        ****       13334,
 191:main.c        ****       9184,
 192:main.c        ****       4682,
 193:main.c        ****       1,
 194:main.c        ****       -4682,
 195:main.c        ****       -9184,
 196:main.c        ****       -13334,
 197:main.c        ****       -16971,
 198:main.c        ****       -19955,
 199:main.c        ****       -22173,
 200:main.c        ****       -23539,
 201:main.c        ****       -23999,
 202:main.c        ****       -23539,
 203:main.c        ****       -22173,
 204:main.c        ****       -19955,
 205:main.c        ****       -16971,
 206:main.c        ****       -13334,
 207:main.c        ****       -9184,
 208:main.c        ****       -4682
 209:main.c        **** 
 210:main.c        ****     }
 211:main.c        **** }; 
 212:main.c        **** 
 213:main.c        **** 
 214:main.c        **** 
 215:main.c        **** void schrittmotor_init(SCHRITT_MODE mode) {
 871              		.loc 1 215 43
 872              		.cfi_startproc
 873              		@ Function supports interworking.
 874              		@ args = 0, pretend = 0, frame = 8
 875              		@ frame_needed = 1, uses_anonymous_args = 0
 876              		@ link register save eliminated.
 877 0000 04B02DE5 		str	fp, [sp, #-4]!
 878              		.cfi_def_cfa_offset 4
 879              		.cfi_offset 11, -4
 880 0004 00B08DE2 		add	fp, sp, #0
 881              		.cfi_def_cfa_register 11
 882 0008 0CD04DE2 		sub	sp, sp, #12
 883 000c 0030A0E1 		mov	r3, r0
 884 0010 05304BE5 		strb	r3, [fp, #-5]
 216:main.c        ****   schrittmotor_data.schritt_mode = mode;
 885              		.loc 1 216 34
 886 0014 84219FE5 		ldr	r2, .L49
 887 0018 05305BE5 		ldrb	r3, [fp, #-5]
 888 001c 0130C2E5 		strb	r3, [r2, #1]
 217:main.c        ****   if (mode != SCHRITT_SINUS) {
 889              		.loc 1 217 6
 890 0020 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 891 0024 030053E3 		cmp	r3, #3
 892 0028 1800000A 		beq	.L46
 218:main.c        ****     pmc->PMC_PCER = ((1 << 2) | (1 << 10));
 893              		.loc 1 218 8
 894 002c 70319FE5 		ldr	r3, .L49+4
 895 0030 003093E5 		ldr	r3, [r3]
 896              		.loc 1 218 19
 897 0034 6C219FE5 		ldr	r2, .L49+8
 898 0038 102083E5 		str	r2, [r3, #16]
 219:main.c        ****     pio->PIO_CODR = (1 << 7);
 899              		.loc 1 219 8
 900 003c 68319FE5 		ldr	r3, .L49+12
 901 0040 003093E5 		ldr	r3, [r3]
 902              		.loc 1 219 19
 903 0044 8020A0E3 		mov	r2, #128
 904 0048 342083E5 		str	r2, [r3, #52]
 220:main.c        ****     pio->PIO_MDDR = ALL;
 905              		.loc 1 220 8
 906 004c 58319FE5 		ldr	r3, .L49+12
 907 0050 003093E5 		ldr	r3, [r3]
 908              		.loc 1 220 19
 909 0054 54219FE5 		ldr	r2, .L49+16
 910 0058 542083E5 		str	r2, [r3, #84]
 221:main.c        ****     pio->PIO_PER = ALL;
 911              		.loc 1 221 8
 912 005c 48319FE5 		ldr	r3, .L49+12
 913 0060 003093E5 		ldr	r3, [r3]
 914              		.loc 1 221 18
 915 0064 44219FE5 		ldr	r2, .L49+16
 916 0068 002083E5 		str	r2, [r3]
 222:main.c        ****     pio->PIO_OER = ALL;
 917              		.loc 1 222 8
 918 006c 38319FE5 		ldr	r3, .L49+12
 919 0070 003093E5 		ldr	r3, [r3]
 920              		.loc 1 222 18
 921 0074 34219FE5 		ldr	r2, .L49+16
 922 0078 102083E5 		str	r2, [r3, #16]
 223:main.c        ****     pio->PIO_SODR = (SPULE1_DIR | SPULE2_DIR | SPULE2_PWM | SPULE1_PWM);
 923              		.loc 1 223 8
 924 007c 28319FE5 		ldr	r3, .L49+12
 925 0080 003093E5 		ldr	r3, [r3]
 926              		.loc 1 223 19
 927 0084 28219FE5 		ldr	r2, .L49+20
 928 0088 302083E5 		str	r2, [r3, #48]
 224:main.c        **** 
 225:main.c        ****   } else {
 226:main.c        ****     pmc->PMC_PCER = ((1 << 2) | (1 << 10));
 227:main.c        ****     
 228:main.c        ****     pio->PIO_MDDR = (PA30 | PA18 | PA7);
 229:main.c        ****     pio->PIO_PER = (PA30 | PA18 | PA7);
 230:main.c        ****     pio->PIO_OER = (PA30 | PA18 | PA7);
 231:main.c        ****     pio->PIO_CODR = PA7;
 232:main.c        ****     pio->PIO_SODR = (PA30 | PA18);
 233:main.c        **** 
 234:main.c        ****     pio->PIO_PDR = (PA23 | PA2);
 235:main.c        ****     pio->PIO_ASR = PA2;
 236:main.c        ****     pio->PIO_BSR = PA23;
 237:main.c        **** 
 238:main.c        ****     // Channel 0 PA23 -> PWM0
 239:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CMR = AT91C_PWMC_CPRE_MCK; // CPRE = MCK (kein prescaler) 
 240:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CPRDR = CPRD_2KHZ;         // Period
 241:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CDTYR = (CPRD_2KHZ / 2);   // duty = 50%
 242:main.c        **** 
 243:main.c        ****     // Channel 2 (PA2 -> PWM2
 244:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CMR = AT91C_PWMC_CPRE_MCK; 
 245:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CPRDR = CPRD_2KHZ;
 246:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CDTYR = (CPRD_2KHZ / 2);
 247:main.c        ****     
 248:main.c        ****     pwm_ctl->PWMC_ENA = (AT91C_PWMC_CHID0 | AT91C_PWMC_CHID2);
 249:main.c        **** 
 250:main.c        ****   }
 251:main.c        **** }
 929              		.loc 1 251 1
 930 008c 3F0000EA 		b	.L48
 931              	.L46:
 226:main.c        ****     
 932              		.loc 1 226 8
 933 0090 0C319FE5 		ldr	r3, .L49+4
 934 0094 003093E5 		ldr	r3, [r3]
 226:main.c        ****     
 935              		.loc 1 226 19
 936 0098 08219FE5 		ldr	r2, .L49+8
 937 009c 102083E5 		str	r2, [r3, #16]
 228:main.c        ****     pio->PIO_PER = (PA30 | PA18 | PA7);
 938              		.loc 1 228 8
 939 00a0 04319FE5 		ldr	r3, .L49+12
 940 00a4 003093E5 		ldr	r3, [r3]
 228:main.c        ****     pio->PIO_PER = (PA30 | PA18 | PA7);
 941              		.loc 1 228 19
 942 00a8 08219FE5 		ldr	r2, .L49+24
 943 00ac 542083E5 		str	r2, [r3, #84]
 229:main.c        ****     pio->PIO_OER = (PA30 | PA18 | PA7);
 944              		.loc 1 229 8
 945 00b0 F4309FE5 		ldr	r3, .L49+12
 946 00b4 003093E5 		ldr	r3, [r3]
 229:main.c        ****     pio->PIO_OER = (PA30 | PA18 | PA7);
 947              		.loc 1 229 18
 948 00b8 F8209FE5 		ldr	r2, .L49+24
 949 00bc 002083E5 		str	r2, [r3]
 230:main.c        ****     pio->PIO_CODR = PA7;
 950              		.loc 1 230 8
 951 00c0 E4309FE5 		ldr	r3, .L49+12
 952 00c4 003093E5 		ldr	r3, [r3]
 230:main.c        ****     pio->PIO_CODR = PA7;
 953              		.loc 1 230 18
 954 00c8 E8209FE5 		ldr	r2, .L49+24
 955 00cc 102083E5 		str	r2, [r3, #16]
 231:main.c        ****     pio->PIO_SODR = (PA30 | PA18);
 956              		.loc 1 231 8
 957 00d0 D4309FE5 		ldr	r3, .L49+12
 958 00d4 003093E5 		ldr	r3, [r3]
 231:main.c        ****     pio->PIO_SODR = (PA30 | PA18);
 959              		.loc 1 231 19
 960 00d8 8020A0E3 		mov	r2, #128
 961 00dc 342083E5 		str	r2, [r3, #52]
 232:main.c        **** 
 962              		.loc 1 232 8
 963 00e0 C4309FE5 		ldr	r3, .L49+12
 964 00e4 003093E5 		ldr	r3, [r3]
 232:main.c        **** 
 965              		.loc 1 232 19
 966 00e8 CC209FE5 		ldr	r2, .L49+28
 967 00ec 302083E5 		str	r2, [r3, #48]
 234:main.c        ****     pio->PIO_ASR = PA2;
 968              		.loc 1 234 8
 969 00f0 B4309FE5 		ldr	r3, .L49+12
 970 00f4 003093E5 		ldr	r3, [r3]
 234:main.c        ****     pio->PIO_ASR = PA2;
 971              		.loc 1 234 18
 972 00f8 C0209FE5 		ldr	r2, .L49+32
 973 00fc 042083E5 		str	r2, [r3, #4]
 235:main.c        ****     pio->PIO_BSR = PA23;
 974              		.loc 1 235 8
 975 0100 A4309FE5 		ldr	r3, .L49+12
 976 0104 003093E5 		ldr	r3, [r3]
 235:main.c        ****     pio->PIO_BSR = PA23;
 977              		.loc 1 235 18
 978 0108 0420A0E3 		mov	r2, #4
 979 010c 702083E5 		str	r2, [r3, #112]
 236:main.c        **** 
 980              		.loc 1 236 8
 981 0110 94309FE5 		ldr	r3, .L49+12
 982 0114 003093E5 		ldr	r3, [r3]
 236:main.c        **** 
 983              		.loc 1 236 18
 984 0118 0225A0E3 		mov	r2, #8388608
 985 011c 742083E5 		str	r2, [r3, #116]
 239:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CPRDR = CPRD_2KHZ;         // Period
 986              		.loc 1 239 12
 987 0120 9C309FE5 		ldr	r3, .L49+36
 988 0124 003093E5 		ldr	r3, [r3]
 239:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CPRDR = CPRD_2KHZ;         // Period
 989              		.loc 1 239 34
 990 0128 0020A0E3 		mov	r2, #0
 991 012c 002283E5 		str	r2, [r3, #512]
 240:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CDTYR = (CPRD_2KHZ / 2);   // duty = 50%
 992              		.loc 1 240 12
 993 0130 8C309FE5 		ldr	r3, .L49+36
 994 0134 003093E5 		ldr	r3, [r3]
 240:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CDTYR = (CPRD_2KHZ / 2);   // duty = 50%
 995              		.loc 1 240 36
 996 0138 88209FE5 		ldr	r2, .L49+40
 997 013c 082283E5 		str	r2, [r3, #520]
 241:main.c        **** 
 998              		.loc 1 241 12
 999 0140 7C309FE5 		ldr	r3, .L49+36
 1000 0144 003093E5 		ldr	r3, [r3]
 241:main.c        **** 
 1001              		.loc 1 241 36
 1002 0148 7C209FE5 		ldr	r2, .L49+44
 1003 014c 042283E5 		str	r2, [r3, #516]
 244:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CPRDR = CPRD_2KHZ;
 1004              		.loc 1 244 12
 1005 0150 6C309FE5 		ldr	r3, .L49+36
 1006 0154 003093E5 		ldr	r3, [r3]
 244:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CPRDR = CPRD_2KHZ;
 1007              		.loc 1 244 34
 1008 0158 0020A0E3 		mov	r2, #0
 1009 015c 402283E5 		str	r2, [r3, #576]
 245:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CDTYR = (CPRD_2KHZ / 2);
 1010              		.loc 1 245 12
 1011 0160 5C309FE5 		ldr	r3, .L49+36
 1012 0164 003093E5 		ldr	r3, [r3]
 245:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CDTYR = (CPRD_2KHZ / 2);
 1013              		.loc 1 245 36
 1014 0168 58209FE5 		ldr	r2, .L49+40
 1015 016c 482283E5 		str	r2, [r3, #584]
 246:main.c        ****     
 1016              		.loc 1 246 12
 1017 0170 4C309FE5 		ldr	r3, .L49+36
 1018 0174 003093E5 		ldr	r3, [r3]
 246:main.c        ****     
 1019              		.loc 1 246 36
 1020 0178 4C209FE5 		ldr	r2, .L49+44
 1021 017c 442283E5 		str	r2, [r3, #580]
 248:main.c        **** 
 1022              		.loc 1 248 12
 1023 0180 3C309FE5 		ldr	r3, .L49+36
 1024 0184 003093E5 		ldr	r3, [r3]
 248:main.c        **** 
 1025              		.loc 1 248 23
 1026 0188 0520A0E3 		mov	r2, #5
 1027 018c 042083E5 		str	r2, [r3, #4]
 1028              	.L48:
 1029              		.loc 1 251 1
 1030 0190 0000A0E1 		nop
 1031 0194 00D08BE2 		add	sp, fp, #0
 1032              		.cfi_def_cfa_register 13
 1033              		@ sp needed
 1034 0198 04B09DE4 		ldr	fp, [sp], #4
 1035              		.cfi_restore 11
 1036              		.cfi_def_cfa_offset 0
 1037 019c 1EFF2FE1 		bx	lr
 1038              	.L50:
 1039              		.align	2
 1040              	.L49:
 1041 01a0 00000000 		.word	schrittmotor_data
 1042 01a4 00000000 		.word	pmc
 1043 01a8 04040000 		.word	1028
 1044 01ac 00000000 		.word	pio
 1045 01b0 84008440 		.word	1082392708
 1046 01b4 04008440 		.word	1082392580
 1047 01b8 80000440 		.word	1074004096
 1048 01bc 00000440 		.word	1074003968
 1049 01c0 04008000 		.word	8388612
 1050 01c4 00000000 		.word	pwm_ctl
 1051 01c8 C05D0000 		.word	24000
 1052 01cc E02E0000 		.word	12000
 1053              		.cfi_endproc
 1054              	.LFE17:
 1056              		.section	.text.schrittmotor_update,"ax",%progbits
 1057              		.align	2
 1058              		.global	schrittmotor_update
 1059              		.syntax unified
 1060              		.arm
 1062              	schrittmotor_update:
 1063              	.LFB18:
 252:main.c        **** void schrittmotor_update(void)
 253:main.c        **** {
 1064              		.loc 1 253 1
 1065              		.cfi_startproc
 1066              		@ Function supports interworking.
 1067              		@ args = 0, pretend = 0, frame = 8
 1068              		@ frame_needed = 1, uses_anonymous_args = 0
 1069              		@ link register save eliminated.
 1070 0000 04B02DE5 		str	fp, [sp, #-4]!
 1071              		.cfi_def_cfa_offset 4
 1072              		.cfi_offset 11, -4
 1073 0004 00B08DE2 		add	fp, sp, #0
 1074              		.cfi_def_cfa_register 11
 1075 0008 0CD04DE2 		sub	sp, sp, #12
 254:main.c        ****     uint16_t max_steps;
 255:main.c        ****     switch (schrittmotor_data.schritt_mode) {
 1076              		.loc 1 255 30
 1077 000c 54319FE5 		ldr	r3, .L62
 1078 0010 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1079 0014 0320A0E1 		mov	r2, r3
 1080              		.loc 1 255 5
 1081 0018 4C319FE5 		ldr	r3, .L62+4
 1082 001c 030052E3 		cmp	r2, #3
 1083 0020 0D00008A 		bhi	.L52
 1084 0024 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1085              	.Lrtx54:
 1086 0028 0000A0E1 		nop
 1087              		.section	.rodata
 1088 0039 000000   		.align	2
 1089              	.L54:
 1090 003c 2C000000 		.word	.L57
 1091 0040 38000000 		.word	.L56
 1092 0044 44000000 		.word	.L55
 1093 0048 50000000 		.word	.L53
 1094              		.section	.text.schrittmotor_update
 1095              		.p2align 2
 1096              	.L57:
 256:main.c        ****         case SCHRITT_VOLL_1: max_steps = MASK_FULL1; break;
 1097              		.loc 1 256 40
 1098 002c 0330A0E3 		mov	r3, #3
 1099 0030 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1100              		.loc 1 256 54
 1101 0034 0B0000EA 		b	.L58
 1102              	.L56:
 257:main.c        ****         case SCHRITT_VOLL_2: max_steps = MASK_FULL2; break;
 1103              		.loc 1 257 40
 1104 0038 0330A0E3 		mov	r3, #3
 1105 003c B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1106              		.loc 1 257 54
 1107 0040 080000EA 		b	.L58
 1108              	.L55:
 258:main.c        ****         case SCHRITT_HALB:   max_steps = MASK_HALF;  break;
 1109              		.loc 1 258 40
 1110 0044 0730A0E3 		mov	r3, #7
 1111 0048 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1112              		.loc 1 258 54
 1113 004c 050000EA 		b	.L58
 1114              	.L53:
 259:main.c        ****         case SCHRITT_SINUS:  max_steps = MASK_MICRO; break;
 1115              		.loc 1 259 40
 1116 0050 1F30A0E3 		mov	r3, #31
 1117 0054 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1118              		.loc 1 259 54
 1119 0058 020000EA 		b	.L58
 1120              	.L52:
 260:main.c        ****         default:             max_steps = MASK_FULL1; break;
 1121              		.loc 1 260 40
 1122 005c 0330A0E3 		mov	r3, #3
 1123 0060 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1124              		.loc 1 260 54
 1125 0064 0000A0E1 		nop
 1126              	.L58:
 261:main.c        ****     }
 262:main.c        **** 
 263:main.c        **** 	if (schrittmotor_data.pos !=0) {
 1127              		.loc 1 263 23
 1128 0068 F8309FE5 		ldr	r3, .L62
 1129 006c D330D3E1 		ldrsb	r3, [r3, #3]
 1130              		.loc 1 263 5
 1131 0070 000053E3 		cmp	r3, #0
 1132 0074 3700000A 		beq	.L61
 264:main.c        **** 				if(schrittmotor_data.pos >0){
 1133              		.loc 1 264 25
 1134 0078 E8309FE5 		ldr	r3, .L62
 1135 007c D330D3E1 		ldrsb	r3, [r3, #3]
 1136              		.loc 1 264 7
 1137 0080 000053E3 		cmp	r3, #0
 1138 0084 170000DA 		ble	.L60
 265:main.c        **** 					schrittmotor_data.step = (schrittmotor_data.step+1) & max_steps;
 1139              		.loc 1 265 49
 1140 0088 D8309FE5 		ldr	r3, .L62
 1141 008c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1142              		.loc 1 265 54
 1143 0090 013083E2 		add	r3, r3, #1
 1144 0094 FF3003E2 		and	r3, r3, #255
 1145 0098 033CA0E1 		lsl	r3, r3, #24
 1146 009c 432CA0E1 		asr	r2, r3, #24
 1147              		.loc 1 265 58
 1148 00a0 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 1149 00a4 033CA0E1 		lsl	r3, r3, #24
 1150 00a8 433CA0E1 		asr	r3, r3, #24
 1151 00ac 023003E0 		and	r3, r3, r2
 1152 00b0 033CA0E1 		lsl	r3, r3, #24
 1153 00b4 433CA0E1 		asr	r3, r3, #24
 1154 00b8 FF2003E2 		and	r2, r3, #255
 1155              		.loc 1 265 29
 1156 00bc A4309FE5 		ldr	r3, .L62
 1157 00c0 0C20C3E5 		strb	r2, [r3, #12]
 266:main.c        **** 					schrittmotor_data.pos--;
 1158              		.loc 1 266 23
 1159 00c4 9C309FE5 		ldr	r3, .L62
 1160 00c8 D330D3E1 		ldrsb	r3, [r3, #3]
 1161              		.loc 1 266 27
 1162 00cc FF3003E2 		and	r3, r3, #255
 1163 00d0 013043E2 		sub	r3, r3, #1
 1164 00d4 FF3003E2 		and	r3, r3, #255
 1165 00d8 033CA0E1 		lsl	r3, r3, #24
 1166 00dc 432CA0E1 		asr	r2, r3, #24
 1167 00e0 80309FE5 		ldr	r3, .L62
 1168 00e4 0320C3E5 		strb	r2, [r3, #3]
 1169              	.L60:
 267:main.c        **** 				}
 268:main.c        **** 
 269:main.c        **** 				if(schrittmotor_data.pos <0){
 1170              		.loc 1 269 25
 1171 00e8 78309FE5 		ldr	r3, .L62
 1172 00ec D330D3E1 		ldrsb	r3, [r3, #3]
 1173              		.loc 1 269 7
 1174 00f0 000053E3 		cmp	r3, #0
 1175 00f4 170000AA 		bge	.L61
 270:main.c        **** 					schrittmotor_data.step = (schrittmotor_data.step-1) & max_steps;
 1176              		.loc 1 270 49
 1177 00f8 68309FE5 		ldr	r3, .L62
 1178 00fc 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1179              		.loc 1 270 54
 1180 0100 013043E2 		sub	r3, r3, #1
 1181 0104 FF3003E2 		and	r3, r3, #255
 1182 0108 033CA0E1 		lsl	r3, r3, #24
 1183 010c 432CA0E1 		asr	r2, r3, #24
 1184              		.loc 1 270 58
 1185 0110 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 1186 0114 033CA0E1 		lsl	r3, r3, #24
 1187 0118 433CA0E1 		asr	r3, r3, #24
 1188 011c 023003E0 		and	r3, r3, r2
 1189 0120 033CA0E1 		lsl	r3, r3, #24
 1190 0124 433CA0E1 		asr	r3, r3, #24
 1191 0128 FF2003E2 		and	r2, r3, #255
 1192              		.loc 1 270 29
 1193 012c 34309FE5 		ldr	r3, .L62
 1194 0130 0C20C3E5 		strb	r2, [r3, #12]
 271:main.c        **** 					schrittmotor_data.pos++;
 1195              		.loc 1 271 23
 1196 0134 2C309FE5 		ldr	r3, .L62
 1197 0138 D330D3E1 		ldrsb	r3, [r3, #3]
 1198              		.loc 1 271 27
 1199 013c FF3003E2 		and	r3, r3, #255
 1200 0140 013083E2 		add	r3, r3, #1
 1201 0144 FF3003E2 		and	r3, r3, #255
 1202 0148 033CA0E1 		lsl	r3, r3, #24
 1203 014c 432CA0E1 		asr	r2, r3, #24
 1204 0150 10309FE5 		ldr	r3, .L62
 1205 0154 0320C3E5 		strb	r2, [r3, #3]
 1206              	.L61:
 272:main.c        **** 
 273:main.c        **** 				}
 274:main.c        **** 
 275:main.c        **** 	}
 276:main.c        **** }
 1207              		.loc 1 276 1
 1208 0158 0000A0E1 		nop
 1209 015c 00D08BE2 		add	sp, fp, #0
 1210              		.cfi_def_cfa_register 13
 1211              		@ sp needed
 1212 0160 04B09DE4 		ldr	fp, [sp], #4
 1213              		.cfi_restore 11
 1214              		.cfi_def_cfa_offset 0
 1215 0164 1EFF2FE1 		bx	lr
 1216              	.L63:
 1217              		.align	2
 1218              	.L62:
 1219 0168 00000000 		.word	schrittmotor_data
 1220 016c 3C000000 		.word	.L54
 1221              		.cfi_endproc
 1222              	.LFE18:
 1224              		.section	.text.schrittmotor_process,"ax",%progbits
 1225              		.align	2
 1226              		.global	schrittmotor_process
 1227              		.syntax unified
 1228              		.arm
 1230              	schrittmotor_process:
 1231              	.LFB19:
 277:main.c        **** 
 278:main.c        **** 
 279:main.c        **** void schrittmotor_process(void) {
 1232              		.loc 1 279 33
 1233              		.cfi_startproc
 1234              		@ Function supports interworking.
 1235              		@ args = 0, pretend = 0, frame = 24
 1236              		@ frame_needed = 1, uses_anonymous_args = 0
 1237 0000 00482DE9 		push	{fp, lr}
 1238              		.cfi_def_cfa_offset 8
 1239              		.cfi_offset 11, -8
 1240              		.cfi_offset 14, -4
 1241 0004 04B08DE2 		add	fp, sp, #4
 1242              		.cfi_def_cfa 11, 4
 1243 0008 18D04DE2 		sub	sp, sp, #24
 280:main.c        ****     switch (schrittmotor_data.schritt_mode) {
 1244              		.loc 1 280 30
 1245 000c 3C349FE5 		ldr	r3, .L109
 1246 0010 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1247 0014 0320A0E1 		mov	r2, r3
 1248              		.loc 1 280 5
 1249 0018 34349FE5 		ldr	r3, .L109+4
 1250 001c 030052E3 		cmp	r2, #3
 1251 0020 FF00008A 		bhi	.L101
 1252 0024 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1253              	.Lrtx67:
 1254 0028 0000A0E1 		nop
 1255              		.section	.rodata
 1256              		.align	2
 1257              	.L67:
 1258 004c 2C000000 		.word	.L70
 1259 0050 00010000 		.word	.L69
 1260 0054 C4010000 		.word	.L68
 1261 0058 18030000 		.word	.L66
 1262              		.section	.text.schrittmotor_process
 1263              		.p2align 2
 1264              	.L70:
 281:main.c        **** 
 282:main.c        ****         case SCHRITT_VOLL_1: {
 283:main.c        ****             if ((schrittmotor_data.pos != 0)) {
 1265              		.loc 1 283 35
 1266 002c 1C349FE5 		ldr	r3, .L109
 1267 0030 D330D3E1 		ldrsb	r3, [r3, #3]
 1268              		.loc 1 283 16
 1269 0034 000053E3 		cmp	r3, #0
 1270 0038 FB00000A 		beq	.L102
 284:main.c        ****               schrittmotor_update();
 1271              		.loc 1 284 15
 1272 003c 14349FE5 		ldr	r3, .L109+8
 1273 0040 0FE0A0E1 		mov	lr, pc
 1274 0044 13FF2FE1 		bx	r3
 1275              	.LVL5:
 285:main.c        ****                 switch (schrittmotor_data.step) {
 1276              		.loc 1 285 42
 1277 0048 00349FE5 		ldr	r3, .L109
 1278 004c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1279 0050 0320A0E1 		mov	r2, r3
 1280              		.loc 1 285 17
 1281 0054 00349FE5 		ldr	r3, .L109+12
 1282 0058 030052E3 		cmp	r2, #3
 1283 005c 2500008A 		bhi	.L103
 1284 0060 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1285              	.Lrtx74:
 1286 0064 0000A0E1 		nop
 1287              		.section	.rodata
 1288              		.align	2
 1289              	.L74:
 1290 005c 68000000 		.word	.L77
 1291 0060 8C000000 		.word	.L76
 1292 0064 B0000000 		.word	.L75
 1293 0068 D4000000 		.word	.L73
 1294              		.section	.text.schrittmotor_process
 1295              		.p2align 2
 1296              	.L77:
 286:main.c        ****                     case 0:
 287:main.c        ****                         pio->PIO_SODR = SPULE1_PWM;
 1297              		.loc 1 287 28
 1298 0068 F0339FE5 		ldr	r3, .L109+16
 1299 006c 003093E5 		ldr	r3, [r3]
 1300              		.loc 1 287 39
 1301 0070 0225A0E3 		mov	r2, #8388608
 1302 0074 302083E5 		str	r2, [r3, #48]
 288:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE2_PWM);
 1303              		.loc 1 288 28
 1304 0078 E0339FE5 		ldr	r3, .L109+16
 1305 007c 003093E5 		ldr	r3, [r3]
 1306              		.loc 1 288 39
 1307 0080 DC239FE5 		ldr	r2, .L109+20
 1308 0084 342083E5 		str	r2, [r3, #52]
 289:main.c        ****                         break;
 1309              		.loc 1 289 25
 1310 0088 1B0000EA 		b	.L71
 1311              	.L76:
 290:main.c        ****                     case 1:
 291:main.c        ****                         pio->PIO_SODR = SPULE2_PWM;
 1312              		.loc 1 291 28
 1313 008c CC339FE5 		ldr	r3, .L109+16
 1314 0090 003093E5 		ldr	r3, [r3]
 1315              		.loc 1 291 39
 1316 0094 0420A0E3 		mov	r2, #4
 1317 0098 302083E5 		str	r2, [r3, #48]
 292:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE1_PWM);
 1318              		.loc 1 292 28
 1319 009c BC339FE5 		ldr	r3, .L109+16
 1320 00a0 003093E5 		ldr	r3, [r3]
 1321              		.loc 1 292 39
 1322 00a4 BC239FE5 		ldr	r2, .L109+24
 1323 00a8 342083E5 		str	r2, [r3, #52]
 293:main.c        ****                         break;
 1324              		.loc 1 293 25
 1325 00ac 120000EA 		b	.L71
 1326              	.L75:
 294:main.c        ****                     case 2:
 295:main.c        ****                         pio->PIO_SODR = (SPULE1_DIR | SPULE1_PWM);
 1327              		.loc 1 295 28
 1328 00b0 A8339FE5 		ldr	r3, .L109+16
 1329 00b4 003093E5 		ldr	r3, [r3]
 1330              		.loc 1 295 39
 1331 00b8 2127A0E3 		mov	r2, #8650752
 1332 00bc 302083E5 		str	r2, [r3, #48]
 296:main.c        ****                         pio->PIO_CODR = (SPULE2_DIR | SPULE2_PWM);
 1333              		.loc 1 296 28
 1334 00c0 98339FE5 		ldr	r3, .L109+16
 1335 00c4 003093E5 		ldr	r3, [r3]
 1336              		.loc 1 296 39
 1337 00c8 1121A0E3 		mov	r2, #1073741828
 1338 00cc 342083E5 		str	r2, [r3, #52]
 297:main.c        ****                         break;
 1339              		.loc 1 297 25
 1340 00d0 090000EA 		b	.L71
 1341              	.L73:
 298:main.c        ****                     case 3:
 299:main.c        ****                         pio->PIO_SODR = (SPULE2_DIR | SPULE2_PWM);
 1342              		.loc 1 299 28
 1343 00d4 84339FE5 		ldr	r3, .L109+16
 1344 00d8 003093E5 		ldr	r3, [r3]
 1345              		.loc 1 299 39
 1346 00dc 1121A0E3 		mov	r2, #1073741828
 1347 00e0 302083E5 		str	r2, [r3, #48]
 300:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE1_PWM);
 1348              		.loc 1 300 28
 1349 00e4 74339FE5 		ldr	r3, .L109+16
 1350 00e8 003093E5 		ldr	r3, [r3]
 1351              		.loc 1 300 39
 1352 00ec 2127A0E3 		mov	r2, #8650752
 1353 00f0 342083E5 		str	r2, [r3, #52]
 301:main.c        ****                         break;
 1354              		.loc 1 301 25
 1355 00f4 000000EA 		b	.L71
 1356              	.L103:
 302:main.c        ****                     default:
 303:main.c        ****                         break;
 1357              		.loc 1 303 25
 1358 00f8 0000A0E1 		nop
 1359              	.L71:
 304:main.c        ****                 }
 305:main.c        ****             }
 306:main.c        ****             break;
 1360              		.loc 1 306 13
 1361 00fc CA0000EA 		b	.L102
 1362              	.L69:
 307:main.c        ****         }
 308:main.c        **** 
 309:main.c        ****         case SCHRITT_VOLL_2: {
 310:main.c        ****             if ((schrittmotor_data.pos != 0)) {
 1363              		.loc 1 310 35
 1364 0100 48339FE5 		ldr	r3, .L109
 1365 0104 D330D3E1 		ldrsb	r3, [r3, #3]
 1366              		.loc 1 310 16
 1367 0108 000053E3 		cmp	r3, #0
 1368 010c C800000A 		beq	.L104
 311:main.c        ****               schrittmotor_update();
 1369              		.loc 1 311 15
 1370 0110 40339FE5 		ldr	r3, .L109+8
 1371 0114 0FE0A0E1 		mov	lr, pc
 1372 0118 13FF2FE1 		bx	r3
 1373              	.LVL6:
 312:main.c        ****                 switch (schrittmotor_data.step) {
 1374              		.loc 1 312 42
 1375 011c 2C339FE5 		ldr	r3, .L109
 1376 0120 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1377 0124 0320A0E1 		mov	r2, r3
 1378              		.loc 1 312 17
 1379 0128 3C339FE5 		ldr	r3, .L109+28
 1380 012c 030052E3 		cmp	r2, #3
 1381 0130 2100008A 		bhi	.L105
 1382 0134 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1383              	.Lrtx82:
 1384 0138 0000A0E1 		nop
 1385              		.section	.rodata
 1386              		.align	2
 1387              	.L82:
 1388 006c 3C010000 		.word	.L85
 1389 0070 60010000 		.word	.L84
 1390 0074 84010000 		.word	.L83
 1391 0078 98010000 		.word	.L81
 1392              		.section	.text.schrittmotor_process
 1393              		.p2align 2
 1394              	.L85:
 313:main.c        ****                     case 0:
 314:main.c        ****                         pio->PIO_SODR = (PA2 | PA23);
 1395              		.loc 1 314 28
 1396 013c 1C339FE5 		ldr	r3, .L109+16
 1397 0140 003093E5 		ldr	r3, [r3]
 1398              		.loc 1 314 39
 1399 0144 24239FE5 		ldr	r2, .L109+32
 1400 0148 302083E5 		str	r2, [r3, #48]
 315:main.c        ****                         pio->PIO_CODR = (PA30 | PA18);
 1401              		.loc 1 315 28
 1402 014c 0C339FE5 		ldr	r3, .L109+16
 1403 0150 003093E5 		ldr	r3, [r3]
 1404              		.loc 1 315 39
 1405 0154 18239FE5 		ldr	r2, .L109+36
 1406 0158 342083E5 		str	r2, [r3, #52]
 316:main.c        ****                         break;
 1407              		.loc 1 316 25
 1408 015c 170000EA 		b	.L79
 1409              	.L84:
 317:main.c        ****                     case 1:
 318:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18);
 1410              		.loc 1 318 28
 1411 0160 F8329FE5 		ldr	r3, .L109+16
 1412 0164 003093E5 		ldr	r3, [r3]
 1413              		.loc 1 318 39
 1414 0168 08239FE5 		ldr	r2, .L109+40
 1415 016c 302083E5 		str	r2, [r3, #48]
 319:main.c        ****                         pio->PIO_CODR = (PA30);
 1416              		.loc 1 319 28
 1417 0170 E8329FE5 		ldr	r3, .L109+16
 1418 0174 003093E5 		ldr	r3, [r3]
 1419              		.loc 1 319 39
 1420 0178 0121A0E3 		mov	r2, #1073741824
 1421 017c 342083E5 		str	r2, [r3, #52]
 320:main.c        ****                         break;
 1422              		.loc 1 320 25
 1423 0180 0E0000EA 		b	.L79
 1424              	.L83:
 321:main.c        ****                     case 2:
 322:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18 | PA30);
 1425              		.loc 1 322 28
 1426 0184 D4329FE5 		ldr	r3, .L109+16
 1427 0188 003093E5 		ldr	r3, [r3]
 1428              		.loc 1 322 39
 1429 018c E8229FE5 		ldr	r2, .L109+44
 1430 0190 302083E5 		str	r2, [r3, #48]
 323:main.c        ****                         break;
 1431              		.loc 1 323 25
 1432 0194 090000EA 		b	.L79
 1433              	.L81:
 324:main.c        ****                     case 3:
 325:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA30);
 1434              		.loc 1 325 28
 1435 0198 C0329FE5 		ldr	r3, .L109+16
 1436 019c 003093E5 		ldr	r3, [r3]
 1437              		.loc 1 325 39
 1438 01a0 D8229FE5 		ldr	r2, .L109+48
 1439 01a4 302083E5 		str	r2, [r3, #48]
 326:main.c        ****                         pio->PIO_CODR = (PA18);
 1440              		.loc 1 326 28
 1441 01a8 B0329FE5 		ldr	r3, .L109+16
 1442 01ac 003093E5 		ldr	r3, [r3]
 1443              		.loc 1 326 39
 1444 01b0 0127A0E3 		mov	r2, #262144
 1445 01b4 342083E5 		str	r2, [r3, #52]
 327:main.c        ****                         break;
 1446              		.loc 1 327 25
 1447 01b8 000000EA 		b	.L79
 1448              	.L105:
 328:main.c        ****                     default:
 329:main.c        ****                         break;
 1449              		.loc 1 329 25
 1450 01bc 0000A0E1 		nop
 1451              	.L79:
 330:main.c        ****                 }
 331:main.c        ****             }
 332:main.c        ****             break;
 1452              		.loc 1 332 13
 1453 01c0 9B0000EA 		b	.L104
 1454              	.L68:
 333:main.c        ****         }
 334:main.c        **** 
 335:main.c        ****         case SCHRITT_HALB: {
 336:main.c        ****             if ((schrittmotor_data.pos != 0)) {
 1455              		.loc 1 336 35
 1456 01c4 84329FE5 		ldr	r3, .L109
 1457 01c8 D330D3E1 		ldrsb	r3, [r3, #3]
 1458              		.loc 1 336 16
 1459 01cc 000053E3 		cmp	r3, #0
 1460 01d0 9900000A 		beq	.L106
 337:main.c        ****               schrittmotor_update();
 1461              		.loc 1 337 15
 1462 01d4 7C329FE5 		ldr	r3, .L109+8
 1463 01d8 0FE0A0E1 		mov	lr, pc
 1464 01dc 13FF2FE1 		bx	r3
 1465              	.LVL7:
 338:main.c        ****                 switch (schrittmotor_data.step) {
 1466              		.loc 1 338 42
 1467 01e0 68329FE5 		ldr	r3, .L109
 1468 01e4 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1469 01e8 0320A0E1 		mov	r2, r3
 1470              		.loc 1 338 17
 1471 01ec 90329FE5 		ldr	r3, .L109+52
 1472 01f0 070052E3 		cmp	r2, #7
 1473 01f4 4500008A 		bhi	.L107
 1474 01f8 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1475              	.Lrtx89:
 1476 01fc 0000A0E1 		nop
 1477              		.section	.rodata
 1478              		.align	2
 1479              	.L89:
 1480 007c 00020000 		.word	.L96
 1481 0080 24020000 		.word	.L95
 1482 0084 48020000 		.word	.L94
 1483 0088 6C020000 		.word	.L93
 1484 008c 90020000 		.word	.L92
 1485 0090 B4020000 		.word	.L91
 1486 0094 C8020000 		.word	.L90
 1487 0098 EC020000 		.word	.L88
 1488              		.section	.text.schrittmotor_process
 1489              		.p2align 2
 1490              	.L96:
 339:main.c        ****                     case 0:
 340:main.c        ****                         pio->PIO_SODR = SPULE1_PWM;
 1491              		.loc 1 340 28
 1492 0200 58329FE5 		ldr	r3, .L109+16
 1493 0204 003093E5 		ldr	r3, [r3]
 1494              		.loc 1 340 39
 1495 0208 0225A0E3 		mov	r2, #8388608
 1496 020c 302083E5 		str	r2, [r3, #48]
 341:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE2_PWM);
 1497              		.loc 1 341 28
 1498 0210 48329FE5 		ldr	r3, .L109+16
 1499 0214 003093E5 		ldr	r3, [r3]
 1500              		.loc 1 341 39
 1501 0218 44229FE5 		ldr	r2, .L109+20
 1502 021c 342083E5 		str	r2, [r3, #52]
 342:main.c        ****                         break;
 1503              		.loc 1 342 25
 1504 0220 3B0000EA 		b	.L86
 1505              	.L95:
 343:main.c        ****                     case 1:
 344:main.c        ****                         pio->PIO_SODR = (PA2 | PA23);
 1506              		.loc 1 344 28
 1507 0224 34329FE5 		ldr	r3, .L109+16
 1508 0228 003093E5 		ldr	r3, [r3]
 1509              		.loc 1 344 39
 1510 022c 3C229FE5 		ldr	r2, .L109+32
 1511 0230 302083E5 		str	r2, [r3, #48]
 345:main.c        ****                         pio->PIO_CODR = (PA30 | PA18);
 1512              		.loc 1 345 28
 1513 0234 24329FE5 		ldr	r3, .L109+16
 1514 0238 003093E5 		ldr	r3, [r3]
 1515              		.loc 1 345 39
 1516 023c 30229FE5 		ldr	r2, .L109+36
 1517 0240 342083E5 		str	r2, [r3, #52]
 346:main.c        ****                         break;
 1518              		.loc 1 346 25
 1519 0244 320000EA 		b	.L86
 1520              	.L94:
 347:main.c        ****                     case 2:
 348:main.c        ****                         pio->PIO_SODR = SPULE2_PWM;
 1521              		.loc 1 348 28
 1522 0248 10329FE5 		ldr	r3, .L109+16
 1523 024c 003093E5 		ldr	r3, [r3]
 1524              		.loc 1 348 39
 1525 0250 0420A0E3 		mov	r2, #4
 1526 0254 302083E5 		str	r2, [r3, #48]
 349:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE1_PWM);
 1527              		.loc 1 349 28
 1528 0258 00329FE5 		ldr	r3, .L109+16
 1529 025c 003093E5 		ldr	r3, [r3]
 1530              		.loc 1 349 39
 1531 0260 00229FE5 		ldr	r2, .L109+24
 1532 0264 342083E5 		str	r2, [r3, #52]
 350:main.c        ****                         break;
 1533              		.loc 1 350 25
 1534 0268 290000EA 		b	.L86
 1535              	.L93:
 351:main.c        ****                     case 3:
 352:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18);
 1536              		.loc 1 352 28
 1537 026c EC319FE5 		ldr	r3, .L109+16
 1538 0270 003093E5 		ldr	r3, [r3]
 1539              		.loc 1 352 39
 1540 0274 FC219FE5 		ldr	r2, .L109+40
 1541 0278 302083E5 		str	r2, [r3, #48]
 353:main.c        ****                         pio->PIO_CODR = (PA30);
 1542              		.loc 1 353 28
 1543 027c DC319FE5 		ldr	r3, .L109+16
 1544 0280 003093E5 		ldr	r3, [r3]
 1545              		.loc 1 353 39
 1546 0284 0121A0E3 		mov	r2, #1073741824
 1547 0288 342083E5 		str	r2, [r3, #52]
 354:main.c        ****                         break;
 1548              		.loc 1 354 25
 1549 028c 200000EA 		b	.L86
 1550              	.L92:
 355:main.c        ****                     case 4:
 356:main.c        ****                         pio->PIO_SODR = (SPULE1_DIR | SPULE1_PWM);
 1551              		.loc 1 356 28
 1552 0290 C8319FE5 		ldr	r3, .L109+16
 1553 0294 003093E5 		ldr	r3, [r3]
 1554              		.loc 1 356 39
 1555 0298 2127A0E3 		mov	r2, #8650752
 1556 029c 302083E5 		str	r2, [r3, #48]
 357:main.c        ****                         pio->PIO_CODR = (SPULE2_DIR | SPULE2_PWM);
 1557              		.loc 1 357 28
 1558 02a0 B8319FE5 		ldr	r3, .L109+16
 1559 02a4 003093E5 		ldr	r3, [r3]
 1560              		.loc 1 357 39
 1561 02a8 1121A0E3 		mov	r2, #1073741828
 1562 02ac 342083E5 		str	r2, [r3, #52]
 358:main.c        ****                         break;
 1563              		.loc 1 358 25
 1564 02b0 170000EA 		b	.L86
 1565              	.L91:
 359:main.c        ****                     case 5:
 360:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18 | PA30);
 1566              		.loc 1 360 28
 1567 02b4 A4319FE5 		ldr	r3, .L109+16
 1568 02b8 003093E5 		ldr	r3, [r3]
 1569              		.loc 1 360 39
 1570 02bc B8219FE5 		ldr	r2, .L109+44
 1571 02c0 302083E5 		str	r2, [r3, #48]
 361:main.c        ****                         break;
 1572              		.loc 1 361 25
 1573 02c4 120000EA 		b	.L86
 1574              	.L90:
 362:main.c        ****                     case 6:
 363:main.c        ****                         pio->PIO_SODR = (SPULE2_DIR | SPULE2_PWM);
 1575              		.loc 1 363 28
 1576 02c8 90319FE5 		ldr	r3, .L109+16
 1577 02cc 003093E5 		ldr	r3, [r3]
 1578              		.loc 1 363 39
 1579 02d0 1121A0E3 		mov	r2, #1073741828
 1580 02d4 302083E5 		str	r2, [r3, #48]
 364:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE1_PWM);
 1581              		.loc 1 364 28
 1582 02d8 80319FE5 		ldr	r3, .L109+16
 1583 02dc 003093E5 		ldr	r3, [r3]
 1584              		.loc 1 364 39
 1585 02e0 2127A0E3 		mov	r2, #8650752
 1586 02e4 342083E5 		str	r2, [r3, #52]
 365:main.c        ****                         break;
 1587              		.loc 1 365 25
 1588 02e8 090000EA 		b	.L86
 1589              	.L88:
 366:main.c        ****                     case 7:
 367:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA30);
 1590              		.loc 1 367 28
 1591 02ec 6C319FE5 		ldr	r3, .L109+16
 1592 02f0 003093E5 		ldr	r3, [r3]
 1593              		.loc 1 367 39
 1594 02f4 84219FE5 		ldr	r2, .L109+48
 1595 02f8 302083E5 		str	r2, [r3, #48]
 368:main.c        ****                         pio->PIO_CODR = (PA18);
 1596              		.loc 1 368 28
 1597 02fc 5C319FE5 		ldr	r3, .L109+16
 1598 0300 003093E5 		ldr	r3, [r3]
 1599              		.loc 1 368 39
 1600 0304 0127A0E3 		mov	r2, #262144
 1601 0308 342083E5 		str	r2, [r3, #52]
 369:main.c        ****                         break;
 1602              		.loc 1 369 25
 1603 030c 000000EA 		b	.L86
 1604              	.L107:
 370:main.c        ****                     default:
 371:main.c        ****                         break;
 1605              		.loc 1 371 25
 1606 0310 0000A0E1 		nop
 1607              	.L86:
 372:main.c        ****                 }
 373:main.c        ****             }
 374:main.c        ****             break;
 1608              		.loc 1 374 13
 1609 0314 480000EA 		b	.L106
 1610              	.L66:
 1611              	.LBB7:
 375:main.c        ****         }
 376:main.c        **** 
 377:main.c        ****         case SCHRITT_SINUS: {
 378:main.c        **** 
 379:main.c        ****             schrittmotor_update();
 1612              		.loc 1 379 13
 1613 0318 38319FE5 		ldr	r3, .L109+8
 1614 031c 0FE0A0E1 		mov	lr, pc
 1615 0320 13FF2FE1 		bx	r3
 1616              	.LVL8:
 380:main.c        **** 
 381:main.c        ****             // A = sin, B = cos = sin + 90deg
 382:main.c        ****             uint8_t idxA = schrittmotor_data.step & MASK_MICRO;
 1617              		.loc 1 382 45
 1618 0324 24319FE5 		ldr	r3, .L109
 1619 0328 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1620              		.loc 1 382 21
 1621 032c 1F3003E2 		and	r3, r3, #31
 1622 0330 05304BE5 		strb	r3, [fp, #-5]
 383:main.c        ****             uint8_t idxB = (idxA + (STEPS_MICRO / 4)) & MASK_MICRO; 
 1623              		.loc 1 383 34
 1624 0334 05305BE5 		ldrb	r3, [fp, #-5]
 1625 0338 083083E2 		add	r3, r3, #8
 1626 033c FF3003E2 		and	r3, r3, #255
 1627              		.loc 1 383 21
 1628 0340 1F3003E2 		and	r3, r3, #31
 1629 0344 06304BE5 		strb	r3, [fp, #-6]
 384:main.c        **** 
 385:main.c        ****             //Array auslesen
 386:main.c        ****             int32_t sampleA = (int32_t) schrittmotor_data.micro[idxA];
 1630              		.loc 1 386 31
 1631 0348 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1632              		.loc 1 386 21
 1633 034c FC209FE5 		ldr	r2, .L109
 1634 0350 063083E2 		add	r3, r3, #6
 1635 0354 0331A0E1 		lsl	r3, r3, #2
 1636 0358 033082E0 		add	r3, r2, r3
 1637 035c 043093E5 		ldr	r3, [r3, #4]
 1638 0360 0C300BE5 		str	r3, [fp, #-12]
 387:main.c        ****             int32_t sampleB = (int32_t) schrittmotor_data.micro[idxB];
 1639              		.loc 1 387 31
 1640 0364 06305BE5 		ldrb	r3, [fp, #-6]	@ zero_extendqisi2
 1641              		.loc 1 387 21
 1642 0368 E0209FE5 		ldr	r2, .L109
 1643 036c 063083E2 		add	r3, r3, #6
 1644 0370 0331A0E1 		lsl	r3, r3, #2
 1645 0374 033082E0 		add	r3, r2, r3
 1646 0378 043093E5 		ldr	r3, [r3, #4]
 1647 037c 10300BE5 		str	r3, [fp, #-16]
 388:main.c        **** 
 389:main.c        ****            
 390:main.c        ****             if (sampleB >= 0) {
 1648              		.loc 1 390 16
 1649 0380 10301BE5 		ldr	r3, [fp, #-16]
 1650 0384 000053E3 		cmp	r3, #0
 1651 0388 040000BA 		blt	.L97
 391:main.c        ****                 pio->PIO_CODR = SPULE1_DIR;
 1652              		.loc 1 391 20
 1653 038c CC309FE5 		ldr	r3, .L109+16
 1654 0390 003093E5 		ldr	r3, [r3]
 1655              		.loc 1 391 31
 1656 0394 0127A0E3 		mov	r2, #262144
 1657 0398 342083E5 		str	r2, [r3, #52]
 1658 039c 030000EA 		b	.L98
 1659              	.L97:
 392:main.c        ****             } else {
 393:main.c        ****                 pio->PIO_SODR = SPULE1_DIR;
 1660              		.loc 1 393 20
 1661 03a0 B8309FE5 		ldr	r3, .L109+16
 1662 03a4 003093E5 		ldr	r3, [r3]
 1663              		.loc 1 393 31
 1664 03a8 0127A0E3 		mov	r2, #262144
 1665 03ac 302083E5 		str	r2, [r3, #48]
 1666              	.L98:
 394:main.c        ****             }
 395:main.c        **** 
 396:main.c        ****             if (sampleA >= 0) {
 1667              		.loc 1 396 16
 1668 03b0 0C301BE5 		ldr	r3, [fp, #-12]
 1669 03b4 000053E3 		cmp	r3, #0
 1670 03b8 040000BA 		blt	.L99
 397:main.c        ****                 pio->PIO_CODR = SPULE2_DIR;
 1671              		.loc 1 397 20
 1672 03bc 9C309FE5 		ldr	r3, .L109+16
 1673 03c0 003093E5 		ldr	r3, [r3]
 1674              		.loc 1 397 31
 1675 03c4 0121A0E3 		mov	r2, #1073741824
 1676 03c8 342083E5 		str	r2, [r3, #52]
 1677 03cc 030000EA 		b	.L100
 1678              	.L99:
 398:main.c        ****             } else {
 399:main.c        ****                 pio->PIO_SODR = SPULE2_DIR;
 1679              		.loc 1 399 20
 1680 03d0 88309FE5 		ldr	r3, .L109+16
 1681 03d4 003093E5 		ldr	r3, [r3]
 1682              		.loc 1 399 31
 1683 03d8 0121A0E3 		mov	r2, #1073741824
 1684 03dc 302083E5 		str	r2, [r3, #48]
 1685              	.L100:
 400:main.c        ****             }
 401:main.c        **** 
 402:main.c        ****             uint32_t dutyA = (uint32_t)(sampleA >= 0 ? sampleA : -sampleA);
 1686              		.loc 1 402 30
 1687 03e0 0C301BE5 		ldr	r3, [fp, #-12]
 1688 03e4 000053E3 		cmp	r3, #0
 1689 03e8 003063B2 		rsblt	r3, r3, #0
 1690              		.loc 1 402 22
 1691 03ec 14300BE5 		str	r3, [fp, #-20]
 403:main.c        ****             uint32_t dutyB = (uint32_t)(sampleB >= 0 ? sampleB : -sampleB);
 1692              		.loc 1 403 30
 1693 03f0 10301BE5 		ldr	r3, [fp, #-16]
 1694 03f4 000053E3 		cmp	r3, #0
 1695 03f8 003063B2 		rsblt	r3, r3, #0
 1696              		.loc 1 403 22
 1697 03fc 18300BE5 		str	r3, [fp, #-24]
 404:main.c        **** 
 405:main.c        ****  
 406:main.c        ****             pwm_ctl->PWMC_CH[0].PWMC_CUPDR = dutyA; // PA23 -> channel 0 
 1698              		.loc 1 406 20
 1699 0400 80309FE5 		ldr	r3, .L109+56
 1700 0404 003093E5 		ldr	r3, [r3]
 1701              		.loc 1 406 44
 1702 0408 14201BE5 		ldr	r2, [fp, #-20]
 1703 040c 102283E5 		str	r2, [r3, #528]
 407:main.c        ****             pwm_ctl->PWMC_CH[2].PWMC_CUPDR = dutyB; // PA2  -> channel 2 
 1704              		.loc 1 407 20
 1705 0410 70309FE5 		ldr	r3, .L109+56
 1706 0414 003093E5 		ldr	r3, [r3]
 1707              		.loc 1 407 44
 1708 0418 18201BE5 		ldr	r2, [fp, #-24]
 1709 041c 502283E5 		str	r2, [r3, #592]
 408:main.c        **** 
 409:main.c        ****             break;
 1710              		.loc 1 409 13
 1711 0420 060000EA 		b	.L78
 1712              	.L101:
 1713              	.LBE7:
 410:main.c        ****         }
 411:main.c        **** 
 412:main.c        ****         default: {
 413:main.c        ****             
 414:main.c        ****             break;
 1714              		.loc 1 414 13
 1715 0424 0000A0E1 		nop
 1716 0428 040000EA 		b	.L108
 1717              	.L102:
 306:main.c        ****         }
 1718              		.loc 1 306 13
 1719 042c 0000A0E1 		nop
 1720 0430 020000EA 		b	.L108
 1721              	.L104:
 332:main.c        ****         }
 1722              		.loc 1 332 13
 1723 0434 0000A0E1 		nop
 1724 0438 000000EA 		b	.L108
 1725              	.L106:
 374:main.c        ****         }
 1726              		.loc 1 374 13
 1727 043c 0000A0E1 		nop
 1728              	.L78:
 1729              	.L108:
 415:main.c        ****         }
 416:main.c        ****     } 
 417:main.c        **** } 
 1730              		.loc 1 417 1
 1731 0440 0000A0E1 		nop
 1732 0444 04D04BE2 		sub	sp, fp, #4
 1733              		.cfi_def_cfa 13, 8
 1734              		@ sp needed
 1735 0448 0048BDE8 		pop	{fp, lr}
 1736              		.cfi_restore 14
 1737              		.cfi_restore 11
 1738              		.cfi_def_cfa_offset 0
 1739 044c 1EFF2FE1 		bx	lr
 1740              	.L110:
 1741              		.align	2
 1742              	.L109:
 1743 0450 00000000 		.word	schrittmotor_data
 1744 0454 4C000000 		.word	.L67
 1745 0458 00000000 		.word	schrittmotor_update
 1746 045c 5C000000 		.word	.L74
 1747 0460 00000000 		.word	pio
 1748 0464 04000440 		.word	1074003972
 1749 0468 00008440 		.word	1082392576
 1750 046c 6C000000 		.word	.L82
 1751 0470 04008000 		.word	8388612
 1752 0474 00000440 		.word	1074003968
 1753 0478 04008400 		.word	8650756
 1754 047c 04008440 		.word	1082392580
 1755 0480 04008040 		.word	1082130436
 1756 0484 7C000000 		.word	.L89
 1757 0488 00000000 		.word	pwm_ctl
 1758              		.cfi_endproc
 1759              	.LFE19:
 1761              		.section	.text.ui_init,"ax",%progbits
 1762              		.align	2
 1763              		.global	ui_init
 1764              		.syntax unified
 1765              		.arm
 1767              	ui_init:
 1768              	.LFB20:
 418:main.c        **** 
 419:main.c        **** 
 420:main.c        **** void ui_init(void) {}
 1769              		.loc 1 420 20
 1770              		.cfi_startproc
 1771              		@ Function supports interworking.
 1772              		@ args = 0, pretend = 0, frame = 0
 1773              		@ frame_needed = 1, uses_anonymous_args = 0
 1774              		@ link register save eliminated.
 1775 0000 04B02DE5 		str	fp, [sp, #-4]!
 1776              		.cfi_def_cfa_offset 4
 1777              		.cfi_offset 11, -4
 1778 0004 00B08DE2 		add	fp, sp, #0
 1779              		.cfi_def_cfa_register 11
 1780              		.loc 1 420 21
 1781 0008 0000A0E1 		nop
 1782 000c 00D08BE2 		add	sp, fp, #0
 1783              		.cfi_def_cfa_register 13
 1784              		@ sp needed
 1785 0010 04B09DE4 		ldr	fp, [sp], #4
 1786              		.cfi_restore 11
 1787              		.cfi_def_cfa_offset 0
 1788 0014 1EFF2FE1 		bx	lr
 1789              		.cfi_endproc
 1790              	.LFE20:
 1792              		.section	.text.ui_process,"ax",%progbits
 1793              		.align	2
 1794              		.global	ui_process
 1795              		.syntax unified
 1796              		.arm
 1798              	ui_process:
 1799              	.LFB21:
 421:main.c        **** 
 422:main.c        **** void ui_process(void) {
 1800              		.loc 1 422 23
 1801              		.cfi_startproc
 1802              		@ Function supports interworking.
 1803              		@ args = 0, pretend = 0, frame = 8
 1804              		@ frame_needed = 1, uses_anonymous_args = 0
 1805 0000 00482DE9 		push	{fp, lr}
 1806              		.cfi_def_cfa_offset 8
 1807              		.cfi_offset 11, -8
 1808              		.cfi_offset 14, -4
 1809 0004 04B08DE2 		add	fp, sp, #4
 1810              		.cfi_def_cfa 11, 4
 1811 0008 08D04DE2 		sub	sp, sp, #8
 423:main.c        ****  
 424:main.c        **** 
 425:main.c        ****   button_t button_new = nxt_avr_get_buttons();
 1812              		.loc 1 425 25
 1813 000c 48349FE5 		ldr	r3, .L129
 1814 0010 0FE0A0E1 		mov	lr, pc
 1815 0014 13FF2FE1 		bx	r3
 1816              	.LVL9:
 1817 0018 0030A0E1 		mov	r3, r0
 1818 001c 08304BE5 		strb	r3, [fp, #-8]
 426:main.c        **** 
 427:main.c        ****   if ((button_new.orange == 1) && (schrittmotor_data.button_old.orange == 0)) {
 1819              		.loc 1 427 26
 1820 0020 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1821 0024 013003E2 		and	r3, r3, #1
 1822 0028 FF3003E2 		and	r3, r3, #255
 1823              		.loc 1 427 6
 1824 002c 000053E3 		cmp	r3, #0
 1825 0030 1F00000A 		beq	.L113
 1826              		.loc 1 427 72 discriminator 1
 1827 0034 24349FE5 		ldr	r3, .L129+4
 1828 0038 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1829 003c 013003E2 		and	r3, r3, #1
 1830 0040 FF3003E2 		and	r3, r3, #255
 1831              		.loc 1 427 32 discriminator 1
 1832 0044 000053E3 		cmp	r3, #0
 1833 0048 1900001A 		bne	.L113
 428:main.c        **** 
 429:main.c        ****     if (schrittmotor_data.schritt_mode + 1 < SCHRITT_END) {
 1834              		.loc 1 429 26
 1835 004c 0C349FE5 		ldr	r3, .L129+4
 1836 0050 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1837              		.loc 1 429 8
 1838 0054 020053E3 		cmp	r3, #2
 1839 0058 0C00008A 		bhi	.L114
 430:main.c        ****       schrittmotor_data.schritt_mode++;
 1840              		.loc 1 430 24
 1841 005c FC339FE5 		ldr	r3, .L129+4
 1842 0060 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1843              		.loc 1 430 37
 1844 0064 013083E2 		add	r3, r3, #1
 1845 0068 FF2003E2 		and	r2, r3, #255
 1846 006c EC339FE5 		ldr	r3, .L129+4
 1847 0070 0120C3E5 		strb	r2, [r3, #1]
 431:main.c        ****       schrittmotor_init(schrittmotor_data.schritt_mode);
 1848              		.loc 1 431 7
 1849 0074 E4339FE5 		ldr	r3, .L129+4
 1850 0078 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1851 007c 0300A0E1 		mov	r0, r3
 1852 0080 DC339FE5 		ldr	r3, .L129+8
 1853 0084 0FE0A0E1 		mov	lr, pc
 1854 0088 13FF2FE1 		bx	r3
 1855              	.LVL10:
 1856 008c 080000EA 		b	.L113
 1857              	.L114:
 432:main.c        ****     } else {
 433:main.c        ****       schrittmotor_data.schritt_mode = SCHRITT_VOLL_1;
 1858              		.loc 1 433 38
 1859 0090 C8339FE5 		ldr	r3, .L129+4
 1860 0094 0020A0E3 		mov	r2, #0
 1861 0098 0120C3E5 		strb	r2, [r3, #1]
 434:main.c        ****       schrittmotor_init(schrittmotor_data.schritt_mode);
 1862              		.loc 1 434 7
 1863 009c BC339FE5 		ldr	r3, .L129+4
 1864 00a0 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1865 00a4 0300A0E1 		mov	r0, r3
 1866 00a8 B4339FE5 		ldr	r3, .L129+8
 1867 00ac 0FE0A0E1 		mov	lr, pc
 1868 00b0 13FF2FE1 		bx	r3
 1869              	.LVL11:
 1870              	.L113:
 435:main.c        ****     }
 436:main.c        **** 
 437:main.c        ****   }
 438:main.c        **** 
 439:main.c        ****   if ((button_new.grey == 1) && (schrittmotor_data.button_old.grey == 0)) {
 1871              		.loc 1 439 24
 1872 00b4 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1873 00b8 083003E2 		and	r3, r3, #8
 1874 00bc FF3003E2 		and	r3, r3, #255
 1875              		.loc 1 439 6
 1876 00c0 000053E3 		cmp	r3, #0
 1877 00c4 1300000A 		beq	.L115
 1878              		.loc 1 439 68 discriminator 1
 1879 00c8 90339FE5 		ldr	r3, .L129+4
 1880 00cc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1881 00d0 083003E2 		and	r3, r3, #8
 1882 00d4 FF3003E2 		and	r3, r3, #255
 1883              		.loc 1 439 30 discriminator 1
 1884 00d8 000053E3 		cmp	r3, #0
 1885 00dc 0D00001A 		bne	.L115
 440:main.c        **** 
 441:main.c        ****     if (schrittmotor_data.position_mode + 1 < POSITION_END) {
 1886              		.loc 1 441 26
 1887 00e0 78339FE5 		ldr	r3, .L129+4
 1888 00e4 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1889              		.loc 1 441 8
 1890 00e8 000053E3 		cmp	r3, #0
 1891 00ec 0600001A 		bne	.L116
 442:main.c        ****       schrittmotor_data.position_mode++;
 1892              		.loc 1 442 24
 1893 00f0 68339FE5 		ldr	r3, .L129+4
 1894 00f4 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1895              		.loc 1 442 38
 1896 00f8 013083E2 		add	r3, r3, #1
 1897 00fc FF2003E2 		and	r2, r3, #255
 1898 0100 58339FE5 		ldr	r3, .L129+4
 1899 0104 0220C3E5 		strb	r2, [r3, #2]
 1900 0108 020000EA 		b	.L115
 1901              	.L116:
 443:main.c        ****     } else {
 444:main.c        ****       schrittmotor_data.position_mode = POSITION_MANUELL;
 1902              		.loc 1 444 39
 1903 010c 4C339FE5 		ldr	r3, .L129+4
 1904 0110 0020A0E3 		mov	r2, #0
 1905 0114 0220C3E5 		strb	r2, [r3, #2]
 1906              	.L115:
 445:main.c        ****     }
 446:main.c        ****   }
 447:main.c        **** 
 448:main.c        **** if (schrittmotor_data.position_mode == POSITION_KONTINUIERLICH) {
 1907              		.loc 1 448 22
 1908 0118 40339FE5 		ldr	r3, .L129+4
 1909 011c 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1910              		.loc 1 448 4
 1911 0120 010053E3 		cmp	r3, #1
 1912 0124 7700001A 		bne	.L117
 449:main.c        ****     if (((button_new.left == 1) && (schrittmotor_data.dir == 1)) && (schrittmotor_data.button_old.l
 1913              		.loc 1 449 27
 1914 0128 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1915 012c 023003E2 		and	r3, r3, #2
 1916 0130 FF3003E2 		and	r3, r3, #255
 1917              		.loc 1 449 8
 1918 0134 000053E3 		cmp	r3, #0
 1919 0138 1D00000A 		beq	.L118
 1920              		.loc 1 449 54 discriminator 1
 1921 013c 1C339FE5 		ldr	r3, .L129+4
 1922 0140 DC39D3E1 		ldrsb	r3, [r3, #156]
 1923              		.loc 1 449 33 discriminator 1
 1924 0144 010053E3 		cmp	r3, #1
 1925 0148 1900001A 		bne	.L118
 1926              		.loc 1 449 104 discriminator 2
 1927 014c 0C339FE5 		ldr	r3, .L129+4
 1928 0150 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1929 0154 023003E2 		and	r3, r3, #2
 1930 0158 FF3003E2 		and	r3, r3, #255
 1931              		.loc 1 449 66 discriminator 2
 1932 015c 000053E3 		cmp	r3, #0
 1933 0160 1300001A 		bne	.L118
 450:main.c        ****         if (schrittmotor_data.speed > 0) {
 1934              		.loc 1 450 30
 1935 0164 F4329FE5 		ldr	r3, .L129+4
 1936 0168 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1937              		.loc 1 450 12
 1938 016c 000053E3 		cmp	r3, #0
 1939 0170 0600000A 		beq	.L119
 451:main.c        ****             schrittmotor_data.speed--;
 1940              		.loc 1 451 30
 1941 0174 E4329FE5 		ldr	r3, .L129+4
 1942 0178 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1943              		.loc 1 451 36
 1944 017c 013043E2 		sub	r3, r3, #1
 1945 0180 FF2003E2 		and	r2, r3, #255
 1946 0184 D4329FE5 		ldr	r3, .L129+4
 1947 0188 0420C3E5 		strb	r2, [r3, #4]
 1948 018c 080000EA 		b	.L118
 1949              	.L119:
 452:main.c        ****         } else {
 453:main.c        ****             schrittmotor_data.dir = (schrittmotor_data.dir == 1) ? -1 : 1;
 1950              		.loc 1 453 55
 1951 0190 C8329FE5 		ldr	r3, .L129+4
 1952 0194 DC39D3E1 		ldrsb	r3, [r3, #156]
 1953              		.loc 1 453 35
 1954 0198 010053E3 		cmp	r3, #1
 1955 019c 0100001A 		bne	.L120
 1956              		.loc 1 453 35 is_stmt 0 discriminator 1
 1957 01a0 0020E0E3 		mvn	r2, #0
 1958 01a4 000000EA 		b	.L121
 1959              	.L120:
 1960              		.loc 1 453 35 discriminator 2
 1961 01a8 0120A0E3 		mov	r2, #1
 1962              	.L121:
 1963              		.loc 1 453 35 discriminator 4
 1964 01ac AC329FE5 		ldr	r3, .L129+4
 1965 01b0 9C20C3E5 		strb	r2, [r3, #156]
 1966              	.L118:
 454:main.c        ****         }
 455:main.c        ****     }
 456:main.c        ****     if (((button_new.left == 1) && (schrittmotor_data.dir == -1)) && (schrittmotor_data.button_old.
 1967              		.loc 1 456 27 is_stmt 1
 1968 01b4 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1969 01b8 023003E2 		and	r3, r3, #2
 1970 01bc FF3003E2 		and	r3, r3, #255
 1971              		.loc 1 456 8
 1972 01c0 000053E3 		cmp	r3, #0
 1973 01c4 1300000A 		beq	.L122
 1974              		.loc 1 456 54 discriminator 1
 1975 01c8 90329FE5 		ldr	r3, .L129+4
 1976 01cc DC39D3E1 		ldrsb	r3, [r3, #156]
 1977              		.loc 1 456 33 discriminator 1
 1978 01d0 010073E3 		cmn	r3, #1
 1979 01d4 0F00001A 		bne	.L122
 1980              		.loc 1 456 105 discriminator 2
 1981 01d8 80329FE5 		ldr	r3, .L129+4
 1982 01dc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1983 01e0 023003E2 		and	r3, r3, #2
 1984 01e4 FF3003E2 		and	r3, r3, #255
 1985              		.loc 1 456 67 discriminator 2
 1986 01e8 000053E3 		cmp	r3, #0
 1987 01ec 0900001A 		bne	.L122
 457:main.c        ****         if (schrittmotor_data.speed <4 ) {
 1988              		.loc 1 457 30
 1989 01f0 68329FE5 		ldr	r3, .L129+4
 1990 01f4 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1991              		.loc 1 457 12
 1992 01f8 030053E3 		cmp	r3, #3
 1993 01fc 0500008A 		bhi	.L122
 458:main.c        ****             schrittmotor_data.speed++;
 1994              		.loc 1 458 30
 1995 0200 58329FE5 		ldr	r3, .L129+4
 1996 0204 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1997              		.loc 1 458 36
 1998 0208 013083E2 		add	r3, r3, #1
 1999 020c FF2003E2 		and	r2, r3, #255
 2000 0210 48329FE5 		ldr	r3, .L129+4
 2001 0214 0420C3E5 		strb	r2, [r3, #4]
 2002              	.L122:
 459:main.c        ****         }
 460:main.c        ****     }
 461:main.c        **** 
 462:main.c        ****     if (((button_new.right == 1) && (schrittmotor_data.dir == 1)) && (schrittmotor_data.button_old.
 2003              		.loc 1 462 28
 2004 0218 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2005 021c 043003E2 		and	r3, r3, #4
 2006 0220 FF3003E2 		and	r3, r3, #255
 2007              		.loc 1 462 8
 2008 0224 000053E3 		cmp	r3, #0
 2009 0228 1300000A 		beq	.L123
 2010              		.loc 1 462 55 discriminator 1
 2011 022c 2C329FE5 		ldr	r3, .L129+4
 2012 0230 DC39D3E1 		ldrsb	r3, [r3, #156]
 2013              		.loc 1 462 34 discriminator 1
 2014 0234 010053E3 		cmp	r3, #1
 2015 0238 0F00001A 		bne	.L123
 2016              		.loc 1 462 106 discriminator 2
 2017 023c 1C329FE5 		ldr	r3, .L129+4
 2018 0240 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2019 0244 043003E2 		and	r3, r3, #4
 2020 0248 FF3003E2 		and	r3, r3, #255
 2021              		.loc 1 462 67 discriminator 2
 2022 024c 000053E3 		cmp	r3, #0
 2023 0250 0900001A 		bne	.L123
 463:main.c        ****         if (schrittmotor_data.speed < 4) {
 2024              		.loc 1 463 30
 2025 0254 04329FE5 		ldr	r3, .L129+4
 2026 0258 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2027              		.loc 1 463 12
 2028 025c 030053E3 		cmp	r3, #3
 2029 0260 0500008A 		bhi	.L123
 464:main.c        ****             schrittmotor_data.speed++;
 2030              		.loc 1 464 30
 2031 0264 F4319FE5 		ldr	r3, .L129+4
 2032 0268 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2033              		.loc 1 464 36
 2034 026c 013083E2 		add	r3, r3, #1
 2035 0270 FF2003E2 		and	r2, r3, #255
 2036 0274 E4319FE5 		ldr	r3, .L129+4
 2037 0278 0420C3E5 		strb	r2, [r3, #4]
 2038              	.L123:
 465:main.c        ****         }
 466:main.c        ****     }
 467:main.c        ****      if (((button_new.right == 1) && (schrittmotor_data.dir == -1)) && (schrittmotor_data.button_ol
 2039              		.loc 1 467 29
 2040 027c 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2041 0280 043003E2 		and	r3, r3, #4
 2042 0284 FF3003E2 		and	r3, r3, #255
 2043              		.loc 1 467 9
 2044 0288 000053E3 		cmp	r3, #0
 2045 028c 1D00000A 		beq	.L117
 2046              		.loc 1 467 56 discriminator 1
 2047 0290 C8319FE5 		ldr	r3, .L129+4
 2048 0294 DC39D3E1 		ldrsb	r3, [r3, #156]
 2049              		.loc 1 467 35 discriminator 1
 2050 0298 010073E3 		cmn	r3, #1
 2051 029c 1900001A 		bne	.L117
 2052              		.loc 1 467 108 discriminator 2
 2053 02a0 B8319FE5 		ldr	r3, .L129+4
 2054 02a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2055 02a8 043003E2 		and	r3, r3, #4
 2056 02ac FF3003E2 		and	r3, r3, #255
 2057              		.loc 1 467 69 discriminator 2
 2058 02b0 000053E3 		cmp	r3, #0
 2059 02b4 1300001A 		bne	.L117
 468:main.c        ****         if (schrittmotor_data.speed > 0) {
 2060              		.loc 1 468 30
 2061 02b8 A0319FE5 		ldr	r3, .L129+4
 2062 02bc 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2063              		.loc 1 468 12
 2064 02c0 000053E3 		cmp	r3, #0
 2065 02c4 0600000A 		beq	.L124
 469:main.c        ****             schrittmotor_data.speed--;
 2066              		.loc 1 469 30
 2067 02c8 90319FE5 		ldr	r3, .L129+4
 2068 02cc 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2069              		.loc 1 469 36
 2070 02d0 013043E2 		sub	r3, r3, #1
 2071 02d4 FF2003E2 		and	r2, r3, #255
 2072 02d8 80319FE5 		ldr	r3, .L129+4
 2073 02dc 0420C3E5 		strb	r2, [r3, #4]
 2074 02e0 080000EA 		b	.L117
 2075              	.L124:
 470:main.c        ****         } else {
 471:main.c        ****             schrittmotor_data.dir = (schrittmotor_data.dir == -1) ? 1 : -1;
 2076              		.loc 1 471 55
 2077 02e4 74319FE5 		ldr	r3, .L129+4
 2078 02e8 DC39D3E1 		ldrsb	r3, [r3, #156]
 2079              		.loc 1 471 35
 2080 02ec 010073E3 		cmn	r3, #1
 2081 02f0 0100001A 		bne	.L125
 2082              		.loc 1 471 35 is_stmt 0 discriminator 1
 2083 02f4 0120A0E3 		mov	r2, #1
 2084 02f8 000000EA 		b	.L126
 2085              	.L125:
 2086              		.loc 1 471 35 discriminator 2
 2087 02fc 0020E0E3 		mvn	r2, #0
 2088              	.L126:
 2089              		.loc 1 471 35 discriminator 4
 2090 0300 58319FE5 		ldr	r3, .L129+4
 2091 0304 9C20C3E5 		strb	r2, [r3, #156]
 2092              	.L117:
 472:main.c        ****         }
 473:main.c        ****     }
 474:main.c        **** }
 475:main.c        **** 
 476:main.c        ****   if (schrittmotor_data.position_mode == POSITION_MANUELL) {
 2093              		.loc 1 476 24 is_stmt 1
 2094 0308 50319FE5 		ldr	r3, .L129+4
 2095 030c 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2096              		.loc 1 476 6
 2097 0310 000053E3 		cmp	r3, #0
 2098 0314 2700001A 		bne	.L127
 477:main.c        **** 
 478:main.c        ****     if ((button_new.left == 1) && (schrittmotor_data.button_old.left == 0)) {
 2099              		.loc 1 478 26
 2100 0318 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2101 031c 023003E2 		and	r3, r3, #2
 2102 0320 FF3003E2 		and	r3, r3, #255
 2103              		.loc 1 478 8
 2104 0324 000053E3 		cmp	r3, #0
 2105 0328 0E00000A 		beq	.L128
 2106              		.loc 1 478 70 discriminator 1
 2107 032c 2C319FE5 		ldr	r3, .L129+4
 2108 0330 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2109 0334 023003E2 		and	r3, r3, #2
 2110 0338 FF3003E2 		and	r3, r3, #255
 2111              		.loc 1 478 32 discriminator 1
 2112 033c 000053E3 		cmp	r3, #0
 2113 0340 0800001A 		bne	.L128
 479:main.c        ****       schrittmotor_data.pos--;
 2114              		.loc 1 479 24
 2115 0344 14319FE5 		ldr	r3, .L129+4
 2116 0348 D330D3E1 		ldrsb	r3, [r3, #3]
 2117              		.loc 1 479 28
 2118 034c FF3003E2 		and	r3, r3, #255
 2119 0350 013043E2 		sub	r3, r3, #1
 2120 0354 FF3003E2 		and	r3, r3, #255
 2121 0358 033CA0E1 		lsl	r3, r3, #24
 2122 035c 432CA0E1 		asr	r2, r3, #24
 2123 0360 F8309FE5 		ldr	r3, .L129+4
 2124 0364 0320C3E5 		strb	r2, [r3, #3]
 2125              	.L128:
 480:main.c        ****     }
 481:main.c        ****     if ((button_new.right == 1) && (schrittmotor_data.button_old.right == 0)) {
 2126              		.loc 1 481 27
 2127 0368 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2128 036c 043003E2 		and	r3, r3, #4
 2129 0370 FF3003E2 		and	r3, r3, #255
 2130              		.loc 1 481 8
 2131 0374 000053E3 		cmp	r3, #0
 2132 0378 0E00000A 		beq	.L127
 2133              		.loc 1 481 72 discriminator 1
 2134 037c DC309FE5 		ldr	r3, .L129+4
 2135 0380 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2136 0384 043003E2 		and	r3, r3, #4
 2137 0388 FF3003E2 		and	r3, r3, #255
 2138              		.loc 1 481 33 discriminator 1
 2139 038c 000053E3 		cmp	r3, #0
 2140 0390 0800001A 		bne	.L127
 482:main.c        ****       schrittmotor_data.pos++;
 2141              		.loc 1 482 24
 2142 0394 C4309FE5 		ldr	r3, .L129+4
 2143 0398 D330D3E1 		ldrsb	r3, [r3, #3]
 2144              		.loc 1 482 28
 2145 039c FF3003E2 		and	r3, r3, #255
 2146 03a0 013083E2 		add	r3, r3, #1
 2147 03a4 FF3003E2 		and	r3, r3, #255
 2148 03a8 033CA0E1 		lsl	r3, r3, #24
 2149 03ac 432CA0E1 		asr	r2, r3, #24
 2150 03b0 A8309FE5 		ldr	r3, .L129+4
 2151 03b4 0320C3E5 		strb	r2, [r3, #3]
 2152              	.L127:
 483:main.c        ****     }
 484:main.c        ****   }
 485:main.c        **** 
 486:main.c        ****   
 487:main.c        **** 
 488:main.c        ****   // Beispielanwendung für Display
 489:main.c        ****   static uint32_t count = 0;
 490:main.c        ****   display_goto_xy(0, 1);
 2153              		.loc 1 490 3
 2154 03b8 0110A0E3 		mov	r1, #1
 2155 03bc 0000A0E3 		mov	r0, #0
 2156 03c0 A0309FE5 		ldr	r3, .L129+12
 2157 03c4 0FE0A0E1 		mov	lr, pc
 2158 03c8 13FF2FE1 		bx	r3
 2159              	.LVL12:
 491:main.c        ****   display_unsigned(++count, 4);
 2160              		.loc 1 491 3
 2161 03cc 98309FE5 		ldr	r3, .L129+16
 2162 03d0 003093E5 		ldr	r3, [r3]
 2163 03d4 013083E2 		add	r3, r3, #1
 2164 03d8 8C209FE5 		ldr	r2, .L129+16
 2165 03dc 003082E5 		str	r3, [r2]
 2166 03e0 84309FE5 		ldr	r3, .L129+16
 2167 03e4 003093E5 		ldr	r3, [r3]
 2168 03e8 0410A0E3 		mov	r1, #4
 2169 03ec 0300A0E1 		mov	r0, r3
 2170 03f0 78309FE5 		ldr	r3, .L129+20
 2171 03f4 0FE0A0E1 		mov	lr, pc
 2172 03f8 13FF2FE1 		bx	r3
 2173              	.LVL13:
 492:main.c        ****   display_goto_xy(0, 2);
 2174              		.loc 1 492 3
 2175 03fc 0210A0E3 		mov	r1, #2
 2176 0400 0000A0E3 		mov	r0, #0
 2177 0404 5C309FE5 		ldr	r3, .L129+12
 2178 0408 0FE0A0E1 		mov	lr, pc
 2179 040c 13FF2FE1 		bx	r3
 2180              	.LVL14:
 493:main.c        ****   display_string(schritt_mode2str[schrittmotor_data.schritt_mode]);
 2181              		.loc 1 493 52
 2182 0410 48309FE5 		ldr	r3, .L129+4
 2183 0414 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2184 0418 0320A0E1 		mov	r2, r3
 2185              		.loc 1 493 3
 2186 041c 50309FE5 		ldr	r3, .L129+24
 2187 0420 023193E7 		ldr	r3, [r3, r2, lsl #2]
 2188 0424 0300A0E1 		mov	r0, r3
 2189 0428 48309FE5 		ldr	r3, .L129+28
 2190 042c 0FE0A0E1 		mov	lr, pc
 2191 0430 13FF2FE1 		bx	r3
 2192              	.LVL15:
 494:main.c        ****   display_update();
 2193              		.loc 1 494 3
 2194 0434 40309FE5 		ldr	r3, .L129+32
 2195 0438 0FE0A0E1 		mov	lr, pc
 2196 043c 13FF2FE1 		bx	r3
 2197              	.LVL16:
 495:main.c        **** 
 496:main.c        ****   schrittmotor_data.button_old = button_new;
 2198              		.loc 1 496 32
 2199 0440 18209FE5 		ldr	r2, .L129+4
 2200 0444 08305BE5 		ldrb	r3, [fp, #-8]
 2201 0448 0030C2E5 		strb	r3, [r2]
 497:main.c        **** }
 2202              		.loc 1 497 1
 2203 044c 0000A0E1 		nop
 2204 0450 04D04BE2 		sub	sp, fp, #4
 2205              		.cfi_def_cfa 13, 8
 2206              		@ sp needed
 2207 0454 0048BDE8 		pop	{fp, lr}
 2208              		.cfi_restore 14
 2209              		.cfi_restore 11
 2210              		.cfi_def_cfa_offset 0
 2211 0458 1EFF2FE1 		bx	lr
 2212              	.L130:
 2213              		.align	2
 2214              	.L129:
 2215 045c 00000000 		.word	nxt_avr_get_buttons
 2216 0460 00000000 		.word	schrittmotor_data
 2217 0464 00000000 		.word	schrittmotor_init
 2218 0468 00000000 		.word	display_goto_xy
 2219 046c 28030000 		.word	count.2
 2220 0470 00000000 		.word	display_unsigned
 2221 0474 00000000 		.word	schritt_mode2str
 2222 0478 00000000 		.word	display_string
 2223 047c 00000000 		.word	display_update
 2224              		.cfi_endproc
 2225              	.LFE21:
 2227              		.section	.text.task_4ms,"ax",%progbits
 2228              		.align	2
 2229              		.global	task_4ms
 2230              		.syntax unified
 2231              		.arm
 2233              	task_4ms:
 2234              	.LFB22:
 498:main.c        **** 
 499:main.c        **** /*****************************************************************************/
 500:main.c        **** /*   Hilfsroutinen                                                           */
 501:main.c        **** /*****************************************************************************/
 502:main.c        **** 
 503:main.c        **** void task_4ms(void) {
 2235              		.loc 1 503 21
 2236              		.cfi_startproc
 2237              		@ Function supports interworking.
 2238              		@ args = 0, pretend = 0, frame = 0
 2239              		@ frame_needed = 1, uses_anonymous_args = 0
 2240 0000 00482DE9 		push	{fp, lr}
 2241              		.cfi_def_cfa_offset 8
 2242              		.cfi_offset 11, -8
 2243              		.cfi_offset 14, -4
 2244 0004 04B08DE2 		add	fp, sp, #4
 2245              		.cfi_def_cfa 11, 4
 504:main.c        ****     schrittmotor_data.current_reload = schrittmotor_data.reload_table[schrittmotor_data.speed];
 2246              		.loc 1 504 88
 2247 0008 D8309FE5 		ldr	r3, .L135
 2248 000c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2249              		.loc 1 504 70
 2250 0010 D0209FE5 		ldr	r2, .L135
 2251 0014 043083E2 		add	r3, r3, #4
 2252 0018 8330A0E1 		lsl	r3, r3, #1
 2253 001c 033082E0 		add	r3, r2, r3
 2254 0020 063083E2 		add	r3, r3, #6
 2255 0024 B030D3E1 		ldrh	r3, [r3]
 2256              		.loc 1 504 38
 2257 0028 B8209FE5 		ldr	r2, .L135
 2258 002c B831C2E1 		strh	r3, [r2, #24]	@ movhi
 505:main.c        **** 
 506:main.c        ****     if (schrittmotor_data.position_mode == POSITION_KONTINUIERLICH) {
 2259              		.loc 1 506 26
 2260 0030 B0309FE5 		ldr	r3, .L135
 2261 0034 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2262              		.loc 1 506 8
 2263 0038 010053E3 		cmp	r3, #1
 2264 003c 1F00001A 		bne	.L132
 507:main.c        ****         schrittmotor_data.counter++;
 2265              		.loc 1 507 26
 2266 0040 A0309FE5 		ldr	r3, .L135
 2267 0044 BA31D3E1 		ldrh	r3, [r3, #26]
 2268              		.loc 1 507 34
 2269 0048 013083E2 		add	r3, r3, #1
 2270 004c 0338A0E1 		lsl	r3, r3, #16
 2271 0050 2338A0E1 		lsr	r3, r3, #16
 2272 0054 8C209FE5 		ldr	r2, .L135
 2273 0058 BA31C2E1 		strh	r3, [r2, #26]	@ movhi
 508:main.c        ****         if (schrittmotor_data.counter >= schrittmotor_data.current_reload) {
 2274              		.loc 1 508 30
 2275 005c 84309FE5 		ldr	r3, .L135
 2276 0060 BA21D3E1 		ldrh	r2, [r3, #26]
 2277              		.loc 1 508 59
 2278 0064 7C309FE5 		ldr	r3, .L135
 2279 0068 B831D3E1 		ldrh	r3, [r3, #24]
 2280              		.loc 1 508 12
 2281 006c 030052E1 		cmp	r2, r3
 2282 0070 1800003A 		bcc	.L134
 509:main.c        ****             schrittmotor_data.counter = 0;
 2283              		.loc 1 509 39
 2284 0074 6C309FE5 		ldr	r3, .L135
 2285 0078 0020A0E3 		mov	r2, #0
 2286 007c BA21C3E1 		strh	r2, [r3, #26]	@ movhi
 510:main.c        ****             schrittmotor_data.pos += (int32_t)schrittmotor_data.dir;
 2287              		.loc 1 510 30
 2288 0080 60309FE5 		ldr	r3, .L135
 2289 0084 D330D3E1 		ldrsb	r3, [r3, #3]
 2290 0088 FF2003E2 		and	r2, r3, #255
 2291              		.loc 1 510 64
 2292 008c 54309FE5 		ldr	r3, .L135
 2293 0090 DC39D3E1 		ldrsb	r3, [r3, #156]
 2294 0094 FF3003E2 		and	r3, r3, #255
 2295              		.loc 1 510 35
 2296 0098 033082E0 		add	r3, r2, r3
 2297 009c FF3003E2 		and	r3, r3, #255
 2298 00a0 033CA0E1 		lsl	r3, r3, #24
 2299 00a4 432CA0E1 		asr	r2, r3, #24
 2300 00a8 38309FE5 		ldr	r3, .L135
 2301 00ac 0320C3E5 		strb	r2, [r3, #3]
 511:main.c        ****             schrittmotor_process();
 2302              		.loc 1 511 13
 2303 00b0 34309FE5 		ldr	r3, .L135+4
 2304 00b4 0FE0A0E1 		mov	lr, pc
 2305 00b8 13FF2FE1 		bx	r3
 2306              	.LVL17:
 512:main.c        ****         }
 513:main.c        ****     } else {
 514:main.c        ****         schrittmotor_process();
 515:main.c        ****         schrittmotor_data.counter = 0;
 516:main.c        ****     }
 517:main.c        **** }
 2307              		.loc 1 517 1
 2308 00bc 050000EA 		b	.L134
 2309              	.L132:
 514:main.c        ****         schrittmotor_data.counter = 0;
 2310              		.loc 1 514 9
 2311 00c0 24309FE5 		ldr	r3, .L135+4
 2312 00c4 0FE0A0E1 		mov	lr, pc
 2313 00c8 13FF2FE1 		bx	r3
 2314              	.LVL18:
 515:main.c        ****     }
 2315              		.loc 1 515 35
 2316 00cc 14309FE5 		ldr	r3, .L135
 2317 00d0 0020A0E3 		mov	r2, #0
 2318 00d4 BA21C3E1 		strh	r2, [r3, #26]	@ movhi
 2319              	.L134:
 2320              		.loc 1 517 1
 2321 00d8 0000A0E1 		nop
 2322 00dc 04D04BE2 		sub	sp, fp, #4
 2323              		.cfi_def_cfa 13, 8
 2324              		@ sp needed
 2325 00e0 0048BDE8 		pop	{fp, lr}
 2326              		.cfi_restore 14
 2327              		.cfi_restore 11
 2328              		.cfi_def_cfa_offset 0
 2329 00e4 1EFF2FE1 		bx	lr
 2330              	.L136:
 2331              		.align	2
 2332              	.L135:
 2333 00e8 00000000 		.word	schrittmotor_data
 2334 00ec 00000000 		.word	schrittmotor_process
 2335              		.cfi_endproc
 2336              	.LFE22:
 2338              		.section	.text.task_8ms,"ax",%progbits
 2339              		.align	2
 2340              		.global	task_8ms
 2341              		.syntax unified
 2342              		.arm
 2344              	task_8ms:
 2345              	.LFB23:
 518:main.c        **** 
 519:main.c        **** void task_8ms(void) {
 2346              		.loc 1 519 21
 2347              		.cfi_startproc
 2348              		@ Function supports interworking.
 2349              		@ args = 0, pretend = 0, frame = 0
 2350              		@ frame_needed = 1, uses_anonymous_args = 0
 2351              		@ link register save eliminated.
 2352 0000 04B02DE5 		str	fp, [sp, #-4]!
 2353              		.cfi_def_cfa_offset 4
 2354              		.cfi_offset 11, -4
 2355 0004 00B08DE2 		add	fp, sp, #0
 2356              		.cfi_def_cfa_register 11
 520:main.c        ****   // Keine blockierende Aufrufe
 521:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 522:main.c        **** }
 2357              		.loc 1 522 1
 2358 0008 0000A0E1 		nop
 2359 000c 00D08BE2 		add	sp, fp, #0
 2360              		.cfi_def_cfa_register 13
 2361              		@ sp needed
 2362 0010 04B09DE4 		ldr	fp, [sp], #4
 2363              		.cfi_restore 11
 2364              		.cfi_def_cfa_offset 0
 2365 0014 1EFF2FE1 		bx	lr
 2366              		.cfi_endproc
 2367              	.LFE23:
 2369              		.section	.text.task_16ms,"ax",%progbits
 2370              		.align	2
 2371              		.global	task_16ms
 2372              		.syntax unified
 2373              		.arm
 2375              	task_16ms:
 2376              	.LFB24:
 523:main.c        **** 
 524:main.c        **** void task_16ms(void) {
 2377              		.loc 1 524 22
 2378              		.cfi_startproc
 2379              		@ Function supports interworking.
 2380              		@ args = 0, pretend = 0, frame = 0
 2381              		@ frame_needed = 1, uses_anonymous_args = 0
 2382              		@ link register save eliminated.
 2383 0000 04B02DE5 		str	fp, [sp, #-4]!
 2384              		.cfi_def_cfa_offset 4
 2385              		.cfi_offset 11, -4
 2386 0004 00B08DE2 		add	fp, sp, #0
 2387              		.cfi_def_cfa_register 11
 525:main.c        ****   // Keine blockierende Aufrufe
 526:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 527:main.c        **** }
 2388              		.loc 1 527 1
 2389 0008 0000A0E1 		nop
 2390 000c 00D08BE2 		add	sp, fp, #0
 2391              		.cfi_def_cfa_register 13
 2392              		@ sp needed
 2393 0010 04B09DE4 		ldr	fp, [sp], #4
 2394              		.cfi_restore 11
 2395              		.cfi_def_cfa_offset 0
 2396 0014 1EFF2FE1 		bx	lr
 2397              		.cfi_endproc
 2398              	.LFE24:
 2400              		.section	.text.task_32ms,"ax",%progbits
 2401              		.align	2
 2402              		.global	task_32ms
 2403              		.syntax unified
 2404              		.arm
 2406              	task_32ms:
 2407              	.LFB25:
 528:main.c        **** 
 529:main.c        **** void task_32ms(void) {
 2408              		.loc 1 529 22
 2409              		.cfi_startproc
 2410              		@ Function supports interworking.
 2411              		@ args = 0, pretend = 0, frame = 0
 2412              		@ frame_needed = 1, uses_anonymous_args = 0
 2413              		@ link register save eliminated.
 2414 0000 04B02DE5 		str	fp, [sp, #-4]!
 2415              		.cfi_def_cfa_offset 4
 2416              		.cfi_offset 11, -4
 2417 0004 00B08DE2 		add	fp, sp, #0
 2418              		.cfi_def_cfa_register 11
 530:main.c        ****   // Keine blockierende Aufrufe
 531:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 532:main.c        **** }
 2419              		.loc 1 532 1
 2420 0008 0000A0E1 		nop
 2421 000c 00D08BE2 		add	sp, fp, #0
 2422              		.cfi_def_cfa_register 13
 2423              		@ sp needed
 2424 0010 04B09DE4 		ldr	fp, [sp], #4
 2425              		.cfi_restore 11
 2426              		.cfi_def_cfa_offset 0
 2427 0014 1EFF2FE1 		bx	lr
 2428              		.cfi_endproc
 2429              	.LFE25:
 2431              		.section	.text.task_64ms,"ax",%progbits
 2432              		.align	2
 2433              		.global	task_64ms
 2434              		.syntax unified
 2435              		.arm
 2437              	task_64ms:
 2438              	.LFB26:
 533:main.c        **** 
 534:main.c        **** void task_64ms(void) {
 2439              		.loc 1 534 22
 2440              		.cfi_startproc
 2441              		@ Function supports interworking.
 2442              		@ args = 0, pretend = 0, frame = 0
 2443              		@ frame_needed = 1, uses_anonymous_args = 0
 2444 0000 00482DE9 		push	{fp, lr}
 2445              		.cfi_def_cfa_offset 8
 2446              		.cfi_offset 11, -8
 2447              		.cfi_offset 14, -4
 2448 0004 04B08DE2 		add	fp, sp, #4
 2449              		.cfi_def_cfa 11, 4
 535:main.c        ****   // Keine blockierende Aufrufe
 536:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 537:main.c        ****   ui_process();
 2450              		.loc 1 537 3
 2451 0008 14309FE5 		ldr	r3, .L141
 2452 000c 0FE0A0E1 		mov	lr, pc
 2453 0010 13FF2FE1 		bx	r3
 2454              	.LVL19:
 538:main.c        **** }
 2455              		.loc 1 538 1
 2456 0014 0000A0E1 		nop
 2457 0018 04D04BE2 		sub	sp, fp, #4
 2458              		.cfi_def_cfa 13, 8
 2459              		@ sp needed
 2460 001c 0048BDE8 		pop	{fp, lr}
 2461              		.cfi_restore 14
 2462              		.cfi_restore 11
 2463              		.cfi_def_cfa_offset 0
 2464 0020 1EFF2FE1 		bx	lr
 2465              	.L142:
 2466              		.align	2
 2467              	.L141:
 2468 0024 00000000 		.word	ui_process
 2469              		.cfi_endproc
 2470              	.LFE26:
 2472              		.section	.text.task_128ms,"ax",%progbits
 2473              		.align	2
 2474              		.global	task_128ms
 2475              		.syntax unified
 2476              		.arm
 2478              	task_128ms:
 2479              	.LFB27:
 539:main.c        **** 
 540:main.c        **** void task_128ms(void) {
 2480              		.loc 1 540 23
 2481              		.cfi_startproc
 2482              		@ Function supports interworking.
 2483              		@ args = 0, pretend = 0, frame = 0
 2484              		@ frame_needed = 1, uses_anonymous_args = 0
 2485              		@ link register save eliminated.
 2486 0000 04B02DE5 		str	fp, [sp, #-4]!
 2487              		.cfi_def_cfa_offset 4
 2488              		.cfi_offset 11, -4
 2489 0004 00B08DE2 		add	fp, sp, #0
 2490              		.cfi_def_cfa_register 11
 541:main.c        ****   // Keine blockierende Aufrufe
 542:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 543:main.c        **** }
 2491              		.loc 1 543 1
 2492 0008 0000A0E1 		nop
 2493 000c 00D08BE2 		add	sp, fp, #0
 2494              		.cfi_def_cfa_register 13
 2495              		@ sp needed
 2496 0010 04B09DE4 		ldr	fp, [sp], #4
 2497              		.cfi_restore 11
 2498              		.cfi_def_cfa_offset 0
 2499 0014 1EFF2FE1 		bx	lr
 2500              		.cfi_endproc
 2501              	.LFE27:
 2503              		.section	.text.task_256ms,"ax",%progbits
 2504              		.align	2
 2505              		.global	task_256ms
 2506              		.syntax unified
 2507              		.arm
 2509              	task_256ms:
 2510              	.LFB28:
 544:main.c        **** 
 545:main.c        **** void task_256ms(void) {
 2511              		.loc 1 545 23
 2512              		.cfi_startproc
 2513              		@ Function supports interworking.
 2514              		@ args = 0, pretend = 0, frame = 0
 2515              		@ frame_needed = 1, uses_anonymous_args = 0
 2516              		@ link register save eliminated.
 2517 0000 04B02DE5 		str	fp, [sp, #-4]!
 2518              		.cfi_def_cfa_offset 4
 2519              		.cfi_offset 11, -4
 2520 0004 00B08DE2 		add	fp, sp, #0
 2521              		.cfi_def_cfa_register 11
 546:main.c        ****   // Keine blockierende Aufrufe
 547:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 548:main.c        **** }
 2522              		.loc 1 548 1
 2523 0008 0000A0E1 		nop
 2524 000c 00D08BE2 		add	sp, fp, #0
 2525              		.cfi_def_cfa_register 13
 2526              		@ sp needed
 2527 0010 04B09DE4 		ldr	fp, [sp], #4
 2528              		.cfi_restore 11
 2529              		.cfi_def_cfa_offset 0
 2530 0014 1EFF2FE1 		bx	lr
 2531              		.cfi_endproc
 2532              	.LFE28:
 2534              		.section	.text.task_512ms,"ax",%progbits
 2535              		.align	2
 2536              		.global	task_512ms
 2537              		.syntax unified
 2538              		.arm
 2540              	task_512ms:
 2541              	.LFB29:
 549:main.c        **** 
 550:main.c        **** void task_512ms(void) {
 2542              		.loc 1 550 23
 2543              		.cfi_startproc
 2544              		@ Function supports interworking.
 2545              		@ args = 0, pretend = 0, frame = 0
 2546              		@ frame_needed = 1, uses_anonymous_args = 0
 2547              		@ link register save eliminated.
 2548 0000 04B02DE5 		str	fp, [sp, #-4]!
 2549              		.cfi_def_cfa_offset 4
 2550              		.cfi_offset 11, -4
 2551 0004 00B08DE2 		add	fp, sp, #0
 2552              		.cfi_def_cfa_register 11
 551:main.c        ****   // Keine blockierende Aufrufe
 552:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 553:main.c        **** }
 2553              		.loc 1 553 1
 2554 0008 0000A0E1 		nop
 2555 000c 00D08BE2 		add	sp, fp, #0
 2556              		.cfi_def_cfa_register 13
 2557              		@ sp needed
 2558 0010 04B09DE4 		ldr	fp, [sp], #4
 2559              		.cfi_restore 11
 2560              		.cfi_def_cfa_offset 0
 2561 0014 1EFF2FE1 		bx	lr
 2562              		.cfi_endproc
 2563              	.LFE29:
 2565              		.section	.text.task_1024ms,"ax",%progbits
 2566              		.align	2
 2567              		.global	task_1024ms
 2568              		.syntax unified
 2569              		.arm
 2571              	task_1024ms:
 2572              	.LFB30:
 554:main.c        **** 
 555:main.c        **** void task_1024ms(void) {
 2573              		.loc 1 555 24
 2574              		.cfi_startproc
 2575              		@ Function supports interworking.
 2576              		@ args = 0, pretend = 0, frame = 0
 2577              		@ frame_needed = 1, uses_anonymous_args = 0
 2578              		@ link register save eliminated.
 2579 0000 04B02DE5 		str	fp, [sp, #-4]!
 2580              		.cfi_def_cfa_offset 4
 2581              		.cfi_offset 11, -4
 2582 0004 00B08DE2 		add	fp, sp, #0
 2583              		.cfi_def_cfa_register 11
 556:main.c        ****   // Keine blockierende Aufrufe
 557:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 558:main.c        **** }
 2584              		.loc 1 558 1
 2585 0008 0000A0E1 		nop
 2586 000c 00D08BE2 		add	sp, fp, #0
 2587              		.cfi_def_cfa_register 13
 2588              		@ sp needed
 2589 0010 04B09DE4 		ldr	fp, [sp], #4
 2590              		.cfi_restore 11
 2591              		.cfi_def_cfa_offset 0
 2592 0014 1EFF2FE1 		bx	lr
 2593              		.cfi_endproc
 2594              	.LFE30:
 2596              		.section	.text.task_idle,"ax",%progbits
 2597              		.align	2
 2598              		.global	task_idle
 2599              		.syntax unified
 2600              		.arm
 2602              	task_idle:
 2603              	.LFB31:
 559:main.c        **** 
 560:main.c        **** void task_idle(void) {
 2604              		.loc 1 560 22
 2605              		.cfi_startproc
 2606              		@ Function supports interworking.
 2607              		@ args = 0, pretend = 0, frame = 0
 2608              		@ frame_needed = 1, uses_anonymous_args = 0
 2609              		@ link register save eliminated.
 2610 0000 04B02DE5 		str	fp, [sp, #-4]!
 2611              		.cfi_def_cfa_offset 4
 2612              		.cfi_offset 11, -4
 2613 0004 00B08DE2 		add	fp, sp, #0
 2614              		.cfi_def_cfa_register 11
 561:main.c        ****   // Keine blockierende Aufrufe
 562:main.c        ****   // Max. Bearbeitungsdauer: IDLE_MS
 563:main.c        **** }
 2615              		.loc 1 563 1
 2616 0008 0000A0E1 		nop
 2617 000c 00D08BE2 		add	sp, fp, #0
 2618              		.cfi_def_cfa_register 13
 2619              		@ sp needed
 2620 0010 04B09DE4 		ldr	fp, [sp], #4
 2621              		.cfi_restore 11
 2622              		.cfi_def_cfa_offset 0
 2623 0014 1EFF2FE1 		bx	lr
 2624              		.cfi_endproc
 2625              	.LFE31:
 2627              		.section	.text.premain_init,"ax",%progbits
 2628              		.align	2
 2629              		.global	premain_init
 2630              		.syntax unified
 2631              		.arm
 2633              	premain_init:
 2634              	.LFB32:
 564:main.c        **** 
 565:main.c        **** /*****************************************************************************/
 566:main.c        **** /*    Pre-Main-Funktion                                                      */
 567:main.c        **** /*****************************************************************************/
 568:main.c        **** // Zur Vermeidung von malloc(1024) bei der ersten Ausgabe über stdout!
 569:main.c        **** //__attribute__(constructor) stellt sicher, dass premain_init() direkt nach
 570:main.c        **** //__sinit() aufgerufen wird (beides innerhalb von __libc_init_array())
 571:main.c        **** void __attribute__((constructor)) premain_init(void) {
 2635              		.loc 1 571 54
 2636              		.cfi_startproc
 2637              		@ Function supports interworking.
 2638              		@ args = 0, pretend = 0, frame = 0
 2639              		@ frame_needed = 1, uses_anonymous_args = 0
 2640 0000 30482DE9 		push	{r4, r5, fp, lr}
 2641              		.cfi_def_cfa_offset 16
 2642              		.cfi_offset 4, -16
 2643              		.cfi_offset 5, -12
 2644              		.cfi_offset 11, -8
 2645              		.cfi_offset 14, -4
 2646 0004 0CB08DE2 		add	fp, sp, #12
 2647              		.cfi_def_cfa 11, 4
 572:main.c        **** #if 0
 573:main.c        **** 	//No linebuffering, call stdio_write() immediately
 574:main.c        **** 	//-> Langsam, da mit jedem Zeichen __sflush_r()/_write()/stdio_write() aufgerufen wird 
 575:main.c        **** 	setvbuf(stdout,NULL,_IONBF,0);
 576:main.c        **** #else
 577:main.c        ****   static char linebuf[10];
 578:main.c        ****   // LineBuffering into global Varialbe (guter Kompromiss)
 579:main.c        ****   setvbuf(stdout, linebuf, _IOLBF, sizeof(linebuf)); // Linebuffering in
 2648              		.loc 1 579 11
 2649 0008 2C309FE5 		ldr	r3, .L149
 2650 000c 003093E5 		ldr	r3, [r3]
 2651 0010 080093E5 		ldr	r0, [r3, #8]
 2652              		.loc 1 579 3
 2653 0014 0A30A0E3 		mov	r3, #10
 2654 0018 0120A0E3 		mov	r2, #1
 2655 001c 1C109FE5 		ldr	r1, .L149+4
 2656 0020 1C409FE5 		ldr	r4, .L149+8
 2657 0024 0FE0A0E1 		mov	lr, pc
 2658 0028 14FF2FE1 		bx	r4
 2659              	.LVL20:
 580:main.c        **** #endif
 581:main.c        **** }
 2660              		.loc 1 581 1
 2661 002c 0000A0E1 		nop
 2662 0030 0CD04BE2 		sub	sp, fp, #12
 2663              		.cfi_def_cfa 13, 16
 2664              		@ sp needed
 2665 0034 3048BDE8 		pop	{r4, r5, fp, lr}
 2666              		.cfi_restore 14
 2667              		.cfi_restore 11
 2668              		.cfi_restore 5
 2669              		.cfi_restore 4
 2670              		.cfi_def_cfa_offset 0
 2671 0038 1EFF2FE1 		bx	lr
 2672              	.L150:
 2673              		.align	2
 2674              	.L149:
 2675 003c 00000000 		.word	_impure_ptr
 2676 0040 2C030000 		.word	linebuf.1
 2677 0044 00000000 		.word	setvbuf
 2678              		.cfi_endproc
 2679              	.LFE32:
 2681              		.section	.init_array,"aw",%init_array
 2682              		.align	2
 2683 0000 00000000 		.word	premain_init(target1)
 2684              		.section	.rodata
 2685              		.align	2
 2686              	.LC9:
 2687 009c 68616C6C 		.ascii	"hallo\012\015\000"
 2687      6F0A0D00 
 2688              		.align	2
 2689              	.LC10:
 2690 00a4 1B5B324A 		.ascii	"\033[2J\033[H\033[0m\000"
 2690      1B5B481B 
 2690      5B306D00 
 2691              		.align	2
 2692              	.LC11:
 2693 00b0 50726F67 		.ascii	"Prog: demo\012\015Version von: Oct 30 2025 18:05:22"
 2693      3A206465 
 2693      6D6F0A0D 
 2693      56657273 
 2693      696F6E20 
 2694 00dd 0A0D00   		.ascii	"\012\015\000"
 2695              		.align	2
 2696              	.LC12:
 2697 00e0 27762E76 		.ascii	"'v.view %e schrittmotor_data' zur Variablendarstell"
 2697      69657720 
 2697      25652073 
 2697      63687269 
 2697      74746D6F 
 2698 0113 756E670A 		.ascii	"ung\012\015\000"
 2698      0D00
 2699 0119 000000   		.align	2
 2700              	.LC13:
 2701 011c 5669656C 		.ascii	"Viel Erfolg!\012\015\000"
 2701      20457266 
 2701      6F6C6721 
 2701      0A0D00
 2702 012b 00       		.align	2
 2703              	.LC14:
 2704 012c 00       		.ascii	"\000"
 2705 012d 000000   		.align	2
 2706              	.LC15:
 2707 0130 346D7300 		.ascii	"4ms\000"
 2708              		.align	2
 2709              	.LC16:
 2710 0134 386D7300 		.ascii	"8ms\000"
 2711              		.align	2
 2712              	.LC17:
 2713 0138 31366D73 		.ascii	"16ms\000"
 2713      00
 2714 013d 000000   		.align	2
 2715              	.LC18:
 2716 0140 33326D73 		.ascii	"32ms\000"
 2716      00
 2717 0145 000000   		.align	2
 2718              	.LC19:
 2719 0148 36346D73 		.ascii	"64ms\000"
 2719      00
 2720 014d 000000   		.align	2
 2721              	.LC20:
 2722 0150 3132386D 		.ascii	"128ms\000"
 2722      7300
 2723 0156 0000     		.align	2
 2724              	.LC21:
 2725 0158 3235366D 		.ascii	"256ms\000"
 2725      7300
 2726 015e 0000     		.align	2
 2727              	.LC22:
 2728 0160 3531326D 		.ascii	"512ms\000"
 2728      7300
 2729 0166 0000     		.align	2
 2730              	.LC23:
 2731 0168 49646C65 		.ascii	"Idle\000"
 2731      00
 2732 016d 000000   		.align	2
 2733              	.LC24:
 2734 0170 1B5B3331 		.ascii	"\033[31mTiming durch '\000"
 2734      6D54696D 
 2734      696E6720 
 2734      64757263 
 2734      68202700 
 2735              		.align	2
 2736              	.LC25:
 2737 0184 27207665 		.ascii	"' verletzt\012\015\033[39m\000"
 2737      726C6574 
 2737      7A740A0D 
 2737      1B5B3339 
 2737      6D00
 2738 0196 0000     		.align	2
 2739              	.LC26:
 2740 0198 1B5B3331 		.ascii	"\033[31mStack overflow durch '\000"
 2740      6D537461 
 2740      636B206F 
 2740      76657266 
 2740      6C6F7720 
 2741              		.align	2
 2742              	.LC27:
 2743 01b4 270A0D1B 		.ascii	"'\012\015\033[39m\000"
 2743      5B33396D 
 2743      00
 2744 01bd 000000   		.align	2
 2745              	.LC28:
 2746 01c0 1B5B3331 		.ascii	"\033[31m\012\015Low Battery\012\015\033[39m\000"
 2746      6D0A0D4C 
 2746      6F772042 
 2746      61747465 
 2746      72790A0D 
 2747 01da 0000     		.align	2
 2748              	.LC29:
 2749 01dc 1B5B3331 		.ascii	"\033[31m\012\015Terminal Overflow\012\015\033[39m\000"
 2749      6D0A0D54 
 2749      65726D69 
 2749      6E616C20 
 2749      4F766572 
 2750              		.section	.text.main,"ax",%progbits
 2751              		.align	2
 2752              		.global	main
 2753              		.syntax unified
 2754              		.arm
 2756              	main:
 2757              	.LFB33:
 582:main.c        **** /*****************************************************************************/
 583:main.c        **** /*    Main-Funktion                                                          */
 584:main.c        **** /*****************************************************************************/
 585:main.c        **** #if 0
 586:main.c        **** //Variante 1: Deklaration der main() Funktion
 587:main.c        **** //da es keine CLI gibt, über welcher die Anwendung getartet wird
 588:main.c        **** //sondern der start über startup.s erfolgt, macht dies kein Sinn
 589:main.c        **** //und belegt unnötige Speicherplatz auf den Stack
 590:main.c        **** int main(int argc, char *argv[]) 
 591:main.c        **** {
 592:main.c        **** 	(void) argc;
 593:main.c        **** 	(void) argv;
 594:main.c        **** #else
 595:main.c        **** // Variante 2: Deklaration der main() funktion
 596:main.c        **** int main(void) {
 2758              		.loc 1 596 16
 2759              		.cfi_startproc
 2760              		@ Function supports interworking.
 2761              		@ args = 0, pretend = 0, frame = 24
 2762              		@ frame_needed = 1, uses_anonymous_args = 0
 2763 0000 00482DE9 		push	{fp, lr}
 2764              		.cfi_def_cfa_offset 8
 2765              		.cfi_offset 11, -8
 2766              		.cfi_offset 14, -4
 2767 0004 04B08DE2 		add	fp, sp, #4
 2768              		.cfi_def_cfa 11, 4
 2769 0008 18D04DE2 		sub	sp, sp, #24
 597:main.c        **** #endif
 598:main.c        ****   /* Interrupts zu diesem Zeitpunkt disabled !!!! */
 599:main.c        **** 
 600:main.c        ****   /* 'Pflicht' Initialisierung, können nicht ausgelassen werden */
 601:main.c        ****   aic_init();          // Interrupt-Controller initialisieren
 2770              		.loc 1 601 3
 2771 000c E4359FE5 		ldr	r3, .L180
 2772 0010 0FE0A0E1 		mov	lr, pc
 2773 0014 13FF2FE1 		bx	r3
 2774              	.LVL21:
 602:main.c        ****   systick_init();      // System-Timer initialisieren
 2775              		.loc 1 602 3
 2776 0018 DC359FE5 		ldr	r3, .L180+4
 2777 001c 0FE0A0E1 		mov	lr, pc
 2778 0020 13FF2FE1 		bx	r3
 2779              	.LVL22:
 603:main.c        ****   interrupts_enable(); // Ohne Worte
 2780              		.loc 1 603 3
 2781 0024 D4359FE5 		ldr	r3, .L180+8
 2782 0028 0FE0A0E1 		mov	lr, pc
 2783 002c 13FF2FE1 		bx	r3
 2784              	.LVL23:
 604:main.c        ****   nxt_avr_init(8);
 2785              		.loc 1 604 3
 2786 0030 0800A0E3 		mov	r0, #8
 2787 0034 C8359FE5 		ldr	r3, .L180+12
 2788 0038 0FE0A0E1 		mov	lr, pc
 2789 003c 13FF2FE1 		bx	r3
 2790              	.LVL24:
 605:main.c        **** #if defined(MODE_RAM) || defined(MODE_SIM)
 606:main.c        ****   udmon3_init(); // Speicherzugriff durch den Debugger
 2791              		.loc 1 606 3
 2792 0040 C0359FE5 		ldr	r3, .L180+16
 2793 0044 0FE0A0E1 		mov	lr, pc
 2794 0048 13FF2FE1 		bx	r3
 2795              	.LVL25:
 607:main.c        ****                  // zur Programmlaufzeit mittels der
 608:main.c        ****                  // DCC Schnittstelle ermöglichen
 609:main.c        **** #endif
 610:main.c        **** 
 611:main.c        ****   /* 'Wahl' Initialisierung, hängt von den benötigten Komponenten ab */
 612:main.c        ****   term_init();
 2796              		.loc 1 612 3
 2797 004c B8359FE5 		ldr	r3, .L180+20
 2798 0050 0FE0A0E1 		mov	lr, pc
 2799 0054 13FF2FE1 		bx	r3
 2800              	.LVL26:
 613:main.c        ****   display_init();
 2801              		.loc 1 613 3
 2802 0058 B0359FE5 		ldr	r3, .L180+24
 2803 005c 0FE0A0E1 		mov	lr, pc
 2804 0060 13FF2FE1 		bx	r3
 2805              	.LVL27:
 614:main.c        **** 
 615:main.c        ****   ui_init();
 2806              		.loc 1 615 3
 2807 0064 A8359FE5 		ldr	r3, .L180+28
 2808 0068 0FE0A0E1 		mov	lr, pc
 2809 006c 13FF2FE1 		bx	r3
 2810              	.LVL28:
 616:main.c        ****   schrittmotor_init(schrittmotor_data.schritt_mode);
 2811              		.loc 1 616 3
 2812 0070 A0359FE5 		ldr	r3, .L180+32
 2813 0074 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2814 0078 0300A0E1 		mov	r0, r3
 2815 007c 98359FE5 		ldr	r3, .L180+36
 2816 0080 0FE0A0E1 		mov	lr, pc
 2817 0084 13FF2FE1 		bx	r3
 2818              	.LVL29:
 617:main.c        **** 
 618:main.c        ****   display_clear(0);
 2819              		.loc 1 618 3
 2820 0088 0000A0E3 		mov	r0, #0
 2821 008c 8C359FE5 		ldr	r3, .L180+40
 2822 0090 0FE0A0E1 		mov	lr, pc
 2823 0094 13FF2FE1 		bx	r3
 2824              	.LVL30:
 619:main.c        ****   display_update();
 2825              		.loc 1 619 3
 2826 0098 84359FE5 		ldr	r3, .L180+44
 2827 009c 0FE0A0E1 		mov	lr, pc
 2828 00a0 13FF2FE1 		bx	r3
 2829              	.LVL31:
 620:main.c        **** 
 621:main.c        ****   // ANSI Escape sequences - VT100 / VT52 (see main.h)
 622:main.c        ****   (void)term_string("hallo\n\r", ASYNCSYNC_BLOCK);
 2830              		.loc 1 622 9
 2831 00a4 0110A0E3 		mov	r1, #1
 2832 00a8 78059FE5 		ldr	r0, .L180+48
 2833 00ac 78359FE5 		ldr	r3, .L180+52
 2834 00b0 0FE0A0E1 		mov	lr, pc
 2835 00b4 13FF2FE1 		bx	r3
 2836              	.LVL32:
 623:main.c        ****   (void)term_string(
 2837              		.loc 1 623 9
 2838 00b8 0110A0E3 		mov	r1, #1
 2839 00bc 6C059FE5 		ldr	r0, .L180+56
 2840 00c0 64359FE5 		ldr	r3, .L180+52
 2841 00c4 0FE0A0E1 		mov	lr, pc
 2842 00c8 13FF2FE1 		bx	r3
 2843              	.LVL33:
 624:main.c        ****       "\033[2J" VT100_CURSORHOME // Move Cursor to home position (0,0)
 625:main.c        ****           VT100_DEFAULT,
 626:main.c        ****       ASYNCSYNC_BLOCK);
 627:main.c        ****   (void)term_string("Prog: " APP_NAME "\n\rVersion von: " __DATE__ " " __TIME__
 2844              		.loc 1 627 9
 2845 00cc 0110A0E3 		mov	r1, #1
 2846 00d0 5C059FE5 		ldr	r0, .L180+60
 2847 00d4 50359FE5 		ldr	r3, .L180+52
 2848 00d8 0FE0A0E1 		mov	lr, pc
 2849 00dc 13FF2FE1 		bx	r3
 2850              	.LVL34:
 628:main.c        ****                     "\n\r",
 629:main.c        ****                     ASYNCSYNC_BLOCK);
 630:main.c        ****   (void)term_string(
 2851              		.loc 1 630 9
 2852 00e0 0110A0E3 		mov	r1, #1
 2853 00e4 4C059FE5 		ldr	r0, .L180+64
 2854 00e8 3C359FE5 		ldr	r3, .L180+52
 2855 00ec 0FE0A0E1 		mov	lr, pc
 2856 00f0 13FF2FE1 		bx	r3
 2857              	.LVL35:
 631:main.c        ****       "'v.view %e schrittmotor_data' zur Variablendarstellung\n\r",
 632:main.c        ****       ASYNCSYNC_BLOCK);
 633:main.c        ****   (void)term_string("Viel Erfolg!\n\r", ASYNCSYNC_BLOCK);
 2858              		.loc 1 633 9
 2859 00f4 0110A0E3 		mov	r1, #1
 2860 00f8 3C059FE5 		ldr	r0, .L180+68
 2861 00fc 28359FE5 		ldr	r3, .L180+52
 2862 0100 0FE0A0E1 		mov	lr, pc
 2863 0104 13FF2FE1 		bx	r3
 2864              	.LVL36:
 634:main.c        **** 
 635:main.c        ****   // Alternativ zu term_xxx() kann auch printf() oder noch besser iprintf
 636:main.c        ****   // genutzt werden beide bedingen jedoch einen großen Speicherbedarf!
 637:main.c        ****   // Alternativ zu term_read() kann auch scanf() genutzt werden. Auch diese
 638:main.c        ****   // Funktion
 639:main.c        ****   //  bedingt einen großen Speicherbedarf
 640:main.c        **** 
 641:main.c        **** #ifndef MODE_ROM
 642:main.c        ****   /* Watchdog Disable */
 643:main.c        ****   /* Mode-Register kann nur einmal beschrieben werden */
 644:main.c        ****   AT91C_BASE_WDTC->WDTC_WDMR = 0xFFF | AT91C_WDTC_WDDIS | /*WD Disable */
 2865              		.loc 1 644 18
 2866 0108 30359FE5 		ldr	r3, .L180+72
 2867              		.loc 1 644 30
 2868 010c 30259FE5 		ldr	r2, .L180+76
 2869 0110 042083E5 		str	r2, [r3, #4]
 2870              	.LBB8:
 2871              	.LBB9:
 2872              		.file 4 "lib/../main.h"
   1:lib/../main.h **** #ifndef main_h
   2:lib/../main.h **** #define main_h
   3:lib/../main.h **** #include <stdint.h>
   4:lib/../main.h **** 
   5:lib/../main.h **** //ASCII-Zeichen
   6:lib/../main.h **** //\a The “alert” character, Ctrl-g, ASCII code 7 (BEL). (This usually makes some sort of audibl
   7:lib/../main.h **** //\b Backspace, Ctrl-h, ASCII code 8 (BS).
   8:lib/../main.h **** //\f Formfeed, Ctrl-l, ASCII code 12 (FF).
   9:lib/../main.h **** //\n Newline, Ctrl-j, ASCII code 10 (LF).
  10:lib/../main.h **** //\r Carriage return, Ctrl-m, ASCII code 13 (CR).
  11:lib/../main.h **** //\t Horizontal TAB, Ctrl-i, ASCII code 9 (HT).
  12:lib/../main.h **** //\v Vertical tab, Ctrl-k, ASCII code 11 (VT).
  13:lib/../main.h **** //\nnn The octal value nnn, where nnn stands for 1 to 3 digits between ‘0’ and ‘7’. For exa
  14:lib/../main.h **** //\xhh...The hexadecimal value hh, where hh stands for a sequence of hexadecimal digits (‘0’–
  15:lib/../main.h **** //       Like the same construct in ISO C, the escape sequence continues until 
  16:lib/../main.h **** //       the first nonhexadecimal digit is seen. (c.e.) However, using more 
  17:lib/../main.h **** //       than two hexadecimal digits produces undefined results. 
  18:lib/../main.h **** //       (The ‘\x’ escape sequence is not allowed in POSIX awk.)
  19:lib/../main.h **** //\/ A literal slash (necessary for regexp constants only). This sequence 
  20:lib/../main.h **** //       is used when you want to write a regexp constant that contains a 
  21:lib/../main.h **** //       slash. Because the regexp is delimited by slashes, you need to 
  22:lib/../main.h **** //       escape the slash that is part of the pattern, in order to tell 
  23:lib/../main.h **** //       awk to keep processing the rest of the regexp.
  24:lib/../main.h **** //\"  A literal double quote (necessary for string constants only). 
  25:lib/../main.h **** //       This sequence is used when you want to write a string constant 
  26:lib/../main.h **** //       that contains a double quote. Because the string is delimited by 
  27:lib/../main.h **** //       double quotes, you need to escape the quote that is part of 
  28:lib/../main.h **** //       the string, in order to tell awk to keep processing the rest
  29:lib/../main.h **** //       of the string.#define ANSI_BLACK   30
  30:lib/../main.h **** 
  31:lib/../main.h **** //https://www-user.tu-chemnitz.de/~heha/hsn/terminal/terminal.htm
  32:lib/../main.h **** //https://gist.github.com/ConnerWill/d4b6c776b509add763e17f9f113fd25b
  33:lib/../main.h **** //Cursor Control
  34:lib/../main.h **** #define VT100_CURSORHOME      "\e[H"
  35:lib/../main.h **** #define VT100_CLEARSCREEN     "\e[2J"
  36:lib/../main.h **** #define VT100_GOTOYX          "\e[%d;%dH"
  37:lib/../main.h **** #define VT100_SAVEPOS         "\e7"
  38:lib/../main.h **** #define VT100_RESTOREPOS      "\e8"
  39:lib/../main.h **** #define VT100_ROLLY1Y2        "\e[%d;%dr"
  40:lib/../main.h **** #define VT100_ROLLOFF         "\e[r"
  41:lib/../main.h **** //Erase Functions
  42:lib/../main.h **** #define VT100_ERASEFROMCURSOR "\e[0J"
  43:lib/../main.h **** #define VT100_ERASETOCURSOR   "\e[1J"
  44:lib/../main.h **** #define VT100_ERASESCREEN     "\e[2J"
  45:lib/../main.h **** #define VT100_DEL_UNTILEOL    "\e[K"
  46:lib/../main.h **** #define VT100_DEL_TOCUR       "\e[1K"
  47:lib/../main.h **** #define VT100_DEL_LINE        "\e[2K"
  48:lib/../main.h **** //Color/Graphics Mode
  49:lib/../main.h **** #define VT100_DEFAULT         "\e[0m"  //stellt hellgraue Schrift auf schwarzem Grund ein
  50:lib/../main.h **** #define VT100_FETT              "\e[1m"
  51:lib/../main.h **** #define VT100_FETT_AUS          "\e[22m"
  52:lib/../main.h **** #define VT100_UNTERSTRICHEN     "\e[4m"
  53:lib/../main.h **** #define VT100_UNTERSTRICHEN_AUS "\e[24m"
  54:lib/../main.h **** #define VT100_BLINKEN           "\e[5m"
  55:lib/../main.h **** #define VT100_BLINKEN_AUS       "\e[25m"
  56:lib/../main.h **** #define VT100_INVERS            "\e[7m"
  57:lib/../main.h **** #define VT100_INVERS_AUS        "\e[27m"
  58:lib/../main.h **** #define VT100_UNSICHTBAR        "\e[8m"
  59:lib/../main.h **** #define VT100_SICHTBAR          "\e[28m"
  60:lib/../main.h **** #define VT100_VORDERGRUND_SCHWARZ "\e[30m"
  61:lib/../main.h **** #define VT100_VORDERGRUND_ROT     "\e[31m"
  62:lib/../main.h **** #define VT100_VORDERGRUND_GRUEN   "\e[32m"
  63:lib/../main.h **** #define VT100_VORDERGRUND_BRAUN   "\e[33m"
  64:lib/../main.h **** #define VT100_VORDERGRUND_BLAU    "\e[34m"
  65:lib/../main.h **** #define VT100_VORDERGRUND_BLAUROT "\e[35m"
  66:lib/../main.h **** #define VT100_VORDERGRUND_ZYAN    "\e[36m"
  67:lib/../main.h **** #define VT100_VORDERGRUND_WEISS   "\e[37m"  //Default
  68:lib/../main.h **** #define VT100_VORDERGRUND_DEFAULT "\e[39m"  //Nicht VT100
  69:lib/../main.h **** #define VT100_HINTERGRUND_SCHWARZ "\e[40m"  //Default
  70:lib/../main.h **** #define VT100_HINTERGRUND_ROT     "\e[41m"  
  71:lib/../main.h **** #define VT100_HINTERGRUND_GRUEN   "\e[42m"  
  72:lib/../main.h **** #define VT100_HINTERGRUND_BRAUN   "\e[43m"  
  73:lib/../main.h **** #define VT100_HINTERGRUND_BLAU    "\e[44m"  
  74:lib/../main.h **** #define VT100_HINTERGRUND_BLAUROT "\e[45m"  
  75:lib/../main.h **** #define VT100_HINTERGRUND_ZYAN    "\e[46m"  
  76:lib/../main.h **** #define VT100_HINTERGRUND_WEISS   "\e[47m"  
  77:lib/../main.h **** #define VT100_HINTERGRUND_DEFAULT "\e[49m"
  78:lib/../main.h **** 
  79:lib/../main.h ****                                                          /* Main Clock [Hz] */
  80:lib/../main.h **** #define MAINCK            18432000
  81:lib/../main.h ****                                      /* Maseter Clock (PLLRC div by 2) [Hz] */
  82:lib/../main.h **** #define MCK               47923200
  83:lib/../main.h ****                                              /* System clock tick rate [Hz] */
  84:lib/../main.h **** #define BSP_TICKS_PER_SEC 1000
  85:lib/../main.h **** 
  86:lib/../main.h **** //#define NODISCARD __attribute__((warn_unused_result))  
  87:lib/../main.h **** #define NODISCARD  [[nodiscard]]
  88:lib/../main.h **** 
  89:lib/../main.h **** typedef enum __attribute__((packed)) {ASYNCSYNC_NONBLOCK,ASYNCSYNC_BLOCK,ASYNCSYNC_ASYNCGET} asyncs
  90:lib/../main.h **** 
  91:lib/../main.h **** typedef enum {SENSOR_1,SENSOR_2,SENSOR_3,SENSOR_4,SENSOR_MAX} sensor_t;
  92:lib/../main.h **** 
  93:lib/../main.h **** typedef enum {MOTOR_A,MOTOR_B,MOTOR_C} motor_t;
  94:lib/../main.h **** 
  95:lib/../main.h **** typedef enum {MOTOR_BREAK, MOTOR_FLOAT} motor_zustand_t;
  96:lib/../main.h **** 
  97:lib/../main.h **** typedef enum {SENSOR_OFF=0x00, SENSOR_9V_PULSED=0x01, SENSOR_9V=0x10 } sensor_power_t;
  98:lib/../main.h **** 
  99:lib/../main.h **** typedef enum {BATTERY_AA, BATTERY_ACCU} battery_t;
 100:lib/../main.h **** 
 101:lib/../main.h **** typedef struct {
 102:lib/../main.h **** 	uint8_t orange : 1;
 103:lib/../main.h **** 	uint8_t left : 1;
 104:lib/../main.h **** 	uint8_t right : 1;
 105:lib/../main.h **** 	uint8_t grey : 1;
 106:lib/../main.h **** 	uint8_t reserved : 4;
 107:lib/../main.h **** } button_t;
 108:lib/../main.h **** 
 109:lib/../main.h **** #define I2C_BAUDRATE 10000  //Orignal 9600
 110:lib/../main.h **** 
 111:lib/../main.h **** extern uint32_t __stack_start__[];   //Definiert in link.ld
 112:lib/../main.h **** extern uint32_t __stack_end__;       //Definiert in link.ld
 113:lib/../main.h **** #define STACK_FILL 0x11111111
 114:lib/../main.h **** 
 115:lib/../main.h **** static __inline__ void stack_fill(void) __attribute__((always_inline));
 116:lib/../main.h **** static __inline__ void stack_fill(void)
 117:lib/../main.h **** {
 118:lib/../main.h **** 	         uint32_t *ptr;
 119:lib/../main.h **** 	register uint32_t *sp asm("r13");
 120:lib/../main.h **** 	for(ptr=&__stack_start__[0];ptr<sp;ptr++)
 2873              		.loc 4 120 9
 2874 0114 2C359FE5 		ldr	r3, .L180+80
 2875 0118 14300BE5 		str	r3, [fp, #-20]
 2876              		.loc 4 120 2
 2877 011c 050000EA 		b	.L152
 2878              	.L153:
 121:lib/../main.h **** 		*ptr=STACK_FILL;
 2879              		.loc 4 121 7
 2880 0120 14301BE5 		ldr	r3, [fp, #-20]
 2881 0124 20259FE5 		ldr	r2, .L180+84
 2882 0128 002083E5 		str	r2, [r3]
 120:lib/../main.h **** 		*ptr=STACK_FILL;
 2883              		.loc 4 120 40 discriminator 3
 2884 012c 14301BE5 		ldr	r3, [fp, #-20]
 2885 0130 043083E2 		add	r3, r3, #4
 2886 0134 14300BE5 		str	r3, [fp, #-20]
 2887              	.L152:
 120:lib/../main.h **** 		*ptr=STACK_FILL;
 2888              		.loc 4 120 33 discriminator 1
 2889 0138 0D20A0E1 		mov	r2, sp
 2890 013c 14301BE5 		ldr	r3, [fp, #-20]
 2891 0140 020053E1 		cmp	r3, r2
 2892 0144 F5FFFF3A 		bcc	.L153
 122:lib/../main.h **** }
 2893              		.loc 4 122 1
 2894 0148 0000A0E1 		nop
 2895              	.L154:
 2896              	.LBE9:
 2897              	.LBE8:
 645:main.c        ****                                AT91C_WDTC_WDDBGHLT |      /*Debug Halt */
 646:main.c        ****                                AT91C_WDTC_WDIDLEHLT;      /*Idle Halt  */
 647:main.c        **** #else
 648:main.c        **** #if 0
 649:main.c        **** 	/* Watchdog Enable */
 650:main.c        **** 	/* Da in dieser Version kein zyklischer Reset des Watchdogs */
 651:main.c        **** 	/* vorhanden ist, wird von einem Watchdog Enable abgesehen  */
 652:main.c        **** 	/* Mit Reset wird der Wachdog aktiviert!                    */
 653:main.c        **** #else
 654:main.c        **** /* Watchdog Disable */
 655:main.c        **** /* Mode-Register kann nur einmal beschrieben werden */
 656:main.c        **** AT91C_BASE_WDTC->WDTC_WDMR = 0xFFF | AT91C_WDTC_WDDIS | /*WD Disable */
 657:main.c        ****                              AT91C_WDTC_WDDBGHLT |      /*Debug Halt */
 658:main.c        ****                              AT91C_WDTC_WDIDLEHLT;      /*Idle Halt  */
 659:main.c        **** #endif
 660:main.c        **** #endif
 661:main.c        ****   // Vorangegangenen Stackaufbau 'löschen'
 662:main.c        ****   stack_fill();
 663:main.c        ****   // Label, so das mit 'go start' hierin gesprungen werden kann
 664:main.c        **** start:
 665:main.c        ****   __attribute__((unused));
 666:main.c        ****   uint32_t start_tick = systick_get_ms();
 2898              		.loc 1 666 25
 2899 014c FC349FE5 		ldr	r3, .L180+88
 2900 0150 0FE0A0E1 		mov	lr, pc
 2901 0154 13FF2FE1 		bx	r3
 2902              	.LVL37:
 2903 0158 08000BE5 		str	r0, [fp, #-8]
 667:main.c        ****   uint32_t zeitscheibe = 0;
 2904              		.loc 1 667 12
 2905 015c 0030A0E3 		mov	r3, #0
 2906 0160 0C300BE5 		str	r3, [fp, #-12]
 668:main.c        ****   char *task_aktiv = "";
 2907              		.loc 1 668 9
 2908 0164 E8349FE5 		ldr	r3, .L180+92
 2909 0168 10300BE5 		str	r3, [fp, #-16]
 2910              	.L179:
 669:main.c        ****   while (1) {
 670:main.c        ****     // Warten bis zum nächsten TimeSlot
 671:main.c        ****     while ((int)(start_tick - systick_get_ms()) > 0)
 2911              		.loc 1 671 11
 2912 016c 0000A0E1 		nop
 2913              	.L155:
 2914              		.loc 1 671 31 discriminator 1
 2915 0170 D8349FE5 		ldr	r3, .L180+88
 2916 0174 0FE0A0E1 		mov	lr, pc
 2917 0178 13FF2FE1 		bx	r3
 2918              	.LVL38:
 2919 017c 0020A0E1 		mov	r2, r0
 2920              		.loc 1 671 29 discriminator 1
 2921 0180 08301BE5 		ldr	r3, [fp, #-8]
 2922 0184 023043E0 		sub	r3, r3, r2
 2923              		.loc 1 671 49 discriminator 1
 2924 0188 000053E3 		cmp	r3, #0
 2925 018c F7FFFFCA 		bgt	.L155
 672:main.c        ****       ;
 673:main.c        ****     start_tick += ZYKLUS_MS;
 2926              		.loc 1 673 16
 2927 0190 08301BE5 		ldr	r3, [fp, #-8]
 2928 0194 023083E2 		add	r3, r3, #2
 2929 0198 08300BE5 		str	r3, [fp, #-8]
 2930              	.L156:
 674:main.c        ****     // Label, so das mit 'go zyklus' hierhin gesprungen werden kann
 675:main.c        ****   zyklus:
 676:main.c        ****     __attribute__((unused)) if ((zeitscheibe & 0b000000001) == 0b000000001) {
 2931              		.loc 1 676 46
 2932 019c 0C301BE5 		ldr	r3, [fp, #-12]
 2933 01a0 013003E2 		and	r3, r3, #1
 2934              		.loc 1 676 32
 2935 01a4 000053E3 		cmp	r3, #0
 2936 01a8 0500000A 		beq	.L157
 677:main.c        ****       task_aktiv = "4ms";
 2937              		.loc 1 677 18
 2938 01ac A4349FE5 		ldr	r3, .L180+96
 2939 01b0 10300BE5 		str	r3, [fp, #-16]
 678:main.c        ****       task_4ms();
 2940              		.loc 1 678 7
 2941 01b4 A0349FE5 		ldr	r3, .L180+100
 2942 01b8 0FE0A0E1 		mov	lr, pc
 2943 01bc 13FF2FE1 		bx	r3
 2944              	.LVL39:
 2945 01c0 440000EA 		b	.L158
 2946              	.L157:
 679:main.c        ****     }
 680:main.c        ****     else if ((zeitscheibe & 0b000000011) == 0b000000010) {
 2947              		.loc 1 680 27
 2948 01c4 0C301BE5 		ldr	r3, [fp, #-12]
 2949 01c8 033003E2 		and	r3, r3, #3
 2950              		.loc 1 680 13
 2951 01cc 020053E3 		cmp	r3, #2
 2952 01d0 0500001A 		bne	.L159
 681:main.c        ****       task_aktiv = "8ms";
 2953              		.loc 1 681 18
 2954 01d4 84349FE5 		ldr	r3, .L180+104
 2955 01d8 10300BE5 		str	r3, [fp, #-16]
 682:main.c        ****       task_8ms();
 2956              		.loc 1 682 7
 2957 01dc 80349FE5 		ldr	r3, .L180+108
 2958 01e0 0FE0A0E1 		mov	lr, pc
 2959 01e4 13FF2FE1 		bx	r3
 2960              	.LVL40:
 2961 01e8 3A0000EA 		b	.L158
 2962              	.L159:
 683:main.c        ****     }
 684:main.c        ****     else if ((zeitscheibe & 0b000000111) == 0b000000100) {
 2963              		.loc 1 684 27
 2964 01ec 0C301BE5 		ldr	r3, [fp, #-12]
 2965 01f0 073003E2 		and	r3, r3, #7
 2966              		.loc 1 684 13
 2967 01f4 040053E3 		cmp	r3, #4
 2968 01f8 0500001A 		bne	.L160
 685:main.c        ****       task_aktiv = "16ms";
 2969              		.loc 1 685 18
 2970 01fc 64349FE5 		ldr	r3, .L180+112
 2971 0200 10300BE5 		str	r3, [fp, #-16]
 686:main.c        ****       task_16ms();
 2972              		.loc 1 686 7
 2973 0204 60349FE5 		ldr	r3, .L180+116
 2974 0208 0FE0A0E1 		mov	lr, pc
 2975 020c 13FF2FE1 		bx	r3
 2976              	.LVL41:
 2977 0210 300000EA 		b	.L158
 2978              	.L160:
 687:main.c        ****     }
 688:main.c        ****     else if ((zeitscheibe & 0b000001111) == 0b000001000) {
 2979              		.loc 1 688 27
 2980 0214 0C301BE5 		ldr	r3, [fp, #-12]
 2981 0218 0F3003E2 		and	r3, r3, #15
 2982              		.loc 1 688 13
 2983 021c 080053E3 		cmp	r3, #8
 2984 0220 0500001A 		bne	.L161
 689:main.c        ****       task_aktiv = "32ms";
 2985              		.loc 1 689 18
 2986 0224 44349FE5 		ldr	r3, .L180+120
 2987 0228 10300BE5 		str	r3, [fp, #-16]
 690:main.c        ****       task_32ms();
 2988              		.loc 1 690 7
 2989 022c 40349FE5 		ldr	r3, .L180+124
 2990 0230 0FE0A0E1 		mov	lr, pc
 2991 0234 13FF2FE1 		bx	r3
 2992              	.LVL42:
 2993 0238 260000EA 		b	.L158
 2994              	.L161:
 691:main.c        ****     }
 692:main.c        ****     else if ((zeitscheibe & 0b000011111) == 0b000010000) {
 2995              		.loc 1 692 27
 2996 023c 0C301BE5 		ldr	r3, [fp, #-12]
 2997 0240 1F3003E2 		and	r3, r3, #31
 2998              		.loc 1 692 13
 2999 0244 100053E3 		cmp	r3, #16
 3000 0248 0500001A 		bne	.L162
 693:main.c        ****       task_aktiv = "64ms";
 3001              		.loc 1 693 18
 3002 024c 24349FE5 		ldr	r3, .L180+128
 3003 0250 10300BE5 		str	r3, [fp, #-16]
 694:main.c        ****       task_64ms();
 3004              		.loc 1 694 7
 3005 0254 20349FE5 		ldr	r3, .L180+132
 3006 0258 0FE0A0E1 		mov	lr, pc
 3007 025c 13FF2FE1 		bx	r3
 3008              	.LVL43:
 3009 0260 1C0000EA 		b	.L158
 3010              	.L162:
 695:main.c        ****     }
 696:main.c        ****     else if ((zeitscheibe & 0b000111111) == 0b000100000) {
 3011              		.loc 1 696 27
 3012 0264 0C301BE5 		ldr	r3, [fp, #-12]
 3013 0268 3F3003E2 		and	r3, r3, #63
 3014              		.loc 1 696 13
 3015 026c 200053E3 		cmp	r3, #32
 3016 0270 0500001A 		bne	.L163
 697:main.c        ****       task_aktiv = "128ms";
 3017              		.loc 1 697 18
 3018 0274 04349FE5 		ldr	r3, .L180+136
 3019 0278 10300BE5 		str	r3, [fp, #-16]
 698:main.c        ****       task_128ms();
 3020              		.loc 1 698 7
 3021 027c 00349FE5 		ldr	r3, .L180+140
 3022 0280 0FE0A0E1 		mov	lr, pc
 3023 0284 13FF2FE1 		bx	r3
 3024              	.LVL44:
 3025 0288 120000EA 		b	.L158
 3026              	.L163:
 699:main.c        ****     }
 700:main.c        ****     else if ((zeitscheibe & 0b001111111) == 0b001000000) {
 3027              		.loc 1 700 27
 3028 028c 0C301BE5 		ldr	r3, [fp, #-12]
 3029 0290 7F3003E2 		and	r3, r3, #127
 3030              		.loc 1 700 13
 3031 0294 400053E3 		cmp	r3, #64
 3032 0298 0500001A 		bne	.L164
 701:main.c        ****       task_aktiv = "256ms";
 3033              		.loc 1 701 18
 3034 029c E4339FE5 		ldr	r3, .L180+144
 3035 02a0 10300BE5 		str	r3, [fp, #-16]
 702:main.c        ****       task_256ms();
 3036              		.loc 1 702 7
 3037 02a4 E0339FE5 		ldr	r3, .L180+148
 3038 02a8 0FE0A0E1 		mov	lr, pc
 3039 02ac 13FF2FE1 		bx	r3
 3040              	.LVL45:
 3041 02b0 080000EA 		b	.L158
 3042              	.L164:
 703:main.c        ****     }
 704:main.c        ****     else if ((zeitscheibe & 0b011111111) == 0b010000000) {
 3043              		.loc 1 704 27
 3044 02b4 0C301BE5 		ldr	r3, [fp, #-12]
 3045 02b8 FF3003E2 		and	r3, r3, #255
 3046              		.loc 1 704 13
 3047 02bc 800053E3 		cmp	r3, #128
 3048 02c0 0400001A 		bne	.L158
 705:main.c        ****       task_aktiv = "512ms";
 3049              		.loc 1 705 18
 3050 02c4 C4339FE5 		ldr	r3, .L180+152
 3051 02c8 10300BE5 		str	r3, [fp, #-16]
 706:main.c        ****       task_512ms();
 3052              		.loc 1 706 7
 3053 02cc C0339FE5 		ldr	r3, .L180+156
 3054 02d0 0FE0A0E1 		mov	lr, pc
 3055 02d4 13FF2FE1 		bx	r3
 3056              	.LVL46:
 3057              	.L158:
 707:main.c        ****     }
 708:main.c        ****     // Zeit für IDLE-Task verfügbar
 709:main.c        ****     if ((int)(start_tick - systick_get_ms()) >= IDLE_MS) {
 3058              		.loc 1 709 28
 3059 02d8 70339FE5 		ldr	r3, .L180+88
 3060 02dc 0FE0A0E1 		mov	lr, pc
 3061 02e0 13FF2FE1 		bx	r3
 3062              	.LVL47:
 3063 02e4 0020A0E1 		mov	r2, r0
 3064              		.loc 1 709 26 discriminator 1
 3065 02e8 08301BE5 		ldr	r3, [fp, #-8]
 3066 02ec 023043E0 		sub	r3, r3, r2
 3067              		.loc 1 709 8 discriminator 1
 3068 02f0 000053E3 		cmp	r3, #0
 3069 02f4 040000DA 		ble	.L165
 710:main.c        ****       task_aktiv = "Idle";
 3070              		.loc 1 710 18
 3071 02f8 98339FE5 		ldr	r3, .L180+160
 3072 02fc 10300BE5 		str	r3, [fp, #-16]
 711:main.c        ****       task_idle();
 3073              		.loc 1 711 7
 3074 0300 94339FE5 		ldr	r3, .L180+164
 3075 0304 0FE0A0E1 		mov	lr, pc
 3076 0308 13FF2FE1 		bx	r3
 3077              	.LVL48:
 3078              	.L165:
 712:main.c        ****     }
 713:main.c        ****     // Max. Zeitdauer einer Zeitscheibe überschritten?
 714:main.c        ****     if ((int)(start_tick - systick_get_ms()) <= 0) {
 3079              		.loc 1 714 28
 3080 030c 3C339FE5 		ldr	r3, .L180+88
 3081 0310 0FE0A0E1 		mov	lr, pc
 3082 0314 13FF2FE1 		bx	r3
 3083              	.LVL49:
 3084 0318 0020A0E1 		mov	r2, r0
 3085              		.loc 1 714 26 discriminator 1
 3086 031c 08301BE5 		ldr	r3, [fp, #-8]
 3087 0320 023043E0 		sub	r3, r3, r2
 3088              		.loc 1 714 8 discriminator 1
 3089 0324 000053E3 		cmp	r3, #0
 3090 0328 2C0000CA 		bgt	.L166
 715:main.c        ****       main_data.term_status |= term_string(
 3091              		.loc 1 715 32
 3092 032c 0010A0E3 		mov	r1, #0
 3093 0330 68039FE5 		ldr	r0, .L180+168
 3094 0334 F0329FE5 		ldr	r3, .L180+52
 3095 0338 0FE0A0E1 		mov	lr, pc
 3096 033c 13FF2FE1 		bx	r3
 3097              	.LVL50:
 3098 0340 0030A0E1 		mov	r3, r0
 3099              		.loc 1 715 16 discriminator 1
 3100 0344 58239FE5 		ldr	r2, .L180+172
 3101 0348 D020D2E1 		ldrsb	r2, [r2]
 3102              		.loc 1 715 29 discriminator 1
 3103 034c 033CA0E1 		lsl	r3, r3, #24
 3104 0350 433CA0E1 		asr	r3, r3, #24
 3105 0354 033082E1 		orr	r3, r2, r3
 3106 0358 033CA0E1 		lsl	r3, r3, #24
 3107 035c 432CA0E1 		asr	r2, r3, #24
 3108 0360 3C339FE5 		ldr	r3, .L180+172
 3109 0364 0020C3E5 		strb	r2, [r3]
 716:main.c        ****           VT100_VORDERGRUND_ROT "Timing durch '", ASYNCSYNC_NONBLOCK);
 717:main.c        ****       main_data.term_status |= term_string(task_aktiv, ASYNCSYNC_NONBLOCK);
 3110              		.loc 1 717 32
 3111 0368 0010A0E3 		mov	r1, #0
 3112 036c 10001BE5 		ldr	r0, [fp, #-16]
 3113 0370 B4329FE5 		ldr	r3, .L180+52
 3114 0374 0FE0A0E1 		mov	lr, pc
 3115 0378 13FF2FE1 		bx	r3
 3116              	.LVL51:
 3117 037c 0030A0E1 		mov	r3, r0
 3118              		.loc 1 717 16 discriminator 1
 3119 0380 1C239FE5 		ldr	r2, .L180+172
 3120 0384 D020D2E1 		ldrsb	r2, [r2]
 3121              		.loc 1 717 29 discriminator 1
 3122 0388 033CA0E1 		lsl	r3, r3, #24
 3123 038c 433CA0E1 		asr	r3, r3, #24
 3124 0390 033082E1 		orr	r3, r2, r3
 3125 0394 033CA0E1 		lsl	r3, r3, #24
 3126 0398 432CA0E1 		asr	r2, r3, #24
 3127 039c 00339FE5 		ldr	r3, .L180+172
 3128 03a0 0020C3E5 		strb	r2, [r3]
 718:main.c        ****       main_data.term_status |= term_string(
 3129              		.loc 1 718 32
 3130 03a4 0010A0E3 		mov	r1, #0
 3131 03a8 F8029FE5 		ldr	r0, .L180+176
 3132 03ac 78329FE5 		ldr	r3, .L180+52
 3133 03b0 0FE0A0E1 		mov	lr, pc
 3134 03b4 13FF2FE1 		bx	r3
 3135              	.LVL52:
 3136 03b8 0030A0E1 		mov	r3, r0
 3137              		.loc 1 718 16 discriminator 1
 3138 03bc E0229FE5 		ldr	r2, .L180+172
 3139 03c0 D020D2E1 		ldrsb	r2, [r2]
 3140              		.loc 1 718 29 discriminator 1
 3141 03c4 033CA0E1 		lsl	r3, r3, #24
 3142 03c8 433CA0E1 		asr	r3, r3, #24
 3143 03cc 033082E1 		orr	r3, r2, r3
 3144 03d0 033CA0E1 		lsl	r3, r3, #24
 3145 03d4 432CA0E1 		asr	r2, r3, #24
 3146 03d8 C4329FE5 		ldr	r3, .L180+172
 3147 03dc 0020C3E5 		strb	r2, [r3]
 3148              	.L166:
 719:main.c        ****           "' verletzt\n\r" VT100_VORDERGRUND_DEFAULT, ASYNCSYNC_NONBLOCK);
 720:main.c        ****     }
 721:main.c        ****     // Zeitscheibe erhöhen
 722:main.c        ****     zeitscheibe++;
 3149              		.loc 1 722 16
 3150 03e0 0C301BE5 		ldr	r3, [fp, #-12]
 3151 03e4 013083E2 		add	r3, r3, #1
 3152 03e8 0C300BE5 		str	r3, [fp, #-12]
 3153              	.LBB10:
 3154              	.LBB11:
 123:lib/../main.h **** 
 124:lib/../main.h **** static __inline__ int32_t stack_check(void) __attribute__((always_inline));
 125:lib/../main.h **** static __inline__ int32_t stack_check(void)
 126:lib/../main.h **** {
 127:lib/../main.h **** 	         uint32_t *ptr;
 128:lib/../main.h **** //	register uint32_t *sp asm("r13");
 129:lib/../main.h **** 	for(ptr=&__stack_start__[0];*ptr==STACK_FILL;++ptr);
 3155              		.loc 4 129 9
 3156 03ec 54329FE5 		ldr	r3, .L180+80
 3157 03f0 18300BE5 		str	r3, [fp, #-24]
 3158              		.loc 4 129 2
 3159 03f4 020000EA 		b	.L167
 3160              	.L168:
 3161              		.loc 4 129 47 discriminator 3
 3162 03f8 18301BE5 		ldr	r3, [fp, #-24]
 3163 03fc 043083E2 		add	r3, r3, #4
 3164 0400 18300BE5 		str	r3, [fp, #-24]
 3165              	.L167:
 3166              		.loc 4 129 30 discriminator 1
 3167 0404 18301BE5 		ldr	r3, [fp, #-24]
 3168 0408 003093E5 		ldr	r3, [r3]
 3169              		.loc 4 129 34 discriminator 1
 3170 040c 38229FE5 		ldr	r2, .L180+84
 3171 0410 020053E1 		cmp	r3, r2
 3172 0414 F7FFFF0A 		beq	.L168
 130:lib/../main.h **** 	return (int32_t)(ptr-&__stack_start__[0]);
 3173              		.loc 4 130 22
 3174 0418 18301BE5 		ldr	r3, [fp, #-24]
 3175 041c 24229FE5 		ldr	r2, .L180+80
 3176 0420 023043E0 		sub	r3, r3, r2
 3177              		.loc 4 130 9
 3178 0424 4331A0E1 		asr	r3, r3, #2
 3179              	.LBE11:
 3180              	.LBE10:
 723:main.c        **** 
 724:main.c        ****     // Stack Testen
 725:main.c        ****     if (stack_check() < (1 * 4)) {
 3181              		.loc 1 725 8 discriminator 1
 3182 0428 030053E3 		cmp	r3, #3
 3183 042c 350000CA 		bgt	.L170
 3184              	.LBB12:
 726:main.c        ****       static uint8_t stack_cnt = 0;
 727:main.c        ****       if (stack_cnt == 0) {
 3185              		.loc 1 727 21
 3186 0430 74329FE5 		ldr	r3, .L180+180
 3187 0434 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 3188              		.loc 1 727 10
 3189 0438 000053E3 		cmp	r3, #0
 3190 043c 3100001A 		bne	.L170
 728:main.c        ****         stack_cnt = 1;
 3191              		.loc 1 728 19
 3192 0440 64329FE5 		ldr	r3, .L180+180
 3193 0444 0120A0E3 		mov	r2, #1
 3194 0448 0020C3E5 		strb	r2, [r3]
 729:main.c        ****         main_data.term_status |= term_string(
 3195              		.loc 1 729 34
 3196 044c 0010A0E3 		mov	r1, #0
 3197 0450 58029FE5 		ldr	r0, .L180+184
 3198 0454 D0319FE5 		ldr	r3, .L180+52
 3199 0458 0FE0A0E1 		mov	lr, pc
 3200 045c 13FF2FE1 		bx	r3
 3201              	.LVL53:
 3202 0460 0030A0E1 		mov	r3, r0
 3203              		.loc 1 729 18 discriminator 1
 3204 0464 38229FE5 		ldr	r2, .L180+172
 3205 0468 D020D2E1 		ldrsb	r2, [r2]
 3206              		.loc 1 729 31 discriminator 1
 3207 046c 033CA0E1 		lsl	r3, r3, #24
 3208 0470 433CA0E1 		asr	r3, r3, #24
 3209 0474 033082E1 		orr	r3, r2, r3
 3210 0478 033CA0E1 		lsl	r3, r3, #24
 3211 047c 432CA0E1 		asr	r2, r3, #24
 3212 0480 1C329FE5 		ldr	r3, .L180+172
 3213 0484 0020C3E5 		strb	r2, [r3]
 730:main.c        ****             VT100_VORDERGRUND_ROT "Stack overflow durch '", ASYNCSYNC_NONBLOCK);
 731:main.c        ****         main_data.term_status |= term_string(task_aktiv, ASYNCSYNC_NONBLOCK);
 3214              		.loc 1 731 34
 3215 0488 0010A0E3 		mov	r1, #0
 3216 048c 10001BE5 		ldr	r0, [fp, #-16]
 3217 0490 94319FE5 		ldr	r3, .L180+52
 3218 0494 0FE0A0E1 		mov	lr, pc
 3219 0498 13FF2FE1 		bx	r3
 3220              	.LVL54:
 3221 049c 0030A0E1 		mov	r3, r0
 3222              		.loc 1 731 18 discriminator 1
 3223 04a0 FC219FE5 		ldr	r2, .L180+172
 3224 04a4 D020D2E1 		ldrsb	r2, [r2]
 3225              		.loc 1 731 31 discriminator 1
 3226 04a8 033CA0E1 		lsl	r3, r3, #24
 3227 04ac 433CA0E1 		asr	r3, r3, #24
 3228 04b0 033082E1 		orr	r3, r2, r3
 3229 04b4 033CA0E1 		lsl	r3, r3, #24
 3230 04b8 432CA0E1 		asr	r2, r3, #24
 3231 04bc E0319FE5 		ldr	r3, .L180+172
 3232 04c0 0020C3E5 		strb	r2, [r3]
 732:main.c        ****         main_data.term_status |=
 733:main.c        ****             term_string("'\n\r" VT100_VORDERGRUND_DEFAULT, ASYNCSYNC_NONBLOCK);
 3233              		.loc 1 733 13
 3234 04c4 0010A0E3 		mov	r1, #0
 3235 04c8 E4019FE5 		ldr	r0, .L180+188
 3236 04cc 58319FE5 		ldr	r3, .L180+52
 3237 04d0 0FE0A0E1 		mov	lr, pc
 3238 04d4 13FF2FE1 		bx	r3
 3239              	.LVL55:
 3240 04d8 0030A0E1 		mov	r3, r0
 732:main.c        ****         main_data.term_status |=
 3241              		.loc 1 732 18
 3242 04dc C0219FE5 		ldr	r2, .L180+172
 3243 04e0 D020D2E1 		ldrsb	r2, [r2]
 732:main.c        ****         main_data.term_status |=
 3244              		.loc 1 732 31
 3245 04e4 033CA0E1 		lsl	r3, r3, #24
 3246 04e8 433CA0E1 		asr	r3, r3, #24
 3247 04ec 033082E1 		orr	r3, r2, r3
 3248 04f0 033CA0E1 		lsl	r3, r3, #24
 3249 04f4 432CA0E1 		asr	r2, r3, #24
 3250 04f8 A4319FE5 		ldr	r3, .L180+172
 3251 04fc 0020C3E5 		strb	r2, [r3]
 3252              	.L171:
 734:main.c        ****         while (1)
 3253              		.loc 1 734 15
 3254 0500 0000A0E1 		nop
 3255 0504 FDFFFFEA 		b	.L171
 3256              	.L170:
 3257              	.LBE12:
 735:main.c        ****           ;
 736:main.c        ****       }
 737:main.c        ****     }
 738:main.c        **** 
 739:main.c        ****     // Batteriespannung überprüfen
 740:main.c        ****     // Ggf. schlägt die Unterspannungsprüfung im Akku zuvor ein!
 741:main.c        ****     if (nxt_avr_get_battery_raw() < ((2 * 3000 /*mV*/) << 10) / 14180) {
 3258              		.loc 1 741 9
 3259 0508 A8319FE5 		ldr	r3, .L180+192
 3260 050c 0FE0A0E1 		mov	lr, pc
 3261 0510 13FF2FE1 		bx	r3
 3262              	.LVL56:
 3263 0514 0030A0E1 		mov	r3, r0
 3264              		.loc 1 741 8 discriminator 1
 3265 0518 1B0E53E3 		cmp	r3, #432
 3266 051c 1D00008A 		bhi	.L172
 742:main.c        ****       if (main_data.lowbat_cnt++ > 100)
 3267              		.loc 1 742 20
 3268 0520 7C319FE5 		ldr	r3, .L180+172
 3269 0524 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3270              		.loc 1 742 31
 3271 0528 012083E2 		add	r2, r3, #1
 3272 052c FF1002E2 		and	r1, r2, #255
 3273 0530 6C219FE5 		ldr	r2, .L180+172
 3274 0534 0210C2E5 		strb	r1, [r2, #2]
 3275              		.loc 1 742 10
 3276 0538 640053E3 		cmp	r3, #100
 3277 053c 0100009A 		bls	.L173
 3278              	.L174:
 743:main.c        ****         while (1)
 3279              		.loc 1 743 15
 3280 0540 0000A0E1 		nop
 3281 0544 FDFFFFEA 		b	.L174
 3282              	.L173:
 744:main.c        ****           ;
 745:main.c        ****       else if (main_data.lowbat_cnt == 10)
 3283              		.loc 1 745 25
 3284 0548 54319FE5 		ldr	r3, .L180+172
 3285 054c 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3286              		.loc 1 745 15
 3287 0550 0A0053E3 		cmp	r3, #10
 3288 0554 1200001A 		bne	.L175
 746:main.c        ****         main_data.term_status |=
 747:main.c        ****             term_string(VT100_VORDERGRUND_ROT
 3289              		.loc 1 747 13
 3290 0558 0010A0E3 		mov	r1, #0
 3291 055c 58019FE5 		ldr	r0, .L180+196
 3292 0560 C4309FE5 		ldr	r3, .L180+52
 3293 0564 0FE0A0E1 		mov	lr, pc
 3294 0568 13FF2FE1 		bx	r3
 3295              	.LVL57:
 3296 056c 0030A0E1 		mov	r3, r0
 746:main.c        ****         main_data.term_status |=
 3297              		.loc 1 746 18
 3298 0570 2C219FE5 		ldr	r2, .L180+172
 3299 0574 D020D2E1 		ldrsb	r2, [r2]
 746:main.c        ****         main_data.term_status |=
 3300              		.loc 1 746 31
 3301 0578 033CA0E1 		lsl	r3, r3, #24
 3302 057c 433CA0E1 		asr	r3, r3, #24
 3303 0580 033082E1 		orr	r3, r2, r3
 3304 0584 033CA0E1 		lsl	r3, r3, #24
 3305 0588 432CA0E1 		asr	r2, r3, #24
 3306 058c 10319FE5 		ldr	r3, .L180+172
 3307 0590 0020C3E5 		strb	r2, [r3]
 3308 0594 020000EA 		b	.L175
 3309              	.L172:
 748:main.c        ****                         "\n\rLow Battery\n\r" VT100_VORDERGRUND_DEFAULT,
 749:main.c        ****                         ASYNCSYNC_NONBLOCK);
 750:main.c        ****     } else {
 751:main.c        ****       main_data.lowbat_cnt = 0;
 3310              		.loc 1 751 28
 3311 0598 04319FE5 		ldr	r3, .L180+172
 3312 059c 0020A0E3 		mov	r2, #0
 3313 05a0 0220C3E5 		strb	r2, [r3, #2]
 3314              	.L175:
 752:main.c        ****     }
 753:main.c        **** 
 754:main.c        ****     // Termstatus ueberpruefen
 755:main.c        ****     if (main_data.term_cnt == 0 && main_data.term_status != 0) {
 3315              		.loc 1 755 18
 3316 05a4 F8309FE5 		ldr	r3, .L180+172
 3317 05a8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3318              		.loc 1 755 8
 3319 05ac 000053E3 		cmp	r3, #0
 3320 05b0 EDFEFF1A 		bne	.L179
 3321              		.loc 1 755 45 discriminator 1
 3322 05b4 E8309FE5 		ldr	r3, .L180+172
 3323 05b8 D030D3E1 		ldrsb	r3, [r3]
 3324              		.loc 1 755 33 discriminator 1
 3325 05bc 000053E3 		cmp	r3, #0
 3326 05c0 E9FEFF0A 		beq	.L179
 756:main.c        ****       main_data.term_cnt++;
 3327              		.loc 1 756 16
 3328 05c4 D8309FE5 		ldr	r3, .L180+172
 3329 05c8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3330              		.loc 1 756 25
 3331 05cc 013083E2 		add	r3, r3, #1
 3332 05d0 FF2003E2 		and	r2, r3, #255
 3333 05d4 C8309FE5 		ldr	r3, .L180+172
 3334 05d8 0120C3E5 		strb	r2, [r3, #1]
 3335              	.L177:
 757:main.c        ****     overflow:
 758:main.c        ****       __attribute__((unused));
 759:main.c        **** 
 760:main.c        ****       (void)term_string(VT100_VORDERGRUND_ROT
 3336              		.loc 1 760 13
 3337 05dc 0110A0E3 		mov	r1, #1
 3338 05e0 D8009FE5 		ldr	r0, .L180+200
 3339 05e4 40309FE5 		ldr	r3, .L180+52
 3340 05e8 0FE0A0E1 		mov	lr, pc
 3341 05ec 13FF2FE1 		bx	r3
 3342              	.LVL58:
 3343              	.L178:
 761:main.c        ****                         "\n\rTerminal Overflow\n\r" VT100_VORDERGRUND_DEFAULT,
 762:main.c        ****                         ASYNCSYNC_BLOCK);
 763:main.c        ****       while (1)
 3344              		.loc 1 763 13
 3345 05f0 0000A0E1 		nop
 3346 05f4 FDFFFFEA 		b	.L178
 3347              	.L181:
 3348              		.align	2
 3349              	.L180:
 3350 05f8 00000000 		.word	aic_init
 3351 05fc 00000000 		.word	systick_init
 3352 0600 00000000 		.word	interrupts_enable
 3353 0604 00000000 		.word	nxt_avr_init
 3354 0608 00000000 		.word	udmon3_init
 3355 060c 00000000 		.word	term_init
 3356 0610 00000000 		.word	display_init
 3357 0614 00000000 		.word	ui_init
 3358 0618 00000000 		.word	schrittmotor_data
 3359 061c 00000000 		.word	schrittmotor_init
 3360 0620 00000000 		.word	display_clear
 3361 0624 00000000 		.word	display_update
 3362 0628 9C000000 		.word	.LC9
 3363 062c 00000000 		.word	term_string
 3364 0630 A4000000 		.word	.LC10
 3365 0634 B0000000 		.word	.LC11
 3366 0638 E0000000 		.word	.LC12
 3367 063c 1C010000 		.word	.LC13
 3368 0640 40FDFFFF 		.word	-704
 3369 0644 FF8F0030 		.word	805343231
 3370 0648 00000000 		.word	__stack_start__
 3371 064c 11111111 		.word	286331153
 3372 0650 00000000 		.word	systick_get_ms
 3373 0654 2C010000 		.word	.LC14
 3374 0658 30010000 		.word	.LC15
 3375 065c 00000000 		.word	task_4ms
 3376 0660 34010000 		.word	.LC16
 3377 0664 00000000 		.word	task_8ms
 3378 0668 38010000 		.word	.LC17
 3379 066c 00000000 		.word	task_16ms
 3380 0670 40010000 		.word	.LC18
 3381 0674 00000000 		.word	task_32ms
 3382 0678 48010000 		.word	.LC19
 3383 067c 00000000 		.word	task_64ms
 3384 0680 50010000 		.word	.LC20
 3385 0684 00000000 		.word	task_128ms
 3386 0688 58010000 		.word	.LC21
 3387 068c 00000000 		.word	task_256ms
 3388 0690 60010000 		.word	.LC22
 3389 0694 00000000 		.word	task_512ms
 3390 0698 68010000 		.word	.LC23
 3391 069c 00000000 		.word	task_idle
 3392 06a0 70010000 		.word	.LC24
 3393 06a4 00000000 		.word	main_data
 3394 06a8 84010000 		.word	.LC25
 3395 06ac 36030000 		.word	stack_cnt.0
 3396 06b0 98010000 		.word	.LC26
 3397 06b4 B4010000 		.word	.LC27
 3398 06b8 00000000 		.word	nxt_avr_get_battery_raw
 3399 06bc C0010000 		.word	.LC28
 3400 06c0 DC010000 		.word	.LC29
 3401              		.cfi_endproc
 3402              	.LFE33:
 3404              		.bss
 3405              		.align	2
 3406              	trace_index.3:
 3407 0324 00000000 		.space	4
 3409              		.align	2
 3410              	count.2:
 3411 0328 00000000 		.space	4
 3413              		.align	2
 3414              	linebuf.1:
 3415 032c 00000000 		.space	10
 3415      00000000 
 3415      0000
 3417              	stack_cnt.0:
 3418 0336 00       		.space	1
 3420              		.text
 3421              	.Letext0:
 3422              		.file 5 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/lib/gcc/arm-none-eabi/14.3.
 3423              		.file 6 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/machi
 3424              		.file 7 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/_
 3425              		.file 8 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/r
 3426              		.file 9 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/l
 3427              		.file 10 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/
 3428              		.file 11 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/stdi
 3429              		.file 12 "AT91SAM7S64.h"
 3430              		.file 13 "lib/nxt_avr.h"
 3431              		.file 14 "lib/systick.h"
 3432              		.file 15 "lib/display.h"
 3433              		.file 16 "lib/term.h"
 3434              		.file 17 "trace32/udmon3.h"
 3435              		.file 18 "lib/isr.h"
 3436              		.file 19 "lib/aic.h"
 3437              		.file 20 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccJvDqPC.s:19     .text.byte_fifo_put_possible:00000000 $a
     /tmp/ccJvDqPC.s:23     .text.byte_fifo_put_possible:00000000 byte_fifo_put_possible
     /tmp/ccJvDqPC.s:75     .text.byte_fifo_remain:00000000 $a
     /tmp/ccJvDqPC.s:79     .text.byte_fifo_remain:00000000 byte_fifo_remain
     /tmp/ccJvDqPC.s:133    .text.byte_fifo_used:00000000 $a
     /tmp/ccJvDqPC.s:137    .text.byte_fifo_used:00000000 byte_fifo_used
     /tmp/ccJvDqPC.s:188    .text.byte_fifo_put:00000000 $a
     /tmp/ccJvDqPC.s:192    .text.byte_fifo_put:00000000 byte_fifo_put
     /tmp/ccJvDqPC.s:277    .text.byte_fifo_get_possible:00000000 $a
     /tmp/ccJvDqPC.s:281    .text.byte_fifo_get_possible:00000000 byte_fifo_get_possible
     /tmp/ccJvDqPC.s:325    .text.byte_fifo_get:00000000 $a
     /tmp/ccJvDqPC.s:329    .text.byte_fifo_get:00000000 byte_fifo_get
     /tmp/ccJvDqPC.s:408    .text.byte_fifo_cb_put_possible:00000000 $a
     /tmp/ccJvDqPC.s:412    .text.byte_fifo_cb_put_possible:00000000 byte_fifo_cb_put_possible
     /tmp/ccJvDqPC.s:450    .text.byte_fifo_cb_put_possible:0000003c $d
     /tmp/ccJvDqPC.s:455    .text.byte_fifo_cb_put:00000000 $a
     /tmp/ccJvDqPC.s:459    .text.byte_fifo_cb_put:00000000 byte_fifo_cb_put
     /tmp/ccJvDqPC.s:520    .text.byte_fifo_cb_put:0000007c $d
     /tmp/ccJvDqPC.s:525    .text.byte_fifo_cb_get_possible:00000000 $a
     /tmp/ccJvDqPC.s:529    .text.byte_fifo_cb_get_possible:00000000 byte_fifo_cb_get_possible
     /tmp/ccJvDqPC.s:566    .text.byte_fifo_cb_get_possible:0000003c $d
     /tmp/ccJvDqPC.s:571    .text.byte_fifo_cb_get:00000000 $a
     /tmp/ccJvDqPC.s:575    .text.byte_fifo_cb_get:00000000 byte_fifo_cb_get
     /tmp/ccJvDqPC.s:614    .text.byte_fifo_cb_get:00000044 $d
     /tmp/ccJvDqPC.s:623    .bss:00000000 main_data
     /tmp/ccJvDqPC.s:620    .bss:00000000 $d
     /tmp/ccJvDqPC.s:626    .text._exit:00000000 $a
     /tmp/ccJvDqPC.s:631    .text._exit:00000000 _exit
     /tmp/ccJvDqPC.s:658    .bss:00000004 trace_buf0
     /tmp/ccJvDqPC.s:664    .bss:00000194 trace_buf1
     /tmp/ccJvDqPC.s:667    .text.trace_scope:00000000 $a
     /tmp/ccJvDqPC.s:672    .text.trace_scope:00000000 trace_scope
     /tmp/ccJvDqPC.s:760    .text.trace_scope:000000c8 $d
     /tmp/ccJvDqPC.s:3406   .bss:00000324 trace_index.3
     /tmp/ccJvDqPC.s:771    .data:00000000 pio
     /tmp/ccJvDqPC.s:768    .data:00000000 $d
     /tmp/ccJvDqPC.s:777    .data:00000004 pmc
     /tmp/ccJvDqPC.s:783    .data:00000008 pwm_ctl
     /tmp/ccJvDqPC.s:803    .data:0000000c schritt_mode2str
     /tmp/ccJvDqPC.s:787    .rodata:00000000 $d
     /tmp/ccJvDqPC.s:812    .data:0000001c schrittmotor_data
     /tmp/ccJvDqPC.s:864    .text.schrittmotor_init:00000000 $a
     /tmp/ccJvDqPC.s:869    .text.schrittmotor_init:00000000 schrittmotor_init
     /tmp/ccJvDqPC.s:1041   .text.schrittmotor_init:000001a0 $d
     /tmp/ccJvDqPC.s:1057   .text.schrittmotor_update:00000000 $a
     /tmp/ccJvDqPC.s:1062   .text.schrittmotor_update:00000000 schrittmotor_update
     /tmp/ccJvDqPC.s:1219   .text.schrittmotor_update:00000168 $d
     /tmp/ccJvDqPC.s:1225   .text.schrittmotor_process:00000000 $a
     /tmp/ccJvDqPC.s:1230   .text.schrittmotor_process:00000000 schrittmotor_process
     /tmp/ccJvDqPC.s:1743   .text.schrittmotor_process:00000450 $d
     /tmp/ccJvDqPC.s:1762   .text.ui_init:00000000 $a
     /tmp/ccJvDqPC.s:1767   .text.ui_init:00000000 ui_init
     /tmp/ccJvDqPC.s:1793   .text.ui_process:00000000 $a
     /tmp/ccJvDqPC.s:1798   .text.ui_process:00000000 ui_process
     /tmp/ccJvDqPC.s:2215   .text.ui_process:0000045c $d
     /tmp/ccJvDqPC.s:3410   .bss:00000328 count.2
     /tmp/ccJvDqPC.s:2228   .text.task_4ms:00000000 $a
     /tmp/ccJvDqPC.s:2233   .text.task_4ms:00000000 task_4ms
     /tmp/ccJvDqPC.s:2333   .text.task_4ms:000000e8 $d
     /tmp/ccJvDqPC.s:2339   .text.task_8ms:00000000 $a
     /tmp/ccJvDqPC.s:2344   .text.task_8ms:00000000 task_8ms
     /tmp/ccJvDqPC.s:2370   .text.task_16ms:00000000 $a
     /tmp/ccJvDqPC.s:2375   .text.task_16ms:00000000 task_16ms
     /tmp/ccJvDqPC.s:2401   .text.task_32ms:00000000 $a
     /tmp/ccJvDqPC.s:2406   .text.task_32ms:00000000 task_32ms
     /tmp/ccJvDqPC.s:2432   .text.task_64ms:00000000 $a
     /tmp/ccJvDqPC.s:2437   .text.task_64ms:00000000 task_64ms
     /tmp/ccJvDqPC.s:2468   .text.task_64ms:00000024 $d
     /tmp/ccJvDqPC.s:2473   .text.task_128ms:00000000 $a
     /tmp/ccJvDqPC.s:2478   .text.task_128ms:00000000 task_128ms
     /tmp/ccJvDqPC.s:2504   .text.task_256ms:00000000 $a
     /tmp/ccJvDqPC.s:2509   .text.task_256ms:00000000 task_256ms
     /tmp/ccJvDqPC.s:2535   .text.task_512ms:00000000 $a
     /tmp/ccJvDqPC.s:2540   .text.task_512ms:00000000 task_512ms
     /tmp/ccJvDqPC.s:2566   .text.task_1024ms:00000000 $a
     /tmp/ccJvDqPC.s:2571   .text.task_1024ms:00000000 task_1024ms
     /tmp/ccJvDqPC.s:2597   .text.task_idle:00000000 $a
     /tmp/ccJvDqPC.s:2602   .text.task_idle:00000000 task_idle
     /tmp/ccJvDqPC.s:2628   .text.premain_init:00000000 $a
     /tmp/ccJvDqPC.s:2633   .text.premain_init:00000000 premain_init
     /tmp/ccJvDqPC.s:2675   .text.premain_init:0000003c $d
     /tmp/ccJvDqPC.s:3414   .bss:0000032c linebuf.1
     /tmp/ccJvDqPC.s:2682   .init_array:00000000 $d
     /tmp/ccJvDqPC.s:2751   .text.main:00000000 $a
     /tmp/ccJvDqPC.s:2756   .text.main:00000000 main
     /tmp/ccJvDqPC.s:3350   .text.main:000005f8 $d
     /tmp/ccJvDqPC.s:3417   .bss:00000336 stack_cnt.0

UNDEFINED SYMBOLS
nxt_avr_get_buttons
display_goto_xy
display_unsigned
display_string
display_update
_impure_ptr
setvbuf
aic_init
systick_init
interrupts_enable
nxt_avr_init
udmon3_init
term_init
display_init
display_clear
term_string
__stack_start__
systick_get_ms
nxt_avr_get_battery_raw
