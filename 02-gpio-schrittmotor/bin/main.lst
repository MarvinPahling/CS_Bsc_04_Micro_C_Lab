   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "main.c"
  18              		.section	.text.byte_fifo_put_possible,"ax",%progbits
  19              		.align	2
  20              		.syntax unified
  21              		.arm
  23              	byte_fifo_put_possible:
  24              	.LFB5:
  25              		.file 2 "trace32/../lib/byte_fifo.h"
   1:trace32/../lib/byte_fifo.h **** /* Byte FIFO queue implementation.
   2:trace32/../lib/byte_fifo.h ****  *
   3:trace32/../lib/byte_fifo.h ****  * Implements a simple reader/write save byte FIFO on top of a data buffer, that lets
   4:trace32/../lib/byte_fifo.h ****  * you enqueue and dequeue single bytes.
   5:trace32/../lib/byte_fifo.h ****  */
   6:trace32/../lib/byte_fifo.h **** 
   7:trace32/../lib/byte_fifo.h **** #ifndef __BYTE_FIFO_H__
   8:trace32/../lib/byte_fifo.h **** #define __BYTE_FIFO_H__
   9:trace32/../lib/byte_fifo.h **** 
  10:trace32/../lib/byte_fifo.h **** 
  11:trace32/../lib/byte_fifo.h **** typedef struct
  12:trace32/../lib/byte_fifo.h **** {
  13:trace32/../lib/byte_fifo.h **** 	unsigned short rd;
  14:trace32/../lib/byte_fifo.h **** 	unsigned short wr;
  15:trace32/../lib/byte_fifo.h ****     unsigned short mask;
  16:trace32/../lib/byte_fifo.h **** 	unsigned char  buf[];
  17:trace32/../lib/byte_fifo.h **** } byte_fifo_t;
  18:trace32/../lib/byte_fifo.h **** 
  19:trace32/../lib/byte_fifo.h **** #define TEST_2erPOTENZ(x) (((x) & ((x) - 1))?0:(x))
  20:trace32/../lib/byte_fifo.h **** #define TEST_64k(x)       ((x)>0x10000?0:(x))
  21:trace32/../lib/byte_fifo.h **** #define TEST_SIZE(x)      (TEST_64k(TEST_2erPOTENZ(x)))
  22:trace32/../lib/byte_fifo.h **** 
  23:trace32/../lib/byte_fifo.h **** //size muss einer 2er Potenzzahl sein, andernfalls gibt der Compiler
  24:trace32/../lib/byte_fifo.h **** //die Fehlermeldung aus, dass die Array-Größe (hier -1) ungültit ist
  25:trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_INIT(size)  (byte_fifo_t) {.rd=0,\
  26:trace32/../lib/byte_fifo.h ****                                              .wr=0,\
  27:trace32/../lib/byte_fifo.h **** 						        	         .mask=TEST_SIZE(size)-1,\
  28:trace32/../lib/byte_fifo.h **** 								    		 .buf={[TEST_SIZE(size)-1]=0}\
  29:trace32/../lib/byte_fifo.h **** 									    	}
  30:trace32/../lib/byte_fifo.h **** 
  31:trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_TYPEOF_RDWR typeof (((byte_fifo_t *)0)->rd)
  32:trace32/../lib/byte_fifo.h **** 
  33:trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic push
  34:trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  35:trace32/../lib/byte_fifo.h **** 
  36:trace32/../lib/byte_fifo.h **** static int byte_fifo_put_possible(byte_fifo_t *fifo)
  37:trace32/../lib/byte_fifo.h **** {
  26              		.loc 2 37 1
  27              		.cfi_startproc
  28              		@ Function supports interworking.
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 04B02DE5 		str	fp, [sp, #-4]!
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 11, -4
  35 0004 00B08DE2 		add	fp, sp, #0
  36              		.cfi_def_cfa_register 11
  37 0008 0CD04DE2 		sub	sp, sp, #12
  38 000c 08000BE5 		str	r0, [fp, #-8]
  38:trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
  39              		.loc 2 38 11
  40 0010 08301BE5 		ldr	r3, [fp, #-8]
  41 0014 B230D3E1 		ldrh	r3, [r3, #2]
  42              		.loc 2 38 15
  43 0018 013083E2 		add	r3, r3, #1
  44              		.loc 2 38 24
  45 001c 08201BE5 		ldr	r2, [fp, #-8]
  46 0020 B420D2E1 		ldrh	r2, [r2, #4]
  47              		.loc 2 38 18
  48 0024 023003E0 		and	r3, r3, r2
  49              		.loc 2 38 40
  50 0028 08201BE5 		ldr	r2, [fp, #-8]
  51 002c B020D2E1 		ldrh	r2, [r2]
  52              		.loc 2 38 4
  53 0030 020053E1 		cmp	r3, r2
  54 0034 0100001A 		bne	.L2
  39:trace32/../lib/byte_fifo.h **** 		return -1;
  55              		.loc 2 39 10
  56 0038 0030E0E3 		mvn	r3, #0
  57 003c 000000EA 		b	.L3
  58              	.L2:
  40:trace32/../lib/byte_fifo.h **** 	
  41:trace32/../lib/byte_fifo.h **** 	return 0;
  59              		.loc 2 41 9
  60 0040 0030A0E3 		mov	r3, #0
  61              	.L3:
  42:trace32/../lib/byte_fifo.h **** }
  62              		.loc 2 42 1
  63 0044 0300A0E1 		mov	r0, r3
  64 0048 00D08BE2 		add	sp, fp, #0
  65              		.cfi_def_cfa_register 13
  66              		@ sp needed
  67 004c 04B09DE4 		ldr	fp, [sp], #4
  68              		.cfi_restore 11
  69              		.cfi_def_cfa_offset 0
  70 0050 1EFF2FE1 		bx	lr
  71              		.cfi_endproc
  72              	.LFE5:
  74              		.section	.text.byte_fifo_remain,"ax",%progbits
  75              		.align	2
  76              		.syntax unified
  77              		.arm
  79              	byte_fifo_remain:
  80              	.LFB6:
  43:trace32/../lib/byte_fifo.h **** 
  44:trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_remain(byte_fifo_t *fifo)
  45:trace32/../lib/byte_fifo.h **** {
  81              		.loc 2 45 1
  82              		.cfi_startproc
  83              		@ Function supports interworking.
  84              		@ args = 0, pretend = 0, frame = 8
  85              		@ frame_needed = 1, uses_anonymous_args = 0
  86              		@ link register save eliminated.
  87 0000 04B02DE5 		str	fp, [sp, #-4]!
  88              		.cfi_def_cfa_offset 4
  89              		.cfi_offset 11, -4
  90 0004 00B08DE2 		add	fp, sp, #0
  91              		.cfi_def_cfa_register 11
  92 0008 0CD04DE2 		sub	sp, sp, #12
  93 000c 08000BE5 		str	r0, [fp, #-8]
  46:trace32/../lib/byte_fifo.h **** 	return fifo->mask - ((fifo->wr-fifo->rd)&fifo->mask);
  94              		.loc 2 46 37
  95 0010 08301BE5 		ldr	r3, [fp, #-8]
  96 0014 B020D3E1 		ldrh	r2, [r3]
  97              		.loc 2 46 28
  98 0018 08301BE5 		ldr	r3, [fp, #-8]
  99 001c B230D3E1 		ldrh	r3, [r3, #2]
 100              		.loc 2 46 20
 101 0020 033042E0 		sub	r3, r2, r3
 102 0024 0338A0E1 		lsl	r3, r3, #16
 103 0028 2338A0E1 		lsr	r3, r3, #16
 104 002c 013043E2 		sub	r3, r3, #1
 105 0030 0338A0E1 		lsl	r3, r3, #16
 106 0034 2338A0E1 		lsr	r3, r3, #16
 107 0038 0338A0E1 		lsl	r3, r3, #16
 108 003c 4328A0E1 		asr	r2, r3, #16
 109              		.loc 2 46 47
 110 0040 08301BE5 		ldr	r3, [fp, #-8]
 111 0044 B430D3E1 		ldrh	r3, [r3, #4]
 112 0048 0338A0E1 		lsl	r3, r3, #16
 113 004c 4338A0E1 		asr	r3, r3, #16
 114              		.loc 2 46 20
 115 0050 023003E0 		and	r3, r3, r2
 116 0054 0338A0E1 		lsl	r3, r3, #16
 117 0058 4338A0E1 		asr	r3, r3, #16
 118 005c 0338A0E1 		lsl	r3, r3, #16
 119 0060 2338A0E1 		lsr	r3, r3, #16
  47:trace32/../lib/byte_fifo.h **** }
 120              		.loc 2 47 1
 121 0064 0300A0E1 		mov	r0, r3
 122 0068 00D08BE2 		add	sp, fp, #0
 123              		.cfi_def_cfa_register 13
 124              		@ sp needed
 125 006c 04B09DE4 		ldr	fp, [sp], #4
 126              		.cfi_restore 11
 127              		.cfi_def_cfa_offset 0
 128 0070 1EFF2FE1 		bx	lr
 129              		.cfi_endproc
 130              	.LFE6:
 132              		.section	.text.byte_fifo_used,"ax",%progbits
 133              		.align	2
 134              		.syntax unified
 135              		.arm
 137              	byte_fifo_used:
 138              	.LFB7:
  48:trace32/../lib/byte_fifo.h **** 	
  49:trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_used(byte_fifo_t *fifo)
  50:trace32/../lib/byte_fifo.h **** {
 139              		.loc 2 50 1
 140              		.cfi_startproc
 141              		@ Function supports interworking.
 142              		@ args = 0, pretend = 0, frame = 8
 143              		@ frame_needed = 1, uses_anonymous_args = 0
 144              		@ link register save eliminated.
 145 0000 04B02DE5 		str	fp, [sp, #-4]!
 146              		.cfi_def_cfa_offset 4
 147              		.cfi_offset 11, -4
 148 0004 00B08DE2 		add	fp, sp, #0
 149              		.cfi_def_cfa_register 11
 150 0008 0CD04DE2 		sub	sp, sp, #12
 151 000c 08000BE5 		str	r0, [fp, #-8]
  51:trace32/../lib/byte_fifo.h **** 	return (fifo->wr-fifo->rd)&fifo->mask;
 152              		.loc 2 51 14
 153 0010 08301BE5 		ldr	r3, [fp, #-8]
 154 0014 B220D3E1 		ldrh	r2, [r3, #2]
 155              		.loc 2 51 23
 156 0018 08301BE5 		ldr	r3, [fp, #-8]
 157 001c B030D3E1 		ldrh	r3, [r3]
 158              		.loc 2 51 18
 159 0020 033042E0 		sub	r3, r2, r3
 160 0024 0338A0E1 		lsl	r3, r3, #16
 161 0028 2338A0E1 		lsr	r3, r3, #16
 162 002c 0338A0E1 		lsl	r3, r3, #16
 163 0030 4328A0E1 		asr	r2, r3, #16
 164              		.loc 2 51 33
 165 0034 08301BE5 		ldr	r3, [fp, #-8]
 166 0038 B430D3E1 		ldrh	r3, [r3, #4]
 167 003c 0338A0E1 		lsl	r3, r3, #16
 168 0040 4338A0E1 		asr	r3, r3, #16
 169              		.loc 2 51 28
 170 0044 023003E0 		and	r3, r3, r2
 171 0048 0338A0E1 		lsl	r3, r3, #16
 172 004c 4338A0E1 		asr	r3, r3, #16
 173 0050 0338A0E1 		lsl	r3, r3, #16
 174 0054 2338A0E1 		lsr	r3, r3, #16
  52:trace32/../lib/byte_fifo.h **** }
 175              		.loc 2 52 1
 176 0058 0300A0E1 		mov	r0, r3
 177 005c 00D08BE2 		add	sp, fp, #0
 178              		.cfi_def_cfa_register 13
 179              		@ sp needed
 180 0060 04B09DE4 		ldr	fp, [sp], #4
 181              		.cfi_restore 11
 182              		.cfi_def_cfa_offset 0
 183 0064 1EFF2FE1 		bx	lr
 184              		.cfi_endproc
 185              	.LFE7:
 187              		.section	.text.byte_fifo_put,"ax",%progbits
 188              		.align	2
 189              		.syntax unified
 190              		.arm
 192              	byte_fifo_put:
 193              	.LFB8:
  53:trace32/../lib/byte_fifo.h **** 	
  54:trace32/../lib/byte_fifo.h **** static int byte_fifo_put(byte_fifo_t *fifo,unsigned char val)
  55:trace32/../lib/byte_fifo.h **** {
 194              		.loc 2 55 1
 195              		.cfi_startproc
 196              		@ Function supports interworking.
 197              		@ args = 0, pretend = 0, frame = 8
 198              		@ frame_needed = 1, uses_anonymous_args = 0
 199              		@ link register save eliminated.
 200 0000 04B02DE5 		str	fp, [sp, #-4]!
 201              		.cfi_def_cfa_offset 4
 202              		.cfi_offset 11, -4
 203 0004 00B08DE2 		add	fp, sp, #0
 204              		.cfi_def_cfa_register 11
 205 0008 0CD04DE2 		sub	sp, sp, #12
 206 000c 08000BE5 		str	r0, [fp, #-8]
 207 0010 0130A0E1 		mov	r3, r1
 208 0014 09304BE5 		strb	r3, [fp, #-9]
  56:trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
 209              		.loc 2 56 11
 210 0018 08301BE5 		ldr	r3, [fp, #-8]
 211 001c B230D3E1 		ldrh	r3, [r3, #2]
 212              		.loc 2 56 15
 213 0020 013083E2 		add	r3, r3, #1
 214              		.loc 2 56 24
 215 0024 08201BE5 		ldr	r2, [fp, #-8]
 216 0028 B420D2E1 		ldrh	r2, [r2, #4]
 217              		.loc 2 56 18
 218 002c 023003E0 		and	r3, r3, r2
 219              		.loc 2 56 40
 220 0030 08201BE5 		ldr	r2, [fp, #-8]
 221 0034 B020D2E1 		ldrh	r2, [r2]
 222              		.loc 2 56 4
 223 0038 020053E1 		cmp	r3, r2
 224 003c 0100001A 		bne	.L9
  57:trace32/../lib/byte_fifo.h **** 		return -1;
 225              		.loc 2 57 10
 226 0040 0030E0E3 		mvn	r3, #0
 227 0044 190000EA 		b	.L10
 228              	.L9:
  58:trace32/../lib/byte_fifo.h **** 	
  59:trace32/../lib/byte_fifo.h **** 	fifo->buf[fifo->wr]=val;
 229              		.loc 2 59 16
 230 0048 08301BE5 		ldr	r3, [fp, #-8]
 231 004c B230D3E1 		ldrh	r3, [r3, #2]
 232 0050 0320A0E1 		mov	r2, r3
 233              		.loc 2 59 21
 234 0054 08301BE5 		ldr	r3, [fp, #-8]
 235 0058 023083E0 		add	r3, r3, r2
 236 005c 09205BE5 		ldrb	r2, [fp, #-9]
 237 0060 0620C3E5 		strb	r2, [r3, #6]
  60:trace32/../lib/byte_fifo.h **** 	fifo->wr=(fifo->wr+1)&(fifo->mask);
 238              		.loc 2 60 16
 239 0064 08301BE5 		ldr	r3, [fp, #-8]
 240 0068 B230D3E1 		ldrh	r3, [r3, #2]
 241              		.loc 2 60 20
 242 006c 013083E2 		add	r3, r3, #1
 243 0070 0338A0E1 		lsl	r3, r3, #16
 244 0074 2338A0E1 		lsr	r3, r3, #16
 245 0078 0338A0E1 		lsl	r3, r3, #16
 246 007c 4328A0E1 		asr	r2, r3, #16
 247              		.loc 2 60 29
 248 0080 08301BE5 		ldr	r3, [fp, #-8]
 249 0084 B430D3E1 		ldrh	r3, [r3, #4]
 250 0088 0338A0E1 		lsl	r3, r3, #16
 251 008c 4338A0E1 		asr	r3, r3, #16
 252              		.loc 2 60 23
 253 0090 023003E0 		and	r3, r3, r2
 254 0094 0338A0E1 		lsl	r3, r3, #16
 255 0098 4338A0E1 		asr	r3, r3, #16
 256 009c 0338A0E1 		lsl	r3, r3, #16
 257 00a0 2328A0E1 		lsr	r2, r3, #16
 258              		.loc 2 60 10
 259 00a4 08301BE5 		ldr	r3, [fp, #-8]
 260 00a8 B220C3E1 		strh	r2, [r3, #2]	@ movhi
  61:trace32/../lib/byte_fifo.h **** 	return 0;
 261              		.loc 2 61 9
 262 00ac 0030A0E3 		mov	r3, #0
 263              	.L10:
  62:trace32/../lib/byte_fifo.h **** }
 264              		.loc 2 62 1
 265 00b0 0300A0E1 		mov	r0, r3
 266 00b4 00D08BE2 		add	sp, fp, #0
 267              		.cfi_def_cfa_register 13
 268              		@ sp needed
 269 00b8 04B09DE4 		ldr	fp, [sp], #4
 270              		.cfi_restore 11
 271              		.cfi_def_cfa_offset 0
 272 00bc 1EFF2FE1 		bx	lr
 273              		.cfi_endproc
 274              	.LFE8:
 276              		.section	.text.byte_fifo_get_possible,"ax",%progbits
 277              		.align	2
 278              		.syntax unified
 279              		.arm
 281              	byte_fifo_get_possible:
 282              	.LFB9:
  63:trace32/../lib/byte_fifo.h **** 
  64:trace32/../lib/byte_fifo.h **** static int byte_fifo_get_possible(byte_fifo_t *fifo)
  65:trace32/../lib/byte_fifo.h **** {
 283              		.loc 2 65 1
 284              		.cfi_startproc
 285              		@ Function supports interworking.
 286              		@ args = 0, pretend = 0, frame = 8
 287              		@ frame_needed = 1, uses_anonymous_args = 0
 288              		@ link register save eliminated.
 289 0000 04B02DE5 		str	fp, [sp, #-4]!
 290              		.cfi_def_cfa_offset 4
 291              		.cfi_offset 11, -4
 292 0004 00B08DE2 		add	fp, sp, #0
 293              		.cfi_def_cfa_register 11
 294 0008 0CD04DE2 		sub	sp, sp, #12
 295 000c 08000BE5 		str	r0, [fp, #-8]
  66:trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 296              		.loc 2 66 9
 297 0010 08301BE5 		ldr	r3, [fp, #-8]
 298 0014 B020D3E1 		ldrh	r2, [r3]
 299              		.loc 2 66 21
 300 0018 08301BE5 		ldr	r3, [fp, #-8]
 301 001c B230D3E1 		ldrh	r3, [r3, #2]
 302              		.loc 2 66 4
 303 0020 030052E1 		cmp	r2, r3
 304 0024 0100001A 		bne	.L12
  67:trace32/../lib/byte_fifo.h **** 		return -1;
 305              		.loc 2 67 10
 306 0028 0030E0E3 		mvn	r3, #0
 307 002c 000000EA 		b	.L13
 308              	.L12:
  68:trace32/../lib/byte_fifo.h **** 		
  69:trace32/../lib/byte_fifo.h **** 	return 0;
 309              		.loc 2 69 9
 310 0030 0030A0E3 		mov	r3, #0
 311              	.L13:
  70:trace32/../lib/byte_fifo.h **** }
 312              		.loc 2 70 1
 313 0034 0300A0E1 		mov	r0, r3
 314 0038 00D08BE2 		add	sp, fp, #0
 315              		.cfi_def_cfa_register 13
 316              		@ sp needed
 317 003c 04B09DE4 		ldr	fp, [sp], #4
 318              		.cfi_restore 11
 319              		.cfi_def_cfa_offset 0
 320 0040 1EFF2FE1 		bx	lr
 321              		.cfi_endproc
 322              	.LFE9:
 324              		.section	.text.byte_fifo_get,"ax",%progbits
 325              		.align	2
 326              		.syntax unified
 327              		.arm
 329              	byte_fifo_get:
 330              	.LFB10:
  71:trace32/../lib/byte_fifo.h **** 
  72:trace32/../lib/byte_fifo.h **** static int byte_fifo_get(byte_fifo_t *fifo,unsigned char *val)
  73:trace32/../lib/byte_fifo.h **** {
 331              		.loc 2 73 1
 332              		.cfi_startproc
 333              		@ Function supports interworking.
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 1, uses_anonymous_args = 0
 336              		@ link register save eliminated.
 337 0000 04B02DE5 		str	fp, [sp, #-4]!
 338              		.cfi_def_cfa_offset 4
 339              		.cfi_offset 11, -4
 340 0004 00B08DE2 		add	fp, sp, #0
 341              		.cfi_def_cfa_register 11
 342 0008 0CD04DE2 		sub	sp, sp, #12
 343 000c 08000BE5 		str	r0, [fp, #-8]
 344 0010 0C100BE5 		str	r1, [fp, #-12]
  74:trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 345              		.loc 2 74 9
 346 0014 08301BE5 		ldr	r3, [fp, #-8]
 347 0018 B020D3E1 		ldrh	r2, [r3]
 348              		.loc 2 74 21
 349 001c 08301BE5 		ldr	r3, [fp, #-8]
 350 0020 B230D3E1 		ldrh	r3, [r3, #2]
 351              		.loc 2 74 4
 352 0024 030052E1 		cmp	r2, r3
 353 0028 0100001A 		bne	.L15
  75:trace32/../lib/byte_fifo.h **** 		return -1;
 354              		.loc 2 75 10
 355 002c 0030E0E3 		mvn	r3, #0
 356 0030 1A0000EA 		b	.L16
 357              	.L15:
  76:trace32/../lib/byte_fifo.h **** 		
  77:trace32/../lib/byte_fifo.h **** 	*val=fifo->buf[fifo->rd];
 358              		.loc 2 77 21
 359 0034 08301BE5 		ldr	r3, [fp, #-8]
 360 0038 B030D3E1 		ldrh	r3, [r3]
 361 003c 0320A0E1 		mov	r2, r3
 362              		.loc 2 77 16
 363 0040 08301BE5 		ldr	r3, [fp, #-8]
 364 0044 023083E0 		add	r3, r3, r2
 365 0048 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 366              		.loc 2 77 6
 367 004c 0C301BE5 		ldr	r3, [fp, #-12]
 368 0050 0020C3E5 		strb	r2, [r3]
  78:trace32/../lib/byte_fifo.h **** 	fifo->rd=(fifo->rd+1)&(fifo->mask);
 369              		.loc 2 78 16
 370 0054 08301BE5 		ldr	r3, [fp, #-8]
 371 0058 B030D3E1 		ldrh	r3, [r3]
 372              		.loc 2 78 20
 373 005c 013083E2 		add	r3, r3, #1
 374 0060 0338A0E1 		lsl	r3, r3, #16
 375 0064 2338A0E1 		lsr	r3, r3, #16
 376 0068 0338A0E1 		lsl	r3, r3, #16
 377 006c 4328A0E1 		asr	r2, r3, #16
 378              		.loc 2 78 29
 379 0070 08301BE5 		ldr	r3, [fp, #-8]
 380 0074 B430D3E1 		ldrh	r3, [r3, #4]
 381 0078 0338A0E1 		lsl	r3, r3, #16
 382 007c 4338A0E1 		asr	r3, r3, #16
 383              		.loc 2 78 23
 384 0080 023003E0 		and	r3, r3, r2
 385 0084 0338A0E1 		lsl	r3, r3, #16
 386 0088 4338A0E1 		asr	r3, r3, #16
 387 008c 0338A0E1 		lsl	r3, r3, #16
 388 0090 2328A0E1 		lsr	r2, r3, #16
 389              		.loc 2 78 10
 390 0094 08301BE5 		ldr	r3, [fp, #-8]
 391 0098 B020C3E1 		strh	r2, [r3]	@ movhi
  79:trace32/../lib/byte_fifo.h **** 	return 0;
 392              		.loc 2 79 9
 393 009c 0030A0E3 		mov	r3, #0
 394              	.L16:
  80:trace32/../lib/byte_fifo.h **** }
 395              		.loc 2 80 1
 396 00a0 0300A0E1 		mov	r0, r3
 397 00a4 00D08BE2 		add	sp, fp, #0
 398              		.cfi_def_cfa_register 13
 399              		@ sp needed
 400 00a8 04B09DE4 		ldr	fp, [sp], #4
 401              		.cfi_restore 11
 402              		.cfi_def_cfa_offset 0
 403 00ac 1EFF2FE1 		bx	lr
 404              		.cfi_endproc
 405              	.LFE10:
 407              		.section	.text.byte_fifo_cb_put_possible,"ax",%progbits
 408              		.align	2
 409              		.syntax unified
 410              		.arm
 412              	byte_fifo_cb_put_possible:
 413              	.LFB11:
 414              		.file 3 "trace32/../lib/byte_fifo_cb.h"
   1:trace32/../lib/byte_fifo_cb.h **** /* Byte FIFO with CallBack
   2:trace32/../lib/byte_fifo_cb.h ****  *
   3:trace32/../lib/byte_fifo_cb.h ****  * Appends the Byte_Fifo with a callback function, which is called
   4:trace32/../lib/byte_fifo_cb.h ****  * when putting some stuff into the fifo (e.g. Enable transmitting interrupt)
   5:trace32/../lib/byte_fifo_cb.h ****  */
   6:trace32/../lib/byte_fifo_cb.h **** 
   7:trace32/../lib/byte_fifo_cb.h **** #ifndef __BYTE_FIFO_CB_H__
   8:trace32/../lib/byte_fifo_cb.h **** #define __BYTE_FIFO_CB_H__
   9:trace32/../lib/byte_fifo_cb.h **** 
  10:trace32/../lib/byte_fifo_cb.h **** #include "byte_fifo.h"
  11:trace32/../lib/byte_fifo_cb.h **** 
  12:trace32/../lib/byte_fifo_cb.h **** typedef void (*byte_fifo_cb)(void);
  13:trace32/../lib/byte_fifo_cb.h **** 
  14:trace32/../lib/byte_fifo_cb.h **** typedef struct {
  15:trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_cb cb;
  16:trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_t  byte_fifo; //Aufgrund des Flexible Array Member hier hinter keine weiteren Strukturel
  17:trace32/../lib/byte_fifo_cb.h **** } byte_fifo_cb_t;
  18:trace32/../lib/byte_fifo_cb.h **** 
  19:trace32/../lib/byte_fifo_cb.h **** #define BYTE_FIFO_CB_INIT(size,func)  (byte_fifo_cb_t) {.cb=func, \
  20:trace32/../lib/byte_fifo_cb.h ****                                                         .byte_fifo=BYTE_FIFO_INIT(size) \
  21:trace32/../lib/byte_fifo_cb.h **** 									    			   }
  22:trace32/../lib/byte_fifo_cb.h **** 
  23:trace32/../lib/byte_fifo_cb.h **** size_t byte_fifo_cb_putsize(byte_fifo_cb_t *fifo,const unsigned char *start,size_t len);
  24:trace32/../lib/byte_fifo_cb.h **** 
  25:trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic push
  26:trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  27:trace32/../lib/byte_fifo_cb.h **** 
  28:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put_possible(byte_fifo_cb_t *fifo)
  29:trace32/../lib/byte_fifo_cb.h **** {
 415              		.loc 3 29 1
 416              		.cfi_startproc
 417              		@ Function supports interworking.
 418              		@ args = 0, pretend = 0, frame = 8
 419              		@ frame_needed = 1, uses_anonymous_args = 0
 420 0000 00482DE9 		push	{fp, lr}
 421              		.cfi_def_cfa_offset 8
 422              		.cfi_offset 11, -8
 423              		.cfi_offset 14, -4
 424 0004 04B08DE2 		add	fp, sp, #4
 425              		.cfi_def_cfa 11, 4
 426 0008 08D04DE2 		sub	sp, sp, #8
 427 000c 08000BE5 		str	r0, [fp, #-8]
  30:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_put_possible(&fifo->byte_fifo);
 428              		.loc 3 30 9
 429 0010 08301BE5 		ldr	r3, [fp, #-8]
 430 0014 043083E2 		add	r3, r3, #4
 431 0018 0300A0E1 		mov	r0, r3
 432 001c 18309FE5 		ldr	r3, .L19
 433 0020 0FE0A0E1 		mov	lr, pc
 434 0024 13FF2FE1 		bx	r3
 435              	.LVL0:
 436 0028 0030A0E1 		mov	r3, r0
  31:trace32/../lib/byte_fifo_cb.h **** }
 437              		.loc 3 31 1
 438 002c 0300A0E1 		mov	r0, r3
 439 0030 04D04BE2 		sub	sp, fp, #4
 440              		.cfi_def_cfa 13, 8
 441              		@ sp needed
 442 0034 0048BDE8 		pop	{fp, lr}
 443              		.cfi_restore 14
 444              		.cfi_restore 11
 445              		.cfi_def_cfa_offset 0
 446 0038 1EFF2FE1 		bx	lr
 447              	.L20:
 448              		.align	2
 449              	.L19:
 450 003c 00000000 		.word	byte_fifo_put_possible
 451              		.cfi_endproc
 452              	.LFE11:
 454              		.section	.text.byte_fifo_cb_put,"ax",%progbits
 455              		.align	2
 456              		.syntax unified
 457              		.arm
 459              	byte_fifo_cb_put:
 460              	.LFB12:
  32:trace32/../lib/byte_fifo_cb.h **** 	
  33:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put(byte_fifo_cb_t *fifo,unsigned char val)
  34:trace32/../lib/byte_fifo_cb.h **** {
 461              		.loc 3 34 1
 462              		.cfi_startproc
 463              		@ Function supports interworking.
 464              		@ args = 0, pretend = 0, frame = 16
 465              		@ frame_needed = 1, uses_anonymous_args = 0
 466 0000 00482DE9 		push	{fp, lr}
 467              		.cfi_def_cfa_offset 8
 468              		.cfi_offset 11, -8
 469              		.cfi_offset 14, -4
 470 0004 04B08DE2 		add	fp, sp, #4
 471              		.cfi_def_cfa 11, 4
 472 0008 10D04DE2 		sub	sp, sp, #16
 473 000c 10000BE5 		str	r0, [fp, #-16]
 474 0010 0130A0E1 		mov	r3, r1
 475 0014 11304BE5 		strb	r3, [fp, #-17]
  35:trace32/../lib/byte_fifo_cb.h **** 	int ret=byte_fifo_put(&fifo->byte_fifo,val);
 476              		.loc 3 35 10
 477 0018 10301BE5 		ldr	r3, [fp, #-16]
 478 001c 043083E2 		add	r3, r3, #4
 479 0020 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 480 0024 0210A0E1 		mov	r1, r2
 481 0028 0300A0E1 		mov	r0, r3
 482 002c 48309FE5 		ldr	r3, .L24
 483 0030 0FE0A0E1 		mov	lr, pc
 484 0034 13FF2FE1 		bx	r3
 485              	.LVL1:
 486 0038 08000BE5 		str	r0, [fp, #-8]
  36:trace32/../lib/byte_fifo_cb.h **** 	if( !ret && fifo->cb)
 487              		.loc 3 36 4
 488 003c 08301BE5 		ldr	r3, [fp, #-8]
 489 0040 000053E3 		cmp	r3, #0
 490 0044 0700001A 		bne	.L22
 491              		.loc 3 36 18 discriminator 1
 492 0048 10301BE5 		ldr	r3, [fp, #-16]
 493 004c 003093E5 		ldr	r3, [r3]
 494              		.loc 3 36 11 discriminator 1
 495 0050 000053E3 		cmp	r3, #0
 496 0054 0300000A 		beq	.L22
  37:trace32/../lib/byte_fifo_cb.h **** 		fifo->cb();
 497              		.loc 3 37 7
 498 0058 10301BE5 		ldr	r3, [fp, #-16]
 499 005c 003093E5 		ldr	r3, [r3]
 500              		.loc 3 37 3
 501 0060 0FE0A0E1 		mov	lr, pc
 502 0064 13FF2FE1 		bx	r3
 503              	.LVL2:
 504              	.L22:
  38:trace32/../lib/byte_fifo_cb.h **** 	return ret;
 505              		.loc 3 38 9
 506 0068 08301BE5 		ldr	r3, [fp, #-8]
  39:trace32/../lib/byte_fifo_cb.h **** }
 507              		.loc 3 39 1
 508 006c 0300A0E1 		mov	r0, r3
 509 0070 04D04BE2 		sub	sp, fp, #4
 510              		.cfi_def_cfa 13, 8
 511              		@ sp needed
 512 0074 0048BDE8 		pop	{fp, lr}
 513              		.cfi_restore 14
 514              		.cfi_restore 11
 515              		.cfi_def_cfa_offset 0
 516 0078 1EFF2FE1 		bx	lr
 517              	.L25:
 518              		.align	2
 519              	.L24:
 520 007c 00000000 		.word	byte_fifo_put
 521              		.cfi_endproc
 522              	.LFE12:
 524              		.section	.text.byte_fifo_cb_get_possible,"ax",%progbits
 525              		.align	2
 526              		.syntax unified
 527              		.arm
 529              	byte_fifo_cb_get_possible:
 530              	.LFB13:
  40:trace32/../lib/byte_fifo_cb.h **** 
  41:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get_possible(byte_fifo_cb_t *fifo)
  42:trace32/../lib/byte_fifo_cb.h **** {
 531              		.loc 3 42 1
 532              		.cfi_startproc
 533              		@ Function supports interworking.
 534              		@ args = 0, pretend = 0, frame = 8
 535              		@ frame_needed = 1, uses_anonymous_args = 0
 536 0000 00482DE9 		push	{fp, lr}
 537              		.cfi_def_cfa_offset 8
 538              		.cfi_offset 11, -8
 539              		.cfi_offset 14, -4
 540 0004 04B08DE2 		add	fp, sp, #4
 541              		.cfi_def_cfa 11, 4
 542 0008 08D04DE2 		sub	sp, sp, #8
 543 000c 08000BE5 		str	r0, [fp, #-8]
  43:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get_possible(&fifo->byte_fifo);
 544              		.loc 3 43 9
 545 0010 08301BE5 		ldr	r3, [fp, #-8]
 546 0014 043083E2 		add	r3, r3, #4
 547 0018 0300A0E1 		mov	r0, r3
 548 001c 18309FE5 		ldr	r3, .L28
 549 0020 0FE0A0E1 		mov	lr, pc
 550 0024 13FF2FE1 		bx	r3
 551              	.LVL3:
 552 0028 0030A0E1 		mov	r3, r0
  44:trace32/../lib/byte_fifo_cb.h **** }
 553              		.loc 3 44 1
 554 002c 0300A0E1 		mov	r0, r3
 555 0030 04D04BE2 		sub	sp, fp, #4
 556              		.cfi_def_cfa 13, 8
 557              		@ sp needed
 558 0034 0048BDE8 		pop	{fp, lr}
 559              		.cfi_restore 14
 560              		.cfi_restore 11
 561              		.cfi_def_cfa_offset 0
 562 0038 1EFF2FE1 		bx	lr
 563              	.L29:
 564              		.align	2
 565              	.L28:
 566 003c 00000000 		.word	byte_fifo_get_possible
 567              		.cfi_endproc
 568              	.LFE13:
 570              		.section	.text.byte_fifo_cb_get,"ax",%progbits
 571              		.align	2
 572              		.syntax unified
 573              		.arm
 575              	byte_fifo_cb_get:
 576              	.LFB14:
  45:trace32/../lib/byte_fifo_cb.h **** 
  46:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get(byte_fifo_cb_t *fifo,unsigned char *val)
  47:trace32/../lib/byte_fifo_cb.h **** {
 577              		.loc 3 47 1
 578              		.cfi_startproc
 579              		@ Function supports interworking.
 580              		@ args = 0, pretend = 0, frame = 8
 581              		@ frame_needed = 1, uses_anonymous_args = 0
 582 0000 00482DE9 		push	{fp, lr}
 583              		.cfi_def_cfa_offset 8
 584              		.cfi_offset 11, -8
 585              		.cfi_offset 14, -4
 586 0004 04B08DE2 		add	fp, sp, #4
 587              		.cfi_def_cfa 11, 4
 588 0008 08D04DE2 		sub	sp, sp, #8
 589 000c 08000BE5 		str	r0, [fp, #-8]
 590 0010 0C100BE5 		str	r1, [fp, #-12]
  48:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get(&fifo->byte_fifo,val);
 591              		.loc 3 48 9
 592 0014 08301BE5 		ldr	r3, [fp, #-8]
 593 0018 043083E2 		add	r3, r3, #4
 594 001c 0C101BE5 		ldr	r1, [fp, #-12]
 595 0020 0300A0E1 		mov	r0, r3
 596 0024 18309FE5 		ldr	r3, .L32
 597 0028 0FE0A0E1 		mov	lr, pc
 598 002c 13FF2FE1 		bx	r3
 599              	.LVL4:
 600 0030 0030A0E1 		mov	r3, r0
  49:trace32/../lib/byte_fifo_cb.h **** }
 601              		.loc 3 49 1
 602 0034 0300A0E1 		mov	r0, r3
 603 0038 04D04BE2 		sub	sp, fp, #4
 604              		.cfi_def_cfa 13, 8
 605              		@ sp needed
 606 003c 0048BDE8 		pop	{fp, lr}
 607              		.cfi_restore 14
 608              		.cfi_restore 11
 609              		.cfi_def_cfa_offset 0
 610 0040 1EFF2FE1 		bx	lr
 611              	.L33:
 612              		.align	2
 613              	.L32:
 614 0044 00000000 		.word	byte_fifo_get
 615              		.cfi_endproc
 616              	.LFE14:
 618              		.global	main_data
 619              		.bss
 620              		.align	2
 623              	main_data:
 624 0000 000000   		.space	3
 625              		.section	.text._exit,"ax",%progbits
 626              		.align	2
 627              		.global	_exit
 628              		.syntax unified
 629              		.arm
 631              	_exit:
 632              	.LFB15:
   1:main.c        **** #include <math.h>
   2:main.c        **** #include <stdint.h>
   3:main.c        **** #include <stdio.h>
   4:main.c        **** #include <string.h>
   5:main.c        **** #include <unistd.h> //fuer _exit()
   6:main.c        **** 
   7:main.c        **** #include "AT91SAM7S64.h"
   8:main.c        **** #include "lib/aic.h"
   9:main.c        **** #include "lib/display.h"
  10:main.c        **** #include "lib/nxt_avr.h"
  11:main.c        **** #include "lib/systick.h"
  12:main.c        **** #include "lib/term.h"
  13:main.c        **** #include "main.h"
  14:main.c        **** // #include "lib/adc.h"
  15:main.c        **** #if defined(MODE_RAM) || defined(MODE_SIM)
  16:main.c        **** #include "trace32/udmon3.h"
  17:main.c        **** #endif
  18:main.c        **** 
  19:main.c        **** #define ZYKLUS_MS 2
  20:main.c        **** #define IDLE_MS 1
  21:main.c        **** 
  22:main.c        **** #if IDLE_MS >= ZYKLUS_MS
  23:main.c        **** #error "Idle_ms muss kleiner als zyklus_ms sein"
  24:main.c        **** #endif
  25:main.c        **** 
  26:main.c        **** /*****************************************************************************/
  27:main.c        **** /*   Globale Variablen                                                       */
  28:main.c        **** /*****************************************************************************/
  29:main.c        **** struct {
  30:main.c        ****   signed char term_status; // 0->false->Alles Bestens   -1->true->Overflow
  31:main.c        ****   unsigned char term_cnt;
  32:main.c        ****   unsigned char lowbat_cnt;
  33:main.c        **** } main_data = {
  34:main.c        ****     .term_status = 0,
  35:main.c        ****     .term_cnt = 0,
  36:main.c        ****     .lowbat_cnt = 0,
  37:main.c        **** };
  38:main.c        **** 
  39:main.c        **** /*****************************************************************************/
  40:main.c        **** /*   Hilfsroutinen                                                           */
  41:main.c        **** /*   Standard-C-Library (weitere befinden sich in newlib_syscalls.c)         */
  42:main.c        **** /*****************************************************************************/
  43:main.c        **** // Routine wird von C-Lib aufgerufen (bspw. printf() abort())
  44:main.c        **** void _exit(int status) {
 633              		.loc 1 44 24
 634              		.cfi_startproc
 635              		@ Function supports interworking.
 636              		@ args = 0, pretend = 0, frame = 8
 637              		@ frame_needed = 1, uses_anonymous_args = 0
 638              		@ link register save eliminated.
 639 0000 04B02DE5 		str	fp, [sp, #-4]!
 640              		.cfi_def_cfa_offset 4
 641              		.cfi_offset 11, -4
 642 0004 00B08DE2 		add	fp, sp, #0
 643              		.cfi_def_cfa_register 11
 644 0008 0CD04DE2 		sub	sp, sp, #12
 645 000c 08000BE5 		str	r0, [fp, #-8]
 646              	.L35:
  45:main.c        ****   (void)status;
  46:main.c        ****   // LED-Blinken lassen
  47:main.c        ****   // Breakpoint setzen
  48:main.c        ****   while (1)
 647              		.loc 1 48 9
 648 0010 0000A0E1 		nop
 649 0014 FDFFFFEA 		b	.L35
 650              		.cfi_endproc
 651              	.LFE15:
 653              		.global	trace_buf0
 654              		.bss
 655 0003 00       		.align	2
 658              	trace_buf0:
 659 0004 00000000 		.space	400
 659      00000000 
 659      00000000 
 659      00000000 
 659      00000000 
 660              		.global	trace_buf1
 661              		.align	2
 664              	trace_buf1:
 665 0194 00000000 		.space	400
 665      00000000 
 665      00000000 
 665      00000000 
 665      00000000 
 666              		.section	.text.trace_scope,"ax",%progbits
 667              		.align	2
 668              		.global	trace_scope
 669              		.syntax unified
 670              		.arm
 672              	trace_scope:
 673              	.LFB16:
  49:main.c        ****     ;
  50:main.c        **** }
  51:main.c        **** 
  52:main.c        **** /************************************************************************/
  53:main.c        **** /*   Hilfsroutine zur Darstellung eines analogen Verlaufes entsprechend */
  54:main.c        **** /*   einem Oszillosop                                                   */
  55:main.c        **** /************************************************************************/
  56:main.c        **** #define TRACE_SIZE 200
  57:main.c        **** int16_t trace_buf0[TRACE_SIZE];
  58:main.c        **** int16_t trace_buf1[TRACE_SIZE];
  59:main.c        **** // Darstellung des Puffers über 'v.draw %e trace_buf0 trace_buf1'
  60:main.c        **** void trace_scope(int channel, int16_t value) {
 674              		.loc 1 60 46
 675              		.cfi_startproc
 676              		@ Function supports interworking.
 677              		@ args = 0, pretend = 0, frame = 8
 678              		@ frame_needed = 1, uses_anonymous_args = 0
 679              		@ link register save eliminated.
 680 0000 04B02DE5 		str	fp, [sp, #-4]!
 681              		.cfi_def_cfa_offset 4
 682              		.cfi_offset 11, -4
 683 0004 00B08DE2 		add	fp, sp, #0
 684              		.cfi_def_cfa_register 11
 685 0008 0CD04DE2 		sub	sp, sp, #12
 686 000c 08000BE5 		str	r0, [fp, #-8]
 687 0010 0130A0E1 		mov	r3, r1
 688 0014 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
  61:main.c        ****   // #define TRACE_ROLL
  62:main.c        **** #ifdef TRACE_ROLL
  63:main.c        ****   if (channel == 0) {
  64:main.c        ****     for (int lauf = 0; lauf < (TRACE_SIZE - 1); lauf++)
  65:main.c        ****       trace_buf0[lauf] = trace_buf0[lauf + 1];
  66:main.c        ****     trace_buf0[TRACE_SIZE - 1] = value;
  67:main.c        ****   } else {
  68:main.c        ****     for (int lauf = 0; lauf < (TRACE_SIZE - 1); lauf++)
  69:main.c        ****       trace_buf1[lauf] = trace_buf1[lauf + 1];
  70:main.c        ****     trace_buf1[TRACE_SIZE - 1] = value;
  71:main.c        ****   }
  72:main.c        **** #else
  73:main.c        ****   static int trace_index = 0;
  74:main.c        ****   if (trace_index < TRACE_SIZE) {
 689              		.loc 1 74 19
 690 0018 A8309FE5 		ldr	r3, .L43
 691 001c 003093E5 		ldr	r3, [r3]
 692              		.loc 1 74 6
 693 0020 C70053E3 		cmp	r3, #199
 694 0024 110000CA 		bgt	.L37
  75:main.c        ****     if (channel == 0)
 695              		.loc 1 75 8
 696 0028 08301BE5 		ldr	r3, [fp, #-8]
 697 002c 000053E3 		cmp	r3, #0
 698 0030 0700001A 		bne	.L38
  76:main.c        ****       trace_buf0[trace_index] = value;
 699              		.loc 1 76 17
 700 0034 8C309FE5 		ldr	r3, .L43
 701 0038 003093E5 		ldr	r3, [r3]
 702              		.loc 1 76 31
 703 003c 88209FE5 		ldr	r2, .L43+4
 704 0040 8330A0E1 		lsl	r3, r3, #1
 705 0044 033082E0 		add	r3, r2, r3
 706 0048 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 707 004c B020C3E1 		strh	r2, [r3]	@ movhi
 708 0050 060000EA 		b	.L37
 709              	.L38:
  77:main.c        ****     else
  78:main.c        ****       trace_buf1[trace_index] = value;
 710              		.loc 1 78 17
 711 0054 6C309FE5 		ldr	r3, .L43
 712 0058 003093E5 		ldr	r3, [r3]
 713              		.loc 1 78 31
 714 005c 6C209FE5 		ldr	r2, .L43+8
 715 0060 8330A0E1 		lsl	r3, r3, #1
 716 0064 033082E0 		add	r3, r2, r3
 717 0068 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 718 006c B020C3E1 		strh	r2, [r3]	@ movhi
 719              	.L37:
  79:main.c        ****   } else {
  80:main.c        ****     // Pause, damit der Debugger in 'Ruhe' den gesamten Speicher auslesen kann
  81:main.c        ****   }
  82:main.c        ****   if (channel == 1) {
 720              		.loc 1 82 6
 721 0070 08301BE5 		ldr	r3, [fp, #-8]
 722 0074 010053E3 		cmp	r3, #1
 723 0078 0E00001A 		bne	.L42
  83:main.c        ****     trace_index++;
 724              		.loc 1 83 16
 725 007c 44309FE5 		ldr	r3, .L43
 726 0080 003093E5 		ldr	r3, [r3]
 727 0084 013083E2 		add	r3, r3, #1
 728 0088 38209FE5 		ldr	r2, .L43
 729 008c 003082E5 		str	r3, [r2]
  84:main.c        ****     trace_index = trace_index >= (3 * TRACE_SIZE) ? 0 : trace_index;
 730              		.loc 1 84 31
 731 0090 30309FE5 		ldr	r3, .L43
 732 0094 003093E5 		ldr	r3, [r3]
 733              		.loc 1 84 55
 734 0098 960F53E3 		cmp	r3, #600
 735 009c 020000AA 		bge	.L40
 736              		.loc 1 84 55 is_stmt 0 discriminator 1
 737 00a0 20309FE5 		ldr	r3, .L43
 738 00a4 003093E5 		ldr	r3, [r3]
 739 00a8 000000EA 		b	.L41
 740              	.L40:
 741              		.loc 1 84 55 discriminator 2
 742 00ac 0030A0E3 		mov	r3, #0
 743              	.L41:
 744              		.loc 1 84 17 is_stmt 1 discriminator 4
 745 00b0 10209FE5 		ldr	r2, .L43
 746 00b4 003082E5 		str	r3, [r2]
 747              	.L42:
  85:main.c        ****   }
  86:main.c        **** #endif
  87:main.c        **** }
 748              		.loc 1 87 1
 749 00b8 0000A0E1 		nop
 750 00bc 00D08BE2 		add	sp, fp, #0
 751              		.cfi_def_cfa_register 13
 752              		@ sp needed
 753 00c0 04B09DE4 		ldr	fp, [sp], #4
 754              		.cfi_restore 11
 755              		.cfi_def_cfa_offset 0
 756 00c4 1EFF2FE1 		bx	lr
 757              	.L44:
 758              		.align	2
 759              	.L43:
 760 00c8 24030000 		.word	trace_index.3
 761 00cc 00000000 		.word	trace_buf0
 762 00d0 00000000 		.word	trace_buf1
 763              		.cfi_endproc
 764              	.LFE16:
 766              		.global	pio
 767              		.data
 768              		.align	2
 771              	pio:
 772 0000 00F4FFFF 		.word	-3072
 773              		.global	pmc
 774              		.align	2
 777              	pmc:
 778 0004 00FCFFFF 		.word	-1024
 779              		.global	pwm_ctl
 780              		.align	2
 783              	pwm_ctl:
 784 0008 00C0FCFF 		.word	-212992
 785              		.global	schritt_mode2str
 786              		.section	.rodata
 787              		.align	2
 788              	.LC0:
 789 0000 566F6C6C 		.ascii	"Vollschritt 1\000"
 789      73636872 
 789      69747420 
 789      3100
 790 000e 0000     		.align	2
 791              	.LC1:
 792 0010 566F6C6C 		.ascii	"Vollschritt 2\000"
 792      73636872 
 792      69747420 
 792      3200
 793 001e 0000     		.align	2
 794              	.LC2:
 795 0020 48616C62 		.ascii	"Halbschritt\000"
 795      73636872 
 795      69747400 
 796              		.align	2
 797              	.LC3:
 798 002c 53696E75 		.ascii	"SinusSchritt\000"
 798      73536368 
 798      72697474 
 798      00
 799              		.data
 800              		.align	2
 803              	schritt_mode2str:
 804 000c 00000000 		.word	.LC0
 805 0010 10000000 		.word	.LC1
 806 0014 20000000 		.word	.LC2
 807 0018 2C000000 		.word	.LC3
 808              		.global	schrittmotor_data
 809 001c 00000000 		.align	3
 812              	schrittmotor_data:
 813 0020 00       		.space	1
 814 0021 00       		.byte	0
 815 0022 00       		.byte	0
 816 0023 00       		.byte	0
 817 0024 00       		.byte	0
 818 0025 000000   		.space	3
 819 0028 00000000 		.word	0
 820 002c 00       		.byte	0
 821 002d 00       		.space	1
 822 002e 0001     		.short	256
 823 0030 8000     		.short	128
 824 0032 4000     		.short	64
 825 0034 2000     		.short	32
 826 0036 0100     		.short	1
 827 0038 0000     		.short	0
 828 003a 0000     		.short	0
 829 003c 00000000 		.space	388
 829      00000000 
 829      00000000 
 829      00000000 
 829      00000000 
 830 01c0 01000000 		.word	1
 831 01c4 4A120000 		.word	4682
 832 01c8 E0230000 		.word	9184
 833 01cc 16340000 		.word	13334
 834 01d0 4B420000 		.word	16971
 835 01d4 F34D0000 		.word	19955
 836 01d8 9D560000 		.word	22173
 837 01dc F35B0000 		.word	23539
 838 01e0 BF5D0000 		.word	23999
 839 01e4 F35B0000 		.word	23539
 840 01e8 9D560000 		.word	22173
 841 01ec F34D0000 		.word	19955
 842 01f0 4B420000 		.word	16971
 843 01f4 16340000 		.word	13334
 844 01f8 E0230000 		.word	9184
 845 01fc 4A120000 		.word	4682
 846 0200 01000000 		.word	1
 847 0204 B6EDFFFF 		.word	-4682
 848 0208 20DCFFFF 		.word	-9184
 849 020c EACBFFFF 		.word	-13334
 850 0210 B5BDFFFF 		.word	-16971
 851 0214 0DB2FFFF 		.word	-19955
 852 0218 63A9FFFF 		.word	-22173
 853 021c 0DA4FFFF 		.word	-23539
 854 0220 41A2FFFF 		.word	-23999
 855 0224 0DA4FFFF 		.word	-23539
 856 0228 63A9FFFF 		.word	-22173
 857 022c 0DB2FFFF 		.word	-19955
 858 0230 B5BDFFFF 		.word	-16971
 859 0234 EACBFFFF 		.word	-13334
 860 0238 20DCFFFF 		.word	-9184
 861 023c B6EDFFFF 		.word	-4682
 862 0240 01       		.byte	1
 863 0241 00000000 		.space	7
 863      000000
 864              		.section	.text.schrittmotor_init,"ax",%progbits
 865              		.align	2
 866              		.global	schrittmotor_init
 867              		.syntax unified
 868              		.arm
 870              	schrittmotor_init:
 871              	.LFB17:
  88:main.c        **** 
  89:main.c        **** /*****************************************************************************/
  90:main.c        **** /*   Ihr Programm                                                            */
  91:main.c        **** /*****************************************************************************/
  92:main.c        **** // AT91S_PIO, *AT91PS_PIO
  93:main.c        **** #define SPULE1_PWM (1 << 23)
  94:main.c        **** #define SPULE2_PWM (1 << 2)
  95:main.c        **** #define SPULE1_DIR (1 << 18)
  96:main.c        **** #define SPULE2_DIR (1 << 30)
  97:main.c        **** #define NXT_PORT4_ENABLE (1 << 7)
  98:main.c        **** #define ALL                                                                    \
  99:main.c        ****   (SPULE1_DIR | SPULE2_DIR | SPULE1_PWM | SPULE2_PWM | NXT_PORT4_ENABLE)
 100:main.c        **** #define SPULE1_PWM_BASE AT91C_BASE_PWMC_CH2
 101:main.c        **** #define SPULE2_PWM_BASE AT91C_BASE_PWMC_CH0
 102:main.c        **** 
 103:main.c        **** #define PA30 SPULE2_DIR
 104:main.c        **** #define PA2  SPULE2_PWM
 105:main.c        **** #define PA18 SPULE1_DIR
 106:main.c        **** #define PA23 SPULE1_PWM
 107:main.c        **** #define PA7 NXT_PORT4_ENABLE
 108:main.c        **** 
 109:main.c        **** #define MASK_FULL1   3
 110:main.c        **** #define MASK_FULL2   3
 111:main.c        **** #define MASK_HALF    7
 112:main.c        **** #define MASK_MICRO   31
 113:main.c        **** 
 114:main.c        **** #define PWM_FREQ_HZ   2000
 115:main.c        **** #define MCK_HZ        48000000
 116:main.c        **** #define CPRD_2KHZ     (MCK_HZ / PWM_FREQ_HZ) // = 24000 
 117:main.c        **** #define STEPS_MICRO   32
 118:main.c        **** 
 119:main.c        **** 
 120:main.c        **** 
 121:main.c        **** AT91PS_PIO pio = (AT91PS_PIO)AT91C_BASE_PIOA;
 122:main.c        **** AT91PS_PMC pmc = (AT91PS_PMC)AT91C_BASE_PMC;
 123:main.c        **** AT91PS_PWMC pwm_ctl = (AT91PS_PWMC)AT91C_BASE_PWMC;
 124:main.c        **** 
 125:main.c        **** 
 126:main.c        **** typedef enum {
 127:main.c        ****   SCHRITT_VOLL_1,
 128:main.c        ****   SCHRITT_VOLL_2,
 129:main.c        ****   SCHRITT_HALB,
 130:main.c        ****   SCHRITT_SINUS,
 131:main.c        ****   SCHRITT_END
 132:main.c        **** } SCHRITT_MODE;
 133:main.c        **** typedef enum {
 134:main.c        ****   POSITION_MANUELL,
 135:main.c        ****   POSITION_KONTINUIERLICH,
 136:main.c        ****   POSITION_END
 137:main.c        **** } POSITION_MODE;
 138:main.c        **** const char *schritt_mode2str[] = {
 139:main.c        ****     [SCHRITT_VOLL_1] = "Vollschritt 1",
 140:main.c        ****     [SCHRITT_VOLL_2] = "Vollschritt 2",
 141:main.c        ****     [SCHRITT_HALB] = "Halbschritt",
 142:main.c        ****     [SCHRITT_SINUS] = "SinusSchritt",
 143:main.c        **** };
 144:main.c        **** 
 145:main.c        **** struct {
 146:main.c        ****   button_t button_old;
 147:main.c        ****   SCHRITT_MODE schritt_mode;
 148:main.c        ****   POSITION_MODE position_mode;
 149:main.c        ****   int8_t pos;
 150:main.c        ****   uint8_t speed;
 151:main.c        ****   uint32_t mode;
 152:main.c        ****   uint8_t step;
 153:main.c        ****   uint16_t reload_table[5];
 154:main.c        ****   uint16_t current_reload;
 155:main.c        ****   uint16_t counter;
 156:main.c        ****   double micro_sign[STEPS_MICRO];
 157:main.c        ****   uint32_t micro_duty[STEPS_MICRO];
 158:main.c        ****   int32_t micro[32];
 159:main.c        ****   int8_t dir;            
 160:main.c        **** 
 161:main.c        **** } schrittmotor_data = {
 162:main.c        ****     .schritt_mode = SCHRITT_VOLL_1,
 163:main.c        ****     .position_mode = POSITION_MANUELL,
 164:main.c        ****     .pos = 0,
 165:main.c        ****     .speed = 0,
 166:main.c        ****     .mode = 0,
 167:main.c        ****     .step = 0,
 168:main.c        ****     .current_reload = 0,
 169:main.c        ****     .dir = 1,
 170:main.c        ****     .counter = 0,
 171:main.c        ****     .reload_table = {
 172:main.c        ****       256, // speed 0 -> 256*4ms = 1024 ms 
 173:main.c        ****       128, // speed 1 -> 512 ms 
 174:main.c        ****       64, // speed 2 -> 256 ms 
 175:main.c        ****       32, // speed 3 -> 128 ms 
 176:main.c        ****       1  // speed 4 -> 4 ms 
 177:main.c        ****     },
 178:main.c        ****     .micro = {
 179:main.c        ****       1,
 180:main.c        ****       4682,
 181:main.c        ****       9184,
 182:main.c        ****       13334,
 183:main.c        ****       16971,
 184:main.c        ****       19955,
 185:main.c        ****       22173,
 186:main.c        ****       23539,
 187:main.c        ****       23999,
 188:main.c        ****       23539,
 189:main.c        ****       22173,
 190:main.c        ****       19955,
 191:main.c        ****       16971,
 192:main.c        ****       13334,
 193:main.c        ****       9184,
 194:main.c        ****       4682,
 195:main.c        ****       1,
 196:main.c        ****       -4682,
 197:main.c        ****       -9184,
 198:main.c        ****       -13334,
 199:main.c        ****       -16971,
 200:main.c        ****       -19955,
 201:main.c        ****       -22173,
 202:main.c        ****       -23539,
 203:main.c        ****       -23999,
 204:main.c        ****       -23539,
 205:main.c        ****       -22173,
 206:main.c        ****       -19955,
 207:main.c        ****       -16971,
 208:main.c        ****       -13334,
 209:main.c        ****       -9184,
 210:main.c        ****       -4682
 211:main.c        **** 
 212:main.c        ****     }
 213:main.c        **** }; 
 214:main.c        **** 
 215:main.c        **** 
 216:main.c        **** 
 217:main.c        **** void schrittmotor_init(SCHRITT_MODE mode) {
 872              		.loc 1 217 43
 873              		.cfi_startproc
 874              		@ Function supports interworking.
 875              		@ args = 0, pretend = 0, frame = 8
 876              		@ frame_needed = 1, uses_anonymous_args = 0
 877              		@ link register save eliminated.
 878 0000 04B02DE5 		str	fp, [sp, #-4]!
 879              		.cfi_def_cfa_offset 4
 880              		.cfi_offset 11, -4
 881 0004 00B08DE2 		add	fp, sp, #0
 882              		.cfi_def_cfa_register 11
 883 0008 0CD04DE2 		sub	sp, sp, #12
 884 000c 0030A0E1 		mov	r3, r0
 885 0010 05304BE5 		strb	r3, [fp, #-5]
 218:main.c        ****   schrittmotor_data.schritt_mode = mode;
 886              		.loc 1 218 34
 887 0014 84219FE5 		ldr	r2, .L49
 888 0018 05305BE5 		ldrb	r3, [fp, #-5]
 889 001c 0130C2E5 		strb	r3, [r2, #1]
 219:main.c        ****   if (mode != SCHRITT_SINUS) {
 890              		.loc 1 219 6
 891 0020 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 892 0024 030053E3 		cmp	r3, #3
 893 0028 1800000A 		beq	.L46
 220:main.c        ****     pmc->PMC_PCER = ((1 << 2) | (1 << 10));
 894              		.loc 1 220 8
 895 002c 70319FE5 		ldr	r3, .L49+4
 896 0030 003093E5 		ldr	r3, [r3]
 897              		.loc 1 220 19
 898 0034 6C219FE5 		ldr	r2, .L49+8
 899 0038 102083E5 		str	r2, [r3, #16]
 221:main.c        ****     pio->PIO_CODR = (1 << 7);
 900              		.loc 1 221 8
 901 003c 68319FE5 		ldr	r3, .L49+12
 902 0040 003093E5 		ldr	r3, [r3]
 903              		.loc 1 221 19
 904 0044 8020A0E3 		mov	r2, #128
 905 0048 342083E5 		str	r2, [r3, #52]
 222:main.c        ****     pio->PIO_MDDR = ALL;
 906              		.loc 1 222 8
 907 004c 58319FE5 		ldr	r3, .L49+12
 908 0050 003093E5 		ldr	r3, [r3]
 909              		.loc 1 222 19
 910 0054 54219FE5 		ldr	r2, .L49+16
 911 0058 542083E5 		str	r2, [r3, #84]
 223:main.c        ****     pio->PIO_PER = ALL;
 912              		.loc 1 223 8
 913 005c 48319FE5 		ldr	r3, .L49+12
 914 0060 003093E5 		ldr	r3, [r3]
 915              		.loc 1 223 18
 916 0064 44219FE5 		ldr	r2, .L49+16
 917 0068 002083E5 		str	r2, [r3]
 224:main.c        ****     pio->PIO_OER = ALL;
 918              		.loc 1 224 8
 919 006c 38319FE5 		ldr	r3, .L49+12
 920 0070 003093E5 		ldr	r3, [r3]
 921              		.loc 1 224 18
 922 0074 34219FE5 		ldr	r2, .L49+16
 923 0078 102083E5 		str	r2, [r3, #16]
 225:main.c        ****     pio->PIO_SODR = (SPULE1_DIR | SPULE2_DIR | SPULE2_PWM | SPULE1_PWM);
 924              		.loc 1 225 8
 925 007c 28319FE5 		ldr	r3, .L49+12
 926 0080 003093E5 		ldr	r3, [r3]
 927              		.loc 1 225 19
 928 0084 28219FE5 		ldr	r2, .L49+20
 929 0088 302083E5 		str	r2, [r3, #48]
 226:main.c        **** 
 227:main.c        ****   } else {
 228:main.c        ****     pmc->PMC_PCER = ((1 << 2) | (1 << 10));
 229:main.c        ****     
 230:main.c        ****     pio->PIO_MDDR = (PA30 | PA18 | PA7);
 231:main.c        ****     pio->PIO_PER = (PA30 | PA18 | PA7);
 232:main.c        ****     pio->PIO_OER = (PA30 | PA18 | PA7);
 233:main.c        ****     pio->PIO_CODR = PA7;
 234:main.c        ****     pio->PIO_SODR = (PA30 | PA18);
 235:main.c        **** 
 236:main.c        ****     pio->PIO_PDR = (PA23 | PA2);
 237:main.c        ****     pio->PIO_ASR = PA2;
 238:main.c        ****     pio->PIO_BSR = PA23;
 239:main.c        **** 
 240:main.c        ****     // Channel 0 PA23 -> PWM0
 241:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CMR = AT91C_PWMC_CPRE_MCK; // CPRE = MCK (kein prescaler) 
 242:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CPRDR = CPRD_2KHZ;         // Period
 243:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CDTYR = (CPRD_2KHZ / 2);   // duty = 50%
 244:main.c        **** 
 245:main.c        ****     // Channel 2 (PA2 -> PWM2
 246:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CMR = AT91C_PWMC_CPRE_MCK; 
 247:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CPRDR = CPRD_2KHZ;
 248:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CDTYR = (CPRD_2KHZ / 2);
 249:main.c        ****     
 250:main.c        ****     pwm_ctl->PWMC_ENA = (AT91C_PWMC_CHID0 | AT91C_PWMC_CHID2);
 251:main.c        **** 
 252:main.c        ****   }
 253:main.c        **** }
 930              		.loc 1 253 1
 931 008c 3F0000EA 		b	.L48
 932              	.L46:
 228:main.c        ****     
 933              		.loc 1 228 8
 934 0090 0C319FE5 		ldr	r3, .L49+4
 935 0094 003093E5 		ldr	r3, [r3]
 228:main.c        ****     
 936              		.loc 1 228 19
 937 0098 08219FE5 		ldr	r2, .L49+8
 938 009c 102083E5 		str	r2, [r3, #16]
 230:main.c        ****     pio->PIO_PER = (PA30 | PA18 | PA7);
 939              		.loc 1 230 8
 940 00a0 04319FE5 		ldr	r3, .L49+12
 941 00a4 003093E5 		ldr	r3, [r3]
 230:main.c        ****     pio->PIO_PER = (PA30 | PA18 | PA7);
 942              		.loc 1 230 19
 943 00a8 08219FE5 		ldr	r2, .L49+24
 944 00ac 542083E5 		str	r2, [r3, #84]
 231:main.c        ****     pio->PIO_OER = (PA30 | PA18 | PA7);
 945              		.loc 1 231 8
 946 00b0 F4309FE5 		ldr	r3, .L49+12
 947 00b4 003093E5 		ldr	r3, [r3]
 231:main.c        ****     pio->PIO_OER = (PA30 | PA18 | PA7);
 948              		.loc 1 231 18
 949 00b8 F8209FE5 		ldr	r2, .L49+24
 950 00bc 002083E5 		str	r2, [r3]
 232:main.c        ****     pio->PIO_CODR = PA7;
 951              		.loc 1 232 8
 952 00c0 E4309FE5 		ldr	r3, .L49+12
 953 00c4 003093E5 		ldr	r3, [r3]
 232:main.c        ****     pio->PIO_CODR = PA7;
 954              		.loc 1 232 18
 955 00c8 E8209FE5 		ldr	r2, .L49+24
 956 00cc 102083E5 		str	r2, [r3, #16]
 233:main.c        ****     pio->PIO_SODR = (PA30 | PA18);
 957              		.loc 1 233 8
 958 00d0 D4309FE5 		ldr	r3, .L49+12
 959 00d4 003093E5 		ldr	r3, [r3]
 233:main.c        ****     pio->PIO_SODR = (PA30 | PA18);
 960              		.loc 1 233 19
 961 00d8 8020A0E3 		mov	r2, #128
 962 00dc 342083E5 		str	r2, [r3, #52]
 234:main.c        **** 
 963              		.loc 1 234 8
 964 00e0 C4309FE5 		ldr	r3, .L49+12
 965 00e4 003093E5 		ldr	r3, [r3]
 234:main.c        **** 
 966              		.loc 1 234 19
 967 00e8 CC209FE5 		ldr	r2, .L49+28
 968 00ec 302083E5 		str	r2, [r3, #48]
 236:main.c        ****     pio->PIO_ASR = PA2;
 969              		.loc 1 236 8
 970 00f0 B4309FE5 		ldr	r3, .L49+12
 971 00f4 003093E5 		ldr	r3, [r3]
 236:main.c        ****     pio->PIO_ASR = PA2;
 972              		.loc 1 236 18
 973 00f8 C0209FE5 		ldr	r2, .L49+32
 974 00fc 042083E5 		str	r2, [r3, #4]
 237:main.c        ****     pio->PIO_BSR = PA23;
 975              		.loc 1 237 8
 976 0100 A4309FE5 		ldr	r3, .L49+12
 977 0104 003093E5 		ldr	r3, [r3]
 237:main.c        ****     pio->PIO_BSR = PA23;
 978              		.loc 1 237 18
 979 0108 0420A0E3 		mov	r2, #4
 980 010c 702083E5 		str	r2, [r3, #112]
 238:main.c        **** 
 981              		.loc 1 238 8
 982 0110 94309FE5 		ldr	r3, .L49+12
 983 0114 003093E5 		ldr	r3, [r3]
 238:main.c        **** 
 984              		.loc 1 238 18
 985 0118 0225A0E3 		mov	r2, #8388608
 986 011c 742083E5 		str	r2, [r3, #116]
 241:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CPRDR = CPRD_2KHZ;         // Period
 987              		.loc 1 241 12
 988 0120 9C309FE5 		ldr	r3, .L49+36
 989 0124 003093E5 		ldr	r3, [r3]
 241:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CPRDR = CPRD_2KHZ;         // Period
 990              		.loc 1 241 34
 991 0128 0020A0E3 		mov	r2, #0
 992 012c 002283E5 		str	r2, [r3, #512]
 242:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CDTYR = (CPRD_2KHZ / 2);   // duty = 50%
 993              		.loc 1 242 12
 994 0130 8C309FE5 		ldr	r3, .L49+36
 995 0134 003093E5 		ldr	r3, [r3]
 242:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CDTYR = (CPRD_2KHZ / 2);   // duty = 50%
 996              		.loc 1 242 36
 997 0138 88209FE5 		ldr	r2, .L49+40
 998 013c 082283E5 		str	r2, [r3, #520]
 243:main.c        **** 
 999              		.loc 1 243 12
 1000 0140 7C309FE5 		ldr	r3, .L49+36
 1001 0144 003093E5 		ldr	r3, [r3]
 243:main.c        **** 
 1002              		.loc 1 243 36
 1003 0148 7C209FE5 		ldr	r2, .L49+44
 1004 014c 042283E5 		str	r2, [r3, #516]
 246:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CPRDR = CPRD_2KHZ;
 1005              		.loc 1 246 12
 1006 0150 6C309FE5 		ldr	r3, .L49+36
 1007 0154 003093E5 		ldr	r3, [r3]
 246:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CPRDR = CPRD_2KHZ;
 1008              		.loc 1 246 34
 1009 0158 0020A0E3 		mov	r2, #0
 1010 015c 402283E5 		str	r2, [r3, #576]
 247:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CDTYR = (CPRD_2KHZ / 2);
 1011              		.loc 1 247 12
 1012 0160 5C309FE5 		ldr	r3, .L49+36
 1013 0164 003093E5 		ldr	r3, [r3]
 247:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CDTYR = (CPRD_2KHZ / 2);
 1014              		.loc 1 247 36
 1015 0168 58209FE5 		ldr	r2, .L49+40
 1016 016c 482283E5 		str	r2, [r3, #584]
 248:main.c        ****     
 1017              		.loc 1 248 12
 1018 0170 4C309FE5 		ldr	r3, .L49+36
 1019 0174 003093E5 		ldr	r3, [r3]
 248:main.c        ****     
 1020              		.loc 1 248 36
 1021 0178 4C209FE5 		ldr	r2, .L49+44
 1022 017c 442283E5 		str	r2, [r3, #580]
 250:main.c        **** 
 1023              		.loc 1 250 12
 1024 0180 3C309FE5 		ldr	r3, .L49+36
 1025 0184 003093E5 		ldr	r3, [r3]
 250:main.c        **** 
 1026              		.loc 1 250 23
 1027 0188 0520A0E3 		mov	r2, #5
 1028 018c 042083E5 		str	r2, [r3, #4]
 1029              	.L48:
 1030              		.loc 1 253 1
 1031 0190 0000A0E1 		nop
 1032 0194 00D08BE2 		add	sp, fp, #0
 1033              		.cfi_def_cfa_register 13
 1034              		@ sp needed
 1035 0198 04B09DE4 		ldr	fp, [sp], #4
 1036              		.cfi_restore 11
 1037              		.cfi_def_cfa_offset 0
 1038 019c 1EFF2FE1 		bx	lr
 1039              	.L50:
 1040              		.align	2
 1041              	.L49:
 1042 01a0 00000000 		.word	schrittmotor_data
 1043 01a4 00000000 		.word	pmc
 1044 01a8 04040000 		.word	1028
 1045 01ac 00000000 		.word	pio
 1046 01b0 84008440 		.word	1082392708
 1047 01b4 04008440 		.word	1082392580
 1048 01b8 80000440 		.word	1074004096
 1049 01bc 00000440 		.word	1074003968
 1050 01c0 04008000 		.word	8388612
 1051 01c4 00000000 		.word	pwm_ctl
 1052 01c8 C05D0000 		.word	24000
 1053 01cc E02E0000 		.word	12000
 1054              		.cfi_endproc
 1055              	.LFE17:
 1057              		.section	.text.schrittmotor_update,"ax",%progbits
 1058              		.align	2
 1059              		.global	schrittmotor_update
 1060              		.syntax unified
 1061              		.arm
 1063              	schrittmotor_update:
 1064              	.LFB18:
 254:main.c        **** void schrittmotor_update(void)
 255:main.c        **** {
 1065              		.loc 1 255 1
 1066              		.cfi_startproc
 1067              		@ Function supports interworking.
 1068              		@ args = 0, pretend = 0, frame = 8
 1069              		@ frame_needed = 1, uses_anonymous_args = 0
 1070              		@ link register save eliminated.
 1071 0000 04B02DE5 		str	fp, [sp, #-4]!
 1072              		.cfi_def_cfa_offset 4
 1073              		.cfi_offset 11, -4
 1074 0004 00B08DE2 		add	fp, sp, #0
 1075              		.cfi_def_cfa_register 11
 1076 0008 0CD04DE2 		sub	sp, sp, #12
 256:main.c        ****     uint16_t max_steps;
 257:main.c        ****     switch (schrittmotor_data.schritt_mode) {
 1077              		.loc 1 257 30
 1078 000c 54319FE5 		ldr	r3, .L62
 1079 0010 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1080 0014 0320A0E1 		mov	r2, r3
 1081              		.loc 1 257 5
 1082 0018 4C319FE5 		ldr	r3, .L62+4
 1083 001c 030052E3 		cmp	r2, #3
 1084 0020 0D00008A 		bhi	.L52
 1085 0024 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1086              	.Lrtx54:
 1087 0028 0000A0E1 		nop
 1088              		.section	.rodata
 1089 0039 000000   		.align	2
 1090              	.L54:
 1091 003c 2C000000 		.word	.L57
 1092 0040 38000000 		.word	.L56
 1093 0044 44000000 		.word	.L55
 1094 0048 50000000 		.word	.L53
 1095              		.section	.text.schrittmotor_update
 1096              		.p2align 2
 1097              	.L57:
 258:main.c        ****         case SCHRITT_VOLL_1: max_steps = MASK_FULL1; break;
 1098              		.loc 1 258 40
 1099 002c 0330A0E3 		mov	r3, #3
 1100 0030 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1101              		.loc 1 258 54
 1102 0034 0B0000EA 		b	.L58
 1103              	.L56:
 259:main.c        ****         case SCHRITT_VOLL_2: max_steps = MASK_FULL2; break;
 1104              		.loc 1 259 40
 1105 0038 0330A0E3 		mov	r3, #3
 1106 003c B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1107              		.loc 1 259 54
 1108 0040 080000EA 		b	.L58
 1109              	.L55:
 260:main.c        ****         case SCHRITT_HALB:   max_steps = MASK_HALF;  break;
 1110              		.loc 1 260 40
 1111 0044 0730A0E3 		mov	r3, #7
 1112 0048 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1113              		.loc 1 260 54
 1114 004c 050000EA 		b	.L58
 1115              	.L53:
 261:main.c        ****         case SCHRITT_SINUS:  max_steps = MASK_MICRO; break;
 1116              		.loc 1 261 40
 1117 0050 1F30A0E3 		mov	r3, #31
 1118 0054 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1119              		.loc 1 261 54
 1120 0058 020000EA 		b	.L58
 1121              	.L52:
 262:main.c        ****         default:             max_steps = MASK_FULL1; break;
 1122              		.loc 1 262 40
 1123 005c 0330A0E3 		mov	r3, #3
 1124 0060 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1125              		.loc 1 262 54
 1126 0064 0000A0E1 		nop
 1127              	.L58:
 263:main.c        ****     }
 264:main.c        **** 
 265:main.c        **** 	if (schrittmotor_data.pos !=0) {
 1128              		.loc 1 265 23
 1129 0068 F8309FE5 		ldr	r3, .L62
 1130 006c D330D3E1 		ldrsb	r3, [r3, #3]
 1131              		.loc 1 265 5
 1132 0070 000053E3 		cmp	r3, #0
 1133 0074 3700000A 		beq	.L61
 266:main.c        **** 				if(schrittmotor_data.pos >0){
 1134              		.loc 1 266 25
 1135 0078 E8309FE5 		ldr	r3, .L62
 1136 007c D330D3E1 		ldrsb	r3, [r3, #3]
 1137              		.loc 1 266 7
 1138 0080 000053E3 		cmp	r3, #0
 1139 0084 170000DA 		ble	.L60
 267:main.c        **** 					schrittmotor_data.step = (schrittmotor_data.step+1) & max_steps;
 1140              		.loc 1 267 49
 1141 0088 D8309FE5 		ldr	r3, .L62
 1142 008c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1143              		.loc 1 267 54
 1144 0090 013083E2 		add	r3, r3, #1
 1145 0094 FF3003E2 		and	r3, r3, #255
 1146 0098 033CA0E1 		lsl	r3, r3, #24
 1147 009c 432CA0E1 		asr	r2, r3, #24
 1148              		.loc 1 267 58
 1149 00a0 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 1150 00a4 033CA0E1 		lsl	r3, r3, #24
 1151 00a8 433CA0E1 		asr	r3, r3, #24
 1152 00ac 023003E0 		and	r3, r3, r2
 1153 00b0 033CA0E1 		lsl	r3, r3, #24
 1154 00b4 433CA0E1 		asr	r3, r3, #24
 1155 00b8 FF2003E2 		and	r2, r3, #255
 1156              		.loc 1 267 29
 1157 00bc A4309FE5 		ldr	r3, .L62
 1158 00c0 0C20C3E5 		strb	r2, [r3, #12]
 268:main.c        **** 					schrittmotor_data.pos--;
 1159              		.loc 1 268 23
 1160 00c4 9C309FE5 		ldr	r3, .L62
 1161 00c8 D330D3E1 		ldrsb	r3, [r3, #3]
 1162              		.loc 1 268 27
 1163 00cc FF3003E2 		and	r3, r3, #255
 1164 00d0 013043E2 		sub	r3, r3, #1
 1165 00d4 FF3003E2 		and	r3, r3, #255
 1166 00d8 033CA0E1 		lsl	r3, r3, #24
 1167 00dc 432CA0E1 		asr	r2, r3, #24
 1168 00e0 80309FE5 		ldr	r3, .L62
 1169 00e4 0320C3E5 		strb	r2, [r3, #3]
 1170              	.L60:
 269:main.c        **** 				}
 270:main.c        **** 
 271:main.c        **** 				if(schrittmotor_data.pos <0){
 1171              		.loc 1 271 25
 1172 00e8 78309FE5 		ldr	r3, .L62
 1173 00ec D330D3E1 		ldrsb	r3, [r3, #3]
 1174              		.loc 1 271 7
 1175 00f0 000053E3 		cmp	r3, #0
 1176 00f4 170000AA 		bge	.L61
 272:main.c        **** 					schrittmotor_data.step = (schrittmotor_data.step-1) & max_steps;
 1177              		.loc 1 272 49
 1178 00f8 68309FE5 		ldr	r3, .L62
 1179 00fc 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1180              		.loc 1 272 54
 1181 0100 013043E2 		sub	r3, r3, #1
 1182 0104 FF3003E2 		and	r3, r3, #255
 1183 0108 033CA0E1 		lsl	r3, r3, #24
 1184 010c 432CA0E1 		asr	r2, r3, #24
 1185              		.loc 1 272 58
 1186 0110 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 1187 0114 033CA0E1 		lsl	r3, r3, #24
 1188 0118 433CA0E1 		asr	r3, r3, #24
 1189 011c 023003E0 		and	r3, r3, r2
 1190 0120 033CA0E1 		lsl	r3, r3, #24
 1191 0124 433CA0E1 		asr	r3, r3, #24
 1192 0128 FF2003E2 		and	r2, r3, #255
 1193              		.loc 1 272 29
 1194 012c 34309FE5 		ldr	r3, .L62
 1195 0130 0C20C3E5 		strb	r2, [r3, #12]
 273:main.c        **** 					schrittmotor_data.pos++;
 1196              		.loc 1 273 23
 1197 0134 2C309FE5 		ldr	r3, .L62
 1198 0138 D330D3E1 		ldrsb	r3, [r3, #3]
 1199              		.loc 1 273 27
 1200 013c FF3003E2 		and	r3, r3, #255
 1201 0140 013083E2 		add	r3, r3, #1
 1202 0144 FF3003E2 		and	r3, r3, #255
 1203 0148 033CA0E1 		lsl	r3, r3, #24
 1204 014c 432CA0E1 		asr	r2, r3, #24
 1205 0150 10309FE5 		ldr	r3, .L62
 1206 0154 0320C3E5 		strb	r2, [r3, #3]
 1207              	.L61:
 274:main.c        **** 
 275:main.c        **** 				}
 276:main.c        **** 
 277:main.c        **** 	}
 278:main.c        **** }
 1208              		.loc 1 278 1
 1209 0158 0000A0E1 		nop
 1210 015c 00D08BE2 		add	sp, fp, #0
 1211              		.cfi_def_cfa_register 13
 1212              		@ sp needed
 1213 0160 04B09DE4 		ldr	fp, [sp], #4
 1214              		.cfi_restore 11
 1215              		.cfi_def_cfa_offset 0
 1216 0164 1EFF2FE1 		bx	lr
 1217              	.L63:
 1218              		.align	2
 1219              	.L62:
 1220 0168 00000000 		.word	schrittmotor_data
 1221 016c 3C000000 		.word	.L54
 1222              		.cfi_endproc
 1223              	.LFE18:
 1225              		.section	.text.schrittmotor_process,"ax",%progbits
 1226              		.align	2
 1227              		.global	schrittmotor_process
 1228              		.syntax unified
 1229              		.arm
 1231              	schrittmotor_process:
 1232              	.LFB19:
 279:main.c        **** 
 280:main.c        **** 
 281:main.c        **** void schrittmotor_process(void) {
 1233              		.loc 1 281 33
 1234              		.cfi_startproc
 1235              		@ Function supports interworking.
 1236              		@ args = 0, pretend = 0, frame = 24
 1237              		@ frame_needed = 1, uses_anonymous_args = 0
 1238 0000 00482DE9 		push	{fp, lr}
 1239              		.cfi_def_cfa_offset 8
 1240              		.cfi_offset 11, -8
 1241              		.cfi_offset 14, -4
 1242 0004 04B08DE2 		add	fp, sp, #4
 1243              		.cfi_def_cfa 11, 4
 1244 0008 18D04DE2 		sub	sp, sp, #24
 282:main.c        ****     switch (schrittmotor_data.schritt_mode) {
 1245              		.loc 1 282 30
 1246 000c 2C349FE5 		ldr	r3, .L109
 1247 0010 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1248 0014 0320A0E1 		mov	r2, r3
 1249              		.loc 1 282 5
 1250 0018 24349FE5 		ldr	r3, .L109+4
 1251 001c 030052E3 		cmp	r2, #3
 1252 0020 FB00008A 		bhi	.L101
 1253 0024 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1254              	.Lrtx67:
 1255 0028 0000A0E1 		nop
 1256              		.section	.rodata
 1257              		.align	2
 1258              	.L67:
 1259 004c 2C000000 		.word	.L70
 1260 0050 00010000 		.word	.L69
 1261 0054 C4010000 		.word	.L68
 1262 0058 18030000 		.word	.L66
 1263              		.section	.text.schrittmotor_process
 1264              		.p2align 2
 1265              	.L70:
 283:main.c        **** 
 284:main.c        ****         case SCHRITT_VOLL_1: {
 285:main.c        ****             if ((schrittmotor_data.pos != 0)) {
 1266              		.loc 1 285 35
 1267 002c 0C349FE5 		ldr	r3, .L109
 1268 0030 D330D3E1 		ldrsb	r3, [r3, #3]
 1269              		.loc 1 285 16
 1270 0034 000053E3 		cmp	r3, #0
 1271 0038 F700000A 		beq	.L102
 286:main.c        ****               schrittmotor_update();
 1272              		.loc 1 286 15
 1273 003c 04349FE5 		ldr	r3, .L109+8
 1274 0040 0FE0A0E1 		mov	lr, pc
 1275 0044 13FF2FE1 		bx	r3
 1276              	.LVL5:
 287:main.c        ****                 switch (schrittmotor_data.step) {
 1277              		.loc 1 287 42
 1278 0048 F0339FE5 		ldr	r3, .L109
 1279 004c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1280 0050 0320A0E1 		mov	r2, r3
 1281              		.loc 1 287 17
 1282 0054 F0339FE5 		ldr	r3, .L109+12
 1283 0058 030052E3 		cmp	r2, #3
 1284 005c 2500008A 		bhi	.L103
 1285 0060 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1286              	.Lrtx74:
 1287 0064 0000A0E1 		nop
 1288              		.section	.rodata
 1289              		.align	2
 1290              	.L74:
 1291 005c 68000000 		.word	.L77
 1292 0060 8C000000 		.word	.L76
 1293 0064 B0000000 		.word	.L75
 1294 0068 D4000000 		.word	.L73
 1295              		.section	.text.schrittmotor_process
 1296              		.p2align 2
 1297              	.L77:
 288:main.c        ****                     case 0:
 289:main.c        ****                         pio->PIO_SODR = SPULE1_PWM;
 1298              		.loc 1 289 28
 1299 0068 E0339FE5 		ldr	r3, .L109+16
 1300 006c 003093E5 		ldr	r3, [r3]
 1301              		.loc 1 289 39
 1302 0070 0225A0E3 		mov	r2, #8388608
 1303 0074 302083E5 		str	r2, [r3, #48]
 290:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE2_PWM);
 1304              		.loc 1 290 28
 1305 0078 D0339FE5 		ldr	r3, .L109+16
 1306 007c 003093E5 		ldr	r3, [r3]
 1307              		.loc 1 290 39
 1308 0080 CC239FE5 		ldr	r2, .L109+20
 1309 0084 342083E5 		str	r2, [r3, #52]
 291:main.c        ****                         break;
 1310              		.loc 1 291 25
 1311 0088 1B0000EA 		b	.L71
 1312              	.L76:
 292:main.c        ****                     case 1:
 293:main.c        ****                         pio->PIO_SODR = SPULE2_PWM;
 1313              		.loc 1 293 28
 1314 008c BC339FE5 		ldr	r3, .L109+16
 1315 0090 003093E5 		ldr	r3, [r3]
 1316              		.loc 1 293 39
 1317 0094 0420A0E3 		mov	r2, #4
 1318 0098 302083E5 		str	r2, [r3, #48]
 294:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE1_PWM);
 1319              		.loc 1 294 28
 1320 009c AC339FE5 		ldr	r3, .L109+16
 1321 00a0 003093E5 		ldr	r3, [r3]
 1322              		.loc 1 294 39
 1323 00a4 AC239FE5 		ldr	r2, .L109+24
 1324 00a8 342083E5 		str	r2, [r3, #52]
 295:main.c        ****                         break;
 1325              		.loc 1 295 25
 1326 00ac 120000EA 		b	.L71
 1327              	.L75:
 296:main.c        ****                     case 2:
 297:main.c        ****                         pio->PIO_SODR = (SPULE1_DIR | SPULE1_PWM);
 1328              		.loc 1 297 28
 1329 00b0 98339FE5 		ldr	r3, .L109+16
 1330 00b4 003093E5 		ldr	r3, [r3]
 1331              		.loc 1 297 39
 1332 00b8 2127A0E3 		mov	r2, #8650752
 1333 00bc 302083E5 		str	r2, [r3, #48]
 298:main.c        ****                         pio->PIO_CODR = (SPULE2_DIR | SPULE2_PWM);
 1334              		.loc 1 298 28
 1335 00c0 88339FE5 		ldr	r3, .L109+16
 1336 00c4 003093E5 		ldr	r3, [r3]
 1337              		.loc 1 298 39
 1338 00c8 1121A0E3 		mov	r2, #1073741828
 1339 00cc 342083E5 		str	r2, [r3, #52]
 299:main.c        ****                         break;
 1340              		.loc 1 299 25
 1341 00d0 090000EA 		b	.L71
 1342              	.L73:
 300:main.c        ****                     case 3:
 301:main.c        ****                         pio->PIO_SODR = (SPULE2_DIR | SPULE2_PWM);
 1343              		.loc 1 301 28
 1344 00d4 74339FE5 		ldr	r3, .L109+16
 1345 00d8 003093E5 		ldr	r3, [r3]
 1346              		.loc 1 301 39
 1347 00dc 1121A0E3 		mov	r2, #1073741828
 1348 00e0 302083E5 		str	r2, [r3, #48]
 302:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE1_PWM);
 1349              		.loc 1 302 28
 1350 00e4 64339FE5 		ldr	r3, .L109+16
 1351 00e8 003093E5 		ldr	r3, [r3]
 1352              		.loc 1 302 39
 1353 00ec 2127A0E3 		mov	r2, #8650752
 1354 00f0 342083E5 		str	r2, [r3, #52]
 303:main.c        ****                         break;
 1355              		.loc 1 303 25
 1356 00f4 000000EA 		b	.L71
 1357              	.L103:
 304:main.c        ****                     default:
 305:main.c        ****                         break;
 1358              		.loc 1 305 25
 1359 00f8 0000A0E1 		nop
 1360              	.L71:
 306:main.c        ****                 }
 307:main.c        ****             }
 308:main.c        ****             break;
 1361              		.loc 1 308 13
 1362 00fc C60000EA 		b	.L102
 1363              	.L69:
 309:main.c        ****         }
 310:main.c        **** 
 311:main.c        ****         case SCHRITT_VOLL_2: {
 312:main.c        ****             if ((schrittmotor_data.pos != 0)) {
 1364              		.loc 1 312 35
 1365 0100 38339FE5 		ldr	r3, .L109
 1366 0104 D330D3E1 		ldrsb	r3, [r3, #3]
 1367              		.loc 1 312 16
 1368 0108 000053E3 		cmp	r3, #0
 1369 010c C400000A 		beq	.L104
 313:main.c        ****               schrittmotor_update();
 1370              		.loc 1 313 15
 1371 0110 30339FE5 		ldr	r3, .L109+8
 1372 0114 0FE0A0E1 		mov	lr, pc
 1373 0118 13FF2FE1 		bx	r3
 1374              	.LVL6:
 314:main.c        ****                 switch (schrittmotor_data.step) {
 1375              		.loc 1 314 42
 1376 011c 1C339FE5 		ldr	r3, .L109
 1377 0120 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1378 0124 0320A0E1 		mov	r2, r3
 1379              		.loc 1 314 17
 1380 0128 2C339FE5 		ldr	r3, .L109+28
 1381 012c 030052E3 		cmp	r2, #3
 1382 0130 2100008A 		bhi	.L105
 1383 0134 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1384              	.Lrtx82:
 1385 0138 0000A0E1 		nop
 1386              		.section	.rodata
 1387              		.align	2
 1388              	.L82:
 1389 006c 3C010000 		.word	.L85
 1390 0070 60010000 		.word	.L84
 1391 0074 84010000 		.word	.L83
 1392 0078 98010000 		.word	.L81
 1393              		.section	.text.schrittmotor_process
 1394              		.p2align 2
 1395              	.L85:
 315:main.c        ****                     case 0:
 316:main.c        ****                         pio->PIO_SODR = (PA2 | PA23);
 1396              		.loc 1 316 28
 1397 013c 0C339FE5 		ldr	r3, .L109+16
 1398 0140 003093E5 		ldr	r3, [r3]
 1399              		.loc 1 316 39
 1400 0144 14239FE5 		ldr	r2, .L109+32
 1401 0148 302083E5 		str	r2, [r3, #48]
 317:main.c        ****                         pio->PIO_CODR = (PA30 | PA18);
 1402              		.loc 1 317 28
 1403 014c FC329FE5 		ldr	r3, .L109+16
 1404 0150 003093E5 		ldr	r3, [r3]
 1405              		.loc 1 317 39
 1406 0154 08239FE5 		ldr	r2, .L109+36
 1407 0158 342083E5 		str	r2, [r3, #52]
 318:main.c        ****                         break;
 1408              		.loc 1 318 25
 1409 015c 170000EA 		b	.L79
 1410              	.L84:
 319:main.c        ****                     case 1:
 320:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18);
 1411              		.loc 1 320 28
 1412 0160 E8329FE5 		ldr	r3, .L109+16
 1413 0164 003093E5 		ldr	r3, [r3]
 1414              		.loc 1 320 39
 1415 0168 F8229FE5 		ldr	r2, .L109+40
 1416 016c 302083E5 		str	r2, [r3, #48]
 321:main.c        ****                         pio->PIO_CODR = (PA30);
 1417              		.loc 1 321 28
 1418 0170 D8329FE5 		ldr	r3, .L109+16
 1419 0174 003093E5 		ldr	r3, [r3]
 1420              		.loc 1 321 39
 1421 0178 0121A0E3 		mov	r2, #1073741824
 1422 017c 342083E5 		str	r2, [r3, #52]
 322:main.c        ****                         break;
 1423              		.loc 1 322 25
 1424 0180 0E0000EA 		b	.L79
 1425              	.L83:
 323:main.c        ****                     case 2:
 324:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18 | PA30);
 1426              		.loc 1 324 28
 1427 0184 C4329FE5 		ldr	r3, .L109+16
 1428 0188 003093E5 		ldr	r3, [r3]
 1429              		.loc 1 324 39
 1430 018c D8229FE5 		ldr	r2, .L109+44
 1431 0190 302083E5 		str	r2, [r3, #48]
 325:main.c        ****                         break;
 1432              		.loc 1 325 25
 1433 0194 090000EA 		b	.L79
 1434              	.L81:
 326:main.c        ****                     case 3:
 327:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA30);
 1435              		.loc 1 327 28
 1436 0198 B0329FE5 		ldr	r3, .L109+16
 1437 019c 003093E5 		ldr	r3, [r3]
 1438              		.loc 1 327 39
 1439 01a0 C8229FE5 		ldr	r2, .L109+48
 1440 01a4 302083E5 		str	r2, [r3, #48]
 328:main.c        ****                         pio->PIO_CODR = (PA18);
 1441              		.loc 1 328 28
 1442 01a8 A0329FE5 		ldr	r3, .L109+16
 1443 01ac 003093E5 		ldr	r3, [r3]
 1444              		.loc 1 328 39
 1445 01b0 0127A0E3 		mov	r2, #262144
 1446 01b4 342083E5 		str	r2, [r3, #52]
 329:main.c        ****                         break;
 1447              		.loc 1 329 25
 1448 01b8 000000EA 		b	.L79
 1449              	.L105:
 330:main.c        ****                     default:
 331:main.c        ****                         break;
 1450              		.loc 1 331 25
 1451 01bc 0000A0E1 		nop
 1452              	.L79:
 332:main.c        ****                 }
 333:main.c        ****             }
 334:main.c        ****             break;
 1453              		.loc 1 334 13
 1454 01c0 970000EA 		b	.L104
 1455              	.L68:
 335:main.c        ****         }
 336:main.c        **** 
 337:main.c        ****         case SCHRITT_HALB: {
 338:main.c        ****             if ((schrittmotor_data.pos != 0)) {
 1456              		.loc 1 338 35
 1457 01c4 74329FE5 		ldr	r3, .L109
 1458 01c8 D330D3E1 		ldrsb	r3, [r3, #3]
 1459              		.loc 1 338 16
 1460 01cc 000053E3 		cmp	r3, #0
 1461 01d0 9500000A 		beq	.L106
 339:main.c        ****               schrittmotor_update();
 1462              		.loc 1 339 15
 1463 01d4 6C329FE5 		ldr	r3, .L109+8
 1464 01d8 0FE0A0E1 		mov	lr, pc
 1465 01dc 13FF2FE1 		bx	r3
 1466              	.LVL7:
 340:main.c        ****                 switch (schrittmotor_data.step) {
 1467              		.loc 1 340 42
 1468 01e0 58329FE5 		ldr	r3, .L109
 1469 01e4 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1470 01e8 0320A0E1 		mov	r2, r3
 1471              		.loc 1 340 17
 1472 01ec 80329FE5 		ldr	r3, .L109+52
 1473 01f0 070052E3 		cmp	r2, #7
 1474 01f4 4500008A 		bhi	.L107
 1475 01f8 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1476              	.Lrtx89:
 1477 01fc 0000A0E1 		nop
 1478              		.section	.rodata
 1479              		.align	2
 1480              	.L89:
 1481 007c 00020000 		.word	.L96
 1482 0080 24020000 		.word	.L95
 1483 0084 48020000 		.word	.L94
 1484 0088 6C020000 		.word	.L93
 1485 008c 90020000 		.word	.L92
 1486 0090 B4020000 		.word	.L91
 1487 0094 C8020000 		.word	.L90
 1488 0098 EC020000 		.word	.L88
 1489              		.section	.text.schrittmotor_process
 1490              		.p2align 2
 1491              	.L96:
 341:main.c        ****                     case 0:
 342:main.c        ****                         pio->PIO_SODR = SPULE1_PWM;
 1492              		.loc 1 342 28
 1493 0200 48329FE5 		ldr	r3, .L109+16
 1494 0204 003093E5 		ldr	r3, [r3]
 1495              		.loc 1 342 39
 1496 0208 0225A0E3 		mov	r2, #8388608
 1497 020c 302083E5 		str	r2, [r3, #48]
 343:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE2_PWM);
 1498              		.loc 1 343 28
 1499 0210 38329FE5 		ldr	r3, .L109+16
 1500 0214 003093E5 		ldr	r3, [r3]
 1501              		.loc 1 343 39
 1502 0218 34229FE5 		ldr	r2, .L109+20
 1503 021c 342083E5 		str	r2, [r3, #52]
 344:main.c        ****                         break;
 1504              		.loc 1 344 25
 1505 0220 3B0000EA 		b	.L86
 1506              	.L95:
 345:main.c        ****                     case 1:
 346:main.c        ****                         pio->PIO_SODR = (PA2 | PA23);
 1507              		.loc 1 346 28
 1508 0224 24329FE5 		ldr	r3, .L109+16
 1509 0228 003093E5 		ldr	r3, [r3]
 1510              		.loc 1 346 39
 1511 022c 2C229FE5 		ldr	r2, .L109+32
 1512 0230 302083E5 		str	r2, [r3, #48]
 347:main.c        ****                         pio->PIO_CODR = (PA30 | PA18);
 1513              		.loc 1 347 28
 1514 0234 14329FE5 		ldr	r3, .L109+16
 1515 0238 003093E5 		ldr	r3, [r3]
 1516              		.loc 1 347 39
 1517 023c 20229FE5 		ldr	r2, .L109+36
 1518 0240 342083E5 		str	r2, [r3, #52]
 348:main.c        ****                         break;
 1519              		.loc 1 348 25
 1520 0244 320000EA 		b	.L86
 1521              	.L94:
 349:main.c        ****                     case 2:
 350:main.c        ****                         pio->PIO_SODR = SPULE2_PWM;
 1522              		.loc 1 350 28
 1523 0248 00329FE5 		ldr	r3, .L109+16
 1524 024c 003093E5 		ldr	r3, [r3]
 1525              		.loc 1 350 39
 1526 0250 0420A0E3 		mov	r2, #4
 1527 0254 302083E5 		str	r2, [r3, #48]
 351:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE1_PWM);
 1528              		.loc 1 351 28
 1529 0258 F0319FE5 		ldr	r3, .L109+16
 1530 025c 003093E5 		ldr	r3, [r3]
 1531              		.loc 1 351 39
 1532 0260 F0219FE5 		ldr	r2, .L109+24
 1533 0264 342083E5 		str	r2, [r3, #52]
 352:main.c        ****                         break;
 1534              		.loc 1 352 25
 1535 0268 290000EA 		b	.L86
 1536              	.L93:
 353:main.c        ****                     case 3:
 354:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18);
 1537              		.loc 1 354 28
 1538 026c DC319FE5 		ldr	r3, .L109+16
 1539 0270 003093E5 		ldr	r3, [r3]
 1540              		.loc 1 354 39
 1541 0274 EC219FE5 		ldr	r2, .L109+40
 1542 0278 302083E5 		str	r2, [r3, #48]
 355:main.c        ****                         pio->PIO_CODR = (PA30);
 1543              		.loc 1 355 28
 1544 027c CC319FE5 		ldr	r3, .L109+16
 1545 0280 003093E5 		ldr	r3, [r3]
 1546              		.loc 1 355 39
 1547 0284 0121A0E3 		mov	r2, #1073741824
 1548 0288 342083E5 		str	r2, [r3, #52]
 356:main.c        ****                         break;
 1549              		.loc 1 356 25
 1550 028c 200000EA 		b	.L86
 1551              	.L92:
 357:main.c        ****                     case 4:
 358:main.c        ****                         pio->PIO_SODR = (SPULE1_DIR | SPULE1_PWM);
 1552              		.loc 1 358 28
 1553 0290 B8319FE5 		ldr	r3, .L109+16
 1554 0294 003093E5 		ldr	r3, [r3]
 1555              		.loc 1 358 39
 1556 0298 2127A0E3 		mov	r2, #8650752
 1557 029c 302083E5 		str	r2, [r3, #48]
 359:main.c        ****                         pio->PIO_CODR = (SPULE2_DIR | SPULE2_PWM);
 1558              		.loc 1 359 28
 1559 02a0 A8319FE5 		ldr	r3, .L109+16
 1560 02a4 003093E5 		ldr	r3, [r3]
 1561              		.loc 1 359 39
 1562 02a8 1121A0E3 		mov	r2, #1073741828
 1563 02ac 342083E5 		str	r2, [r3, #52]
 360:main.c        ****                         break;
 1564              		.loc 1 360 25
 1565 02b0 170000EA 		b	.L86
 1566              	.L91:
 361:main.c        ****                     case 5:
 362:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18 | PA30);
 1567              		.loc 1 362 28
 1568 02b4 94319FE5 		ldr	r3, .L109+16
 1569 02b8 003093E5 		ldr	r3, [r3]
 1570              		.loc 1 362 39
 1571 02bc A8219FE5 		ldr	r2, .L109+44
 1572 02c0 302083E5 		str	r2, [r3, #48]
 363:main.c        ****                         break;
 1573              		.loc 1 363 25
 1574 02c4 120000EA 		b	.L86
 1575              	.L90:
 364:main.c        ****                     case 6:
 365:main.c        ****                         pio->PIO_SODR = (SPULE2_DIR | SPULE2_PWM);
 1576              		.loc 1 365 28
 1577 02c8 80319FE5 		ldr	r3, .L109+16
 1578 02cc 003093E5 		ldr	r3, [r3]
 1579              		.loc 1 365 39
 1580 02d0 1121A0E3 		mov	r2, #1073741828
 1581 02d4 302083E5 		str	r2, [r3, #48]
 366:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE1_PWM);
 1582              		.loc 1 366 28
 1583 02d8 70319FE5 		ldr	r3, .L109+16
 1584 02dc 003093E5 		ldr	r3, [r3]
 1585              		.loc 1 366 39
 1586 02e0 2127A0E3 		mov	r2, #8650752
 1587 02e4 342083E5 		str	r2, [r3, #52]
 367:main.c        ****                         break;
 1588              		.loc 1 367 25
 1589 02e8 090000EA 		b	.L86
 1590              	.L88:
 368:main.c        ****                     case 7:
 369:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA30);
 1591              		.loc 1 369 28
 1592 02ec 5C319FE5 		ldr	r3, .L109+16
 1593 02f0 003093E5 		ldr	r3, [r3]
 1594              		.loc 1 369 39
 1595 02f4 74219FE5 		ldr	r2, .L109+48
 1596 02f8 302083E5 		str	r2, [r3, #48]
 370:main.c        ****                         pio->PIO_CODR = (PA18);
 1597              		.loc 1 370 28
 1598 02fc 4C319FE5 		ldr	r3, .L109+16
 1599 0300 003093E5 		ldr	r3, [r3]
 1600              		.loc 1 370 39
 1601 0304 0127A0E3 		mov	r2, #262144
 1602 0308 342083E5 		str	r2, [r3, #52]
 371:main.c        ****                         break;
 1603              		.loc 1 371 25
 1604 030c 000000EA 		b	.L86
 1605              	.L107:
 372:main.c        ****                     default:
 373:main.c        ****                         break;
 1606              		.loc 1 373 25
 1607 0310 0000A0E1 		nop
 1608              	.L86:
 374:main.c        ****                 }
 375:main.c        ****             }
 376:main.c        ****             break;
 1609              		.loc 1 376 13
 1610 0314 440000EA 		b	.L106
 1611              	.L66:
 1612              	.LBB7:
 377:main.c        ****         }
 378:main.c        **** 
 379:main.c        ****         case SCHRITT_SINUS: {
 380:main.c        **** 
 381:main.c        ****             schrittmotor_update();
 1613              		.loc 1 381 13
 1614 0318 28319FE5 		ldr	r3, .L109+8
 1615 031c 0FE0A0E1 		mov	lr, pc
 1616 0320 13FF2FE1 		bx	r3
 1617              	.LVL8:
 382:main.c        **** 
 383:main.c        ****             // A = sin, B = cos = sin + 90deg
 384:main.c        ****             uint8_t idxA = schrittmotor_data.step & MASK_MICRO;
 1618              		.loc 1 384 45
 1619 0324 14319FE5 		ldr	r3, .L109
 1620 0328 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1621              		.loc 1 384 21
 1622 032c 1F3003E2 		and	r3, r3, #31
 1623 0330 05304BE5 		strb	r3, [fp, #-5]
 385:main.c        ****             uint8_t idxB = (idxA + (STEPS_MICRO / 4)) & MASK_MICRO; 
 1624              		.loc 1 385 34
 1625 0334 05305BE5 		ldrb	r3, [fp, #-5]
 1626 0338 083083E2 		add	r3, r3, #8
 1627 033c FF3003E2 		and	r3, r3, #255
 1628              		.loc 1 385 21
 1629 0340 1F3003E2 		and	r3, r3, #31
 1630 0344 06304BE5 		strb	r3, [fp, #-6]
 386:main.c        **** 
 387:main.c        ****             //Array auslesen
 388:main.c        ****             int32_t sampleA = (int32_t) schrittmotor_data.micro[idxA];
 1631              		.loc 1 388 31
 1632 0348 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1633              		.loc 1 388 21
 1634 034c EC209FE5 		ldr	r2, .L109
 1635 0350 683083E2 		add	r3, r3, #104
 1636 0354 033192E7 		ldr	r3, [r2, r3, lsl #2]
 1637 0358 0C300BE5 		str	r3, [fp, #-12]
 389:main.c        ****             int32_t sampleB = (int32_t) schrittmotor_data.micro[idxB];
 1638              		.loc 1 389 31
 1639 035c 06305BE5 		ldrb	r3, [fp, #-6]	@ zero_extendqisi2
 1640              		.loc 1 389 21
 1641 0360 D8209FE5 		ldr	r2, .L109
 1642 0364 683083E2 		add	r3, r3, #104
 1643 0368 033192E7 		ldr	r3, [r2, r3, lsl #2]
 1644 036c 10300BE5 		str	r3, [fp, #-16]
 390:main.c        **** 
 391:main.c        ****            
 392:main.c        ****             if (sampleB >= 0) {
 1645              		.loc 1 392 16
 1646 0370 10301BE5 		ldr	r3, [fp, #-16]
 1647 0374 000053E3 		cmp	r3, #0
 1648 0378 040000BA 		blt	.L97
 393:main.c        ****                 pio->PIO_CODR = SPULE1_DIR;
 1649              		.loc 1 393 20
 1650 037c CC309FE5 		ldr	r3, .L109+16
 1651 0380 003093E5 		ldr	r3, [r3]
 1652              		.loc 1 393 31
 1653 0384 0127A0E3 		mov	r2, #262144
 1654 0388 342083E5 		str	r2, [r3, #52]
 1655 038c 030000EA 		b	.L98
 1656              	.L97:
 394:main.c        ****             } else {
 395:main.c        ****                 pio->PIO_SODR = SPULE1_DIR;
 1657              		.loc 1 395 20
 1658 0390 B8309FE5 		ldr	r3, .L109+16
 1659 0394 003093E5 		ldr	r3, [r3]
 1660              		.loc 1 395 31
 1661 0398 0127A0E3 		mov	r2, #262144
 1662 039c 302083E5 		str	r2, [r3, #48]
 1663              	.L98:
 396:main.c        ****             }
 397:main.c        **** 
 398:main.c        ****             if (sampleA >= 0) {
 1664              		.loc 1 398 16
 1665 03a0 0C301BE5 		ldr	r3, [fp, #-12]
 1666 03a4 000053E3 		cmp	r3, #0
 1667 03a8 040000BA 		blt	.L99
 399:main.c        ****                 pio->PIO_CODR = SPULE2_DIR;
 1668              		.loc 1 399 20
 1669 03ac 9C309FE5 		ldr	r3, .L109+16
 1670 03b0 003093E5 		ldr	r3, [r3]
 1671              		.loc 1 399 31
 1672 03b4 0121A0E3 		mov	r2, #1073741824
 1673 03b8 342083E5 		str	r2, [r3, #52]
 1674 03bc 030000EA 		b	.L100
 1675              	.L99:
 400:main.c        ****             } else {
 401:main.c        ****                 pio->PIO_SODR = SPULE2_DIR;
 1676              		.loc 1 401 20
 1677 03c0 88309FE5 		ldr	r3, .L109+16
 1678 03c4 003093E5 		ldr	r3, [r3]
 1679              		.loc 1 401 31
 1680 03c8 0121A0E3 		mov	r2, #1073741824
 1681 03cc 302083E5 		str	r2, [r3, #48]
 1682              	.L100:
 402:main.c        ****             }
 403:main.c        **** 
 404:main.c        ****             uint32_t dutyA = (uint32_t)(sampleA >= 0 ? sampleA : -sampleA);
 1683              		.loc 1 404 30
 1684 03d0 0C301BE5 		ldr	r3, [fp, #-12]
 1685 03d4 000053E3 		cmp	r3, #0
 1686 03d8 003063B2 		rsblt	r3, r3, #0
 1687              		.loc 1 404 22
 1688 03dc 14300BE5 		str	r3, [fp, #-20]
 405:main.c        ****             uint32_t dutyB = (uint32_t)(sampleB >= 0 ? sampleB : -sampleB);
 1689              		.loc 1 405 30
 1690 03e0 10301BE5 		ldr	r3, [fp, #-16]
 1691 03e4 000053E3 		cmp	r3, #0
 1692 03e8 003063B2 		rsblt	r3, r3, #0
 1693              		.loc 1 405 22
 1694 03ec 18300BE5 		str	r3, [fp, #-24]
 406:main.c        **** 
 407:main.c        ****  
 408:main.c        ****             pwm_ctl->PWMC_CH[0].PWMC_CUPDR = dutyA; // PA23 -> channel 0 
 1695              		.loc 1 408 20
 1696 03f0 80309FE5 		ldr	r3, .L109+56
 1697 03f4 003093E5 		ldr	r3, [r3]
 1698              		.loc 1 408 44
 1699 03f8 14201BE5 		ldr	r2, [fp, #-20]
 1700 03fc 102283E5 		str	r2, [r3, #528]
 409:main.c        ****             pwm_ctl->PWMC_CH[2].PWMC_CUPDR = dutyB; // PA2  -> channel 2 
 1701              		.loc 1 409 20
 1702 0400 70309FE5 		ldr	r3, .L109+56
 1703 0404 003093E5 		ldr	r3, [r3]
 1704              		.loc 1 409 44
 1705 0408 18201BE5 		ldr	r2, [fp, #-24]
 1706 040c 502283E5 		str	r2, [r3, #592]
 410:main.c        **** 
 411:main.c        ****             break;
 1707              		.loc 1 411 13
 1708 0410 060000EA 		b	.L78
 1709              	.L101:
 1710              	.LBE7:
 412:main.c        ****         }
 413:main.c        **** 
 414:main.c        ****         default: {
 415:main.c        ****             
 416:main.c        ****             break;
 1711              		.loc 1 416 13
 1712 0414 0000A0E1 		nop
 1713 0418 040000EA 		b	.L108
 1714              	.L102:
 308:main.c        ****         }
 1715              		.loc 1 308 13
 1716 041c 0000A0E1 		nop
 1717 0420 020000EA 		b	.L108
 1718              	.L104:
 334:main.c        ****         }
 1719              		.loc 1 334 13
 1720 0424 0000A0E1 		nop
 1721 0428 000000EA 		b	.L108
 1722              	.L106:
 376:main.c        ****         }
 1723              		.loc 1 376 13
 1724 042c 0000A0E1 		nop
 1725              	.L78:
 1726              	.L108:
 417:main.c        ****         }
 418:main.c        ****     } 
 419:main.c        **** } 
 1727              		.loc 1 419 1
 1728 0430 0000A0E1 		nop
 1729 0434 04D04BE2 		sub	sp, fp, #4
 1730              		.cfi_def_cfa 13, 8
 1731              		@ sp needed
 1732 0438 0048BDE8 		pop	{fp, lr}
 1733              		.cfi_restore 14
 1734              		.cfi_restore 11
 1735              		.cfi_def_cfa_offset 0
 1736 043c 1EFF2FE1 		bx	lr
 1737              	.L110:
 1738              		.align	2
 1739              	.L109:
 1740 0440 00000000 		.word	schrittmotor_data
 1741 0444 4C000000 		.word	.L67
 1742 0448 00000000 		.word	schrittmotor_update
 1743 044c 5C000000 		.word	.L74
 1744 0450 00000000 		.word	pio
 1745 0454 04000440 		.word	1074003972
 1746 0458 00008440 		.word	1082392576
 1747 045c 6C000000 		.word	.L82
 1748 0460 04008000 		.word	8388612
 1749 0464 00000440 		.word	1074003968
 1750 0468 04008400 		.word	8650756
 1751 046c 04008440 		.word	1082392580
 1752 0470 04008040 		.word	1082130436
 1753 0474 7C000000 		.word	.L89
 1754 0478 00000000 		.word	pwm_ctl
 1755              		.cfi_endproc
 1756              	.LFE19:
 1758              		.section	.text.ui_init,"ax",%progbits
 1759              		.align	2
 1760              		.global	ui_init
 1761              		.syntax unified
 1762              		.arm
 1764              	ui_init:
 1765              	.LFB20:
 420:main.c        **** 
 421:main.c        **** 
 422:main.c        **** void ui_init(void) {}
 1766              		.loc 1 422 20
 1767              		.cfi_startproc
 1768              		@ Function supports interworking.
 1769              		@ args = 0, pretend = 0, frame = 0
 1770              		@ frame_needed = 1, uses_anonymous_args = 0
 1771              		@ link register save eliminated.
 1772 0000 04B02DE5 		str	fp, [sp, #-4]!
 1773              		.cfi_def_cfa_offset 4
 1774              		.cfi_offset 11, -4
 1775 0004 00B08DE2 		add	fp, sp, #0
 1776              		.cfi_def_cfa_register 11
 1777              		.loc 1 422 21
 1778 0008 0000A0E1 		nop
 1779 000c 00D08BE2 		add	sp, fp, #0
 1780              		.cfi_def_cfa_register 13
 1781              		@ sp needed
 1782 0010 04B09DE4 		ldr	fp, [sp], #4
 1783              		.cfi_restore 11
 1784              		.cfi_def_cfa_offset 0
 1785 0014 1EFF2FE1 		bx	lr
 1786              		.cfi_endproc
 1787              	.LFE20:
 1789              		.section	.text.ui_process,"ax",%progbits
 1790              		.align	2
 1791              		.global	ui_process
 1792              		.syntax unified
 1793              		.arm
 1795              	ui_process:
 1796              	.LFB21:
 423:main.c        **** 
 424:main.c        **** void ui_process(void) {
 1797              		.loc 1 424 23
 1798              		.cfi_startproc
 1799              		@ Function supports interworking.
 1800              		@ args = 0, pretend = 0, frame = 8
 1801              		@ frame_needed = 1, uses_anonymous_args = 0
 1802 0000 00482DE9 		push	{fp, lr}
 1803              		.cfi_def_cfa_offset 8
 1804              		.cfi_offset 11, -8
 1805              		.cfi_offset 14, -4
 1806 0004 04B08DE2 		add	fp, sp, #4
 1807              		.cfi_def_cfa 11, 4
 1808 0008 08D04DE2 		sub	sp, sp, #8
 425:main.c        ****  
 426:main.c        **** 
 427:main.c        ****   button_t button_new = nxt_avr_get_buttons();
 1809              		.loc 1 427 25
 1810 000c 60349FE5 		ldr	r3, .L129
 1811 0010 0FE0A0E1 		mov	lr, pc
 1812 0014 13FF2FE1 		bx	r3
 1813              	.LVL9:
 1814 0018 0030A0E1 		mov	r3, r0
 1815 001c 08304BE5 		strb	r3, [fp, #-8]
 428:main.c        **** 
 429:main.c        ****   if ((button_new.orange == 1) && (schrittmotor_data.button_old.orange == 0)) {
 1816              		.loc 1 429 26
 1817 0020 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1818 0024 013003E2 		and	r3, r3, #1
 1819 0028 FF3003E2 		and	r3, r3, #255
 1820              		.loc 1 429 6
 1821 002c 000053E3 		cmp	r3, #0
 1822 0030 1F00000A 		beq	.L113
 1823              		.loc 1 429 72 discriminator 1
 1824 0034 3C349FE5 		ldr	r3, .L129+4
 1825 0038 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1826 003c 013003E2 		and	r3, r3, #1
 1827 0040 FF3003E2 		and	r3, r3, #255
 1828              		.loc 1 429 32 discriminator 1
 1829 0044 000053E3 		cmp	r3, #0
 1830 0048 1900001A 		bne	.L113
 430:main.c        **** 
 431:main.c        ****     if (schrittmotor_data.schritt_mode + 1 < SCHRITT_END) {
 1831              		.loc 1 431 26
 1832 004c 24349FE5 		ldr	r3, .L129+4
 1833 0050 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1834              		.loc 1 431 8
 1835 0054 020053E3 		cmp	r3, #2
 1836 0058 0C00008A 		bhi	.L114
 432:main.c        ****       schrittmotor_data.schritt_mode++;
 1837              		.loc 1 432 24
 1838 005c 14349FE5 		ldr	r3, .L129+4
 1839 0060 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1840              		.loc 1 432 37
 1841 0064 013083E2 		add	r3, r3, #1
 1842 0068 FF2003E2 		and	r2, r3, #255
 1843 006c 04349FE5 		ldr	r3, .L129+4
 1844 0070 0120C3E5 		strb	r2, [r3, #1]
 433:main.c        ****       schrittmotor_init(schrittmotor_data.schritt_mode);
 1845              		.loc 1 433 7
 1846 0074 FC339FE5 		ldr	r3, .L129+4
 1847 0078 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1848 007c 0300A0E1 		mov	r0, r3
 1849 0080 F4339FE5 		ldr	r3, .L129+8
 1850 0084 0FE0A0E1 		mov	lr, pc
 1851 0088 13FF2FE1 		bx	r3
 1852              	.LVL10:
 1853 008c 080000EA 		b	.L113
 1854              	.L114:
 434:main.c        ****     } else {
 435:main.c        ****       schrittmotor_data.schritt_mode = SCHRITT_VOLL_1;
 1855              		.loc 1 435 38
 1856 0090 E0339FE5 		ldr	r3, .L129+4
 1857 0094 0020A0E3 		mov	r2, #0
 1858 0098 0120C3E5 		strb	r2, [r3, #1]
 436:main.c        ****       schrittmotor_init(schrittmotor_data.schritt_mode);
 1859              		.loc 1 436 7
 1860 009c D4339FE5 		ldr	r3, .L129+4
 1861 00a0 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1862 00a4 0300A0E1 		mov	r0, r3
 1863 00a8 CC339FE5 		ldr	r3, .L129+8
 1864 00ac 0FE0A0E1 		mov	lr, pc
 1865 00b0 13FF2FE1 		bx	r3
 1866              	.LVL11:
 1867              	.L113:
 437:main.c        ****     }
 438:main.c        **** 
 439:main.c        ****   }
 440:main.c        **** 
 441:main.c        ****   if ((button_new.grey == 1) && (schrittmotor_data.button_old.grey == 0)) {
 1868              		.loc 1 441 24
 1869 00b4 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1870 00b8 083003E2 		and	r3, r3, #8
 1871 00bc FF3003E2 		and	r3, r3, #255
 1872              		.loc 1 441 6
 1873 00c0 000053E3 		cmp	r3, #0
 1874 00c4 1300000A 		beq	.L115
 1875              		.loc 1 441 68 discriminator 1
 1876 00c8 A8339FE5 		ldr	r3, .L129+4
 1877 00cc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1878 00d0 083003E2 		and	r3, r3, #8
 1879 00d4 FF3003E2 		and	r3, r3, #255
 1880              		.loc 1 441 30 discriminator 1
 1881 00d8 000053E3 		cmp	r3, #0
 1882 00dc 0D00001A 		bne	.L115
 442:main.c        **** 
 443:main.c        ****     if (schrittmotor_data.position_mode + 1 < POSITION_END) {
 1883              		.loc 1 443 26
 1884 00e0 90339FE5 		ldr	r3, .L129+4
 1885 00e4 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1886              		.loc 1 443 8
 1887 00e8 000053E3 		cmp	r3, #0
 1888 00ec 0600001A 		bne	.L116
 444:main.c        ****       schrittmotor_data.position_mode++;
 1889              		.loc 1 444 24
 1890 00f0 80339FE5 		ldr	r3, .L129+4
 1891 00f4 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1892              		.loc 1 444 38
 1893 00f8 013083E2 		add	r3, r3, #1
 1894 00fc FF2003E2 		and	r2, r3, #255
 1895 0100 70339FE5 		ldr	r3, .L129+4
 1896 0104 0220C3E5 		strb	r2, [r3, #2]
 1897 0108 020000EA 		b	.L115
 1898              	.L116:
 445:main.c        ****     } else {
 446:main.c        ****       schrittmotor_data.position_mode = POSITION_MANUELL;
 1899              		.loc 1 446 39
 1900 010c 64339FE5 		ldr	r3, .L129+4
 1901 0110 0020A0E3 		mov	r2, #0
 1902 0114 0220C3E5 		strb	r2, [r3, #2]
 1903              	.L115:
 447:main.c        ****     }
 448:main.c        ****   }
 449:main.c        **** 
 450:main.c        **** if (schrittmotor_data.position_mode == POSITION_KONTINUIERLICH) {
 1904              		.loc 1 450 22
 1905 0118 58339FE5 		ldr	r3, .L129+4
 1906 011c 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1907              		.loc 1 450 4
 1908 0120 010053E3 		cmp	r3, #1
 1909 0124 7D00001A 		bne	.L117
 451:main.c        ****     if (((button_new.left == 1) && (schrittmotor_data.dir == 1)) && (schrittmotor_data.button_old.l
 1910              		.loc 1 451 27
 1911 0128 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1912 012c 023003E2 		and	r3, r3, #2
 1913 0130 FF3003E2 		and	r3, r3, #255
 1914              		.loc 1 451 8
 1915 0134 000053E3 		cmp	r3, #0
 1916 0138 1F00000A 		beq	.L118
 1917              		.loc 1 451 54 discriminator 1
 1918 013c 34339FE5 		ldr	r3, .L129+4
 1919 0140 223E83E2 		add	r3, r3, #544
 1920 0144 D030D3E1 		ldrsb	r3, [r3]
 1921              		.loc 1 451 33 discriminator 1
 1922 0148 010053E3 		cmp	r3, #1
 1923 014c 1A00001A 		bne	.L118
 1924              		.loc 1 451 104 discriminator 2
 1925 0150 20339FE5 		ldr	r3, .L129+4
 1926 0154 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1927 0158 023003E2 		and	r3, r3, #2
 1928 015c FF3003E2 		and	r3, r3, #255
 1929              		.loc 1 451 66 discriminator 2
 1930 0160 000053E3 		cmp	r3, #0
 1931 0164 1400001A 		bne	.L118
 452:main.c        ****         if (schrittmotor_data.speed > 0) {
 1932              		.loc 1 452 30
 1933 0168 08339FE5 		ldr	r3, .L129+4
 1934 016c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1935              		.loc 1 452 12
 1936 0170 000053E3 		cmp	r3, #0
 1937 0174 0600000A 		beq	.L119
 453:main.c        ****             schrittmotor_data.speed--;
 1938              		.loc 1 453 30
 1939 0178 F8329FE5 		ldr	r3, .L129+4
 1940 017c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1941              		.loc 1 453 36
 1942 0180 013043E2 		sub	r3, r3, #1
 1943 0184 FF2003E2 		and	r2, r3, #255
 1944 0188 E8329FE5 		ldr	r3, .L129+4
 1945 018c 0420C3E5 		strb	r2, [r3, #4]
 1946 0190 090000EA 		b	.L118
 1947              	.L119:
 454:main.c        ****         } else {
 455:main.c        ****             schrittmotor_data.dir = (schrittmotor_data.dir == 1) ? -1 : 1;
 1948              		.loc 1 455 55
 1949 0194 DC329FE5 		ldr	r3, .L129+4
 1950 0198 223E83E2 		add	r3, r3, #544
 1951 019c D030D3E1 		ldrsb	r3, [r3]
 1952              		.loc 1 455 35
 1953 01a0 010053E3 		cmp	r3, #1
 1954 01a4 0100001A 		bne	.L120
 1955              		.loc 1 455 35 is_stmt 0 discriminator 1
 1956 01a8 0020E0E3 		mvn	r2, #0
 1957 01ac 000000EA 		b	.L121
 1958              	.L120:
 1959              		.loc 1 455 35 discriminator 2
 1960 01b0 0120A0E3 		mov	r2, #1
 1961              	.L121:
 1962              		.loc 1 455 35 discriminator 4
 1963 01b4 BC329FE5 		ldr	r3, .L129+4
 1964 01b8 2022C3E5 		strb	r2, [r3, #544]
 1965              	.L118:
 456:main.c        ****         }
 457:main.c        ****     }
 458:main.c        ****     if (((button_new.left == 1) && (schrittmotor_data.dir == -1)) && (schrittmotor_data.button_old.
 1966              		.loc 1 458 27 is_stmt 1
 1967 01bc 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1968 01c0 023003E2 		and	r3, r3, #2
 1969 01c4 FF3003E2 		and	r3, r3, #255
 1970              		.loc 1 458 8
 1971 01c8 000053E3 		cmp	r3, #0
 1972 01cc 1400000A 		beq	.L122
 1973              		.loc 1 458 54 discriminator 1
 1974 01d0 A0329FE5 		ldr	r3, .L129+4
 1975 01d4 223E83E2 		add	r3, r3, #544
 1976 01d8 D030D3E1 		ldrsb	r3, [r3]
 1977              		.loc 1 458 33 discriminator 1
 1978 01dc 010073E3 		cmn	r3, #1
 1979 01e0 0F00001A 		bne	.L122
 1980              		.loc 1 458 105 discriminator 2
 1981 01e4 8C329FE5 		ldr	r3, .L129+4
 1982 01e8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1983 01ec 023003E2 		and	r3, r3, #2
 1984 01f0 FF3003E2 		and	r3, r3, #255
 1985              		.loc 1 458 67 discriminator 2
 1986 01f4 000053E3 		cmp	r3, #0
 1987 01f8 0900001A 		bne	.L122
 459:main.c        ****         if (schrittmotor_data.speed <4 ) {
 1988              		.loc 1 459 30
 1989 01fc 74329FE5 		ldr	r3, .L129+4
 1990 0200 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1991              		.loc 1 459 12
 1992 0204 030053E3 		cmp	r3, #3
 1993 0208 0500008A 		bhi	.L122
 460:main.c        ****             schrittmotor_data.speed++;
 1994              		.loc 1 460 30
 1995 020c 64329FE5 		ldr	r3, .L129+4
 1996 0210 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1997              		.loc 1 460 36
 1998 0214 013083E2 		add	r3, r3, #1
 1999 0218 FF2003E2 		and	r2, r3, #255
 2000 021c 54329FE5 		ldr	r3, .L129+4
 2001 0220 0420C3E5 		strb	r2, [r3, #4]
 2002              	.L122:
 461:main.c        ****         }
 462:main.c        ****     }
 463:main.c        **** 
 464:main.c        ****     if (((button_new.right == 1) && (schrittmotor_data.dir == 1)) && (schrittmotor_data.button_old.
 2003              		.loc 1 464 28
 2004 0224 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2005 0228 043003E2 		and	r3, r3, #4
 2006 022c FF3003E2 		and	r3, r3, #255
 2007              		.loc 1 464 8
 2008 0230 000053E3 		cmp	r3, #0
 2009 0234 1400000A 		beq	.L123
 2010              		.loc 1 464 55 discriminator 1
 2011 0238 38329FE5 		ldr	r3, .L129+4
 2012 023c 223E83E2 		add	r3, r3, #544
 2013 0240 D030D3E1 		ldrsb	r3, [r3]
 2014              		.loc 1 464 34 discriminator 1
 2015 0244 010053E3 		cmp	r3, #1
 2016 0248 0F00001A 		bne	.L123
 2017              		.loc 1 464 106 discriminator 2
 2018 024c 24329FE5 		ldr	r3, .L129+4
 2019 0250 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2020 0254 043003E2 		and	r3, r3, #4
 2021 0258 FF3003E2 		and	r3, r3, #255
 2022              		.loc 1 464 67 discriminator 2
 2023 025c 000053E3 		cmp	r3, #0
 2024 0260 0900001A 		bne	.L123
 465:main.c        ****         if (schrittmotor_data.speed < 4) {
 2025              		.loc 1 465 30
 2026 0264 0C329FE5 		ldr	r3, .L129+4
 2027 0268 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2028              		.loc 1 465 12
 2029 026c 030053E3 		cmp	r3, #3
 2030 0270 0500008A 		bhi	.L123
 466:main.c        ****             schrittmotor_data.speed++;
 2031              		.loc 1 466 30
 2032 0274 FC319FE5 		ldr	r3, .L129+4
 2033 0278 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2034              		.loc 1 466 36
 2035 027c 013083E2 		add	r3, r3, #1
 2036 0280 FF2003E2 		and	r2, r3, #255
 2037 0284 EC319FE5 		ldr	r3, .L129+4
 2038 0288 0420C3E5 		strb	r2, [r3, #4]
 2039              	.L123:
 467:main.c        ****         }
 468:main.c        ****     }
 469:main.c        ****      if (((button_new.right == 1) && (schrittmotor_data.dir == -1)) && (schrittmotor_data.button_ol
 2040              		.loc 1 469 29
 2041 028c 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2042 0290 043003E2 		and	r3, r3, #4
 2043 0294 FF3003E2 		and	r3, r3, #255
 2044              		.loc 1 469 9
 2045 0298 000053E3 		cmp	r3, #0
 2046 029c 1F00000A 		beq	.L117
 2047              		.loc 1 469 56 discriminator 1
 2048 02a0 D0319FE5 		ldr	r3, .L129+4
 2049 02a4 223E83E2 		add	r3, r3, #544
 2050 02a8 D030D3E1 		ldrsb	r3, [r3]
 2051              		.loc 1 469 35 discriminator 1
 2052 02ac 010073E3 		cmn	r3, #1
 2053 02b0 1A00001A 		bne	.L117
 2054              		.loc 1 469 108 discriminator 2
 2055 02b4 BC319FE5 		ldr	r3, .L129+4
 2056 02b8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2057 02bc 043003E2 		and	r3, r3, #4
 2058 02c0 FF3003E2 		and	r3, r3, #255
 2059              		.loc 1 469 69 discriminator 2
 2060 02c4 000053E3 		cmp	r3, #0
 2061 02c8 1400001A 		bne	.L117
 470:main.c        ****         if (schrittmotor_data.speed > 0) {
 2062              		.loc 1 470 30
 2063 02cc A4319FE5 		ldr	r3, .L129+4
 2064 02d0 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2065              		.loc 1 470 12
 2066 02d4 000053E3 		cmp	r3, #0
 2067 02d8 0600000A 		beq	.L124
 471:main.c        ****             schrittmotor_data.speed--;
 2068              		.loc 1 471 30
 2069 02dc 94319FE5 		ldr	r3, .L129+4
 2070 02e0 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2071              		.loc 1 471 36
 2072 02e4 013043E2 		sub	r3, r3, #1
 2073 02e8 FF2003E2 		and	r2, r3, #255
 2074 02ec 84319FE5 		ldr	r3, .L129+4
 2075 02f0 0420C3E5 		strb	r2, [r3, #4]
 2076 02f4 090000EA 		b	.L117
 2077              	.L124:
 472:main.c        ****         } else {
 473:main.c        ****             schrittmotor_data.dir = (schrittmotor_data.dir == -1) ? 1 : -1;
 2078              		.loc 1 473 55
 2079 02f8 78319FE5 		ldr	r3, .L129+4
 2080 02fc 223E83E2 		add	r3, r3, #544
 2081 0300 D030D3E1 		ldrsb	r3, [r3]
 2082              		.loc 1 473 35
 2083 0304 010073E3 		cmn	r3, #1
 2084 0308 0100001A 		bne	.L125
 2085              		.loc 1 473 35 is_stmt 0 discriminator 1
 2086 030c 0120A0E3 		mov	r2, #1
 2087 0310 000000EA 		b	.L126
 2088              	.L125:
 2089              		.loc 1 473 35 discriminator 2
 2090 0314 0020E0E3 		mvn	r2, #0
 2091              	.L126:
 2092              		.loc 1 473 35 discriminator 4
 2093 0318 58319FE5 		ldr	r3, .L129+4
 2094 031c 2022C3E5 		strb	r2, [r3, #544]
 2095              	.L117:
 474:main.c        ****         }
 475:main.c        ****     }
 476:main.c        **** }
 477:main.c        **** 
 478:main.c        ****   if (schrittmotor_data.position_mode == POSITION_MANUELL) {
 2096              		.loc 1 478 24 is_stmt 1
 2097 0320 50319FE5 		ldr	r3, .L129+4
 2098 0324 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2099              		.loc 1 478 6
 2100 0328 000053E3 		cmp	r3, #0
 2101 032c 2700001A 		bne	.L127
 479:main.c        **** 
 480:main.c        ****     if ((button_new.left == 1) && (schrittmotor_data.button_old.left == 0)) {
 2102              		.loc 1 480 26
 2103 0330 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2104 0334 023003E2 		and	r3, r3, #2
 2105 0338 FF3003E2 		and	r3, r3, #255
 2106              		.loc 1 480 8
 2107 033c 000053E3 		cmp	r3, #0
 2108 0340 0E00000A 		beq	.L128
 2109              		.loc 1 480 70 discriminator 1
 2110 0344 2C319FE5 		ldr	r3, .L129+4
 2111 0348 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2112 034c 023003E2 		and	r3, r3, #2
 2113 0350 FF3003E2 		and	r3, r3, #255
 2114              		.loc 1 480 32 discriminator 1
 2115 0354 000053E3 		cmp	r3, #0
 2116 0358 0800001A 		bne	.L128
 481:main.c        ****       schrittmotor_data.pos--;
 2117              		.loc 1 481 24
 2118 035c 14319FE5 		ldr	r3, .L129+4
 2119 0360 D330D3E1 		ldrsb	r3, [r3, #3]
 2120              		.loc 1 481 28
 2121 0364 FF3003E2 		and	r3, r3, #255
 2122 0368 013043E2 		sub	r3, r3, #1
 2123 036c FF3003E2 		and	r3, r3, #255
 2124 0370 033CA0E1 		lsl	r3, r3, #24
 2125 0374 432CA0E1 		asr	r2, r3, #24
 2126 0378 F8309FE5 		ldr	r3, .L129+4
 2127 037c 0320C3E5 		strb	r2, [r3, #3]
 2128              	.L128:
 482:main.c        ****     }
 483:main.c        ****     if ((button_new.right == 1) && (schrittmotor_data.button_old.right == 0)) {
 2129              		.loc 1 483 27
 2130 0380 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2131 0384 043003E2 		and	r3, r3, #4
 2132 0388 FF3003E2 		and	r3, r3, #255
 2133              		.loc 1 483 8
 2134 038c 000053E3 		cmp	r3, #0
 2135 0390 0E00000A 		beq	.L127
 2136              		.loc 1 483 72 discriminator 1
 2137 0394 DC309FE5 		ldr	r3, .L129+4
 2138 0398 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2139 039c 043003E2 		and	r3, r3, #4
 2140 03a0 FF3003E2 		and	r3, r3, #255
 2141              		.loc 1 483 33 discriminator 1
 2142 03a4 000053E3 		cmp	r3, #0
 2143 03a8 0800001A 		bne	.L127
 484:main.c        ****       schrittmotor_data.pos++;
 2144              		.loc 1 484 24
 2145 03ac C4309FE5 		ldr	r3, .L129+4
 2146 03b0 D330D3E1 		ldrsb	r3, [r3, #3]
 2147              		.loc 1 484 28
 2148 03b4 FF3003E2 		and	r3, r3, #255
 2149 03b8 013083E2 		add	r3, r3, #1
 2150 03bc FF3003E2 		and	r3, r3, #255
 2151 03c0 033CA0E1 		lsl	r3, r3, #24
 2152 03c4 432CA0E1 		asr	r2, r3, #24
 2153 03c8 A8309FE5 		ldr	r3, .L129+4
 2154 03cc 0320C3E5 		strb	r2, [r3, #3]
 2155              	.L127:
 485:main.c        ****     }
 486:main.c        ****   }
 487:main.c        **** 
 488:main.c        ****   
 489:main.c        **** 
 490:main.c        ****   // Beispielanwendung für Display
 491:main.c        ****   static uint32_t count = 0;
 492:main.c        ****   display_goto_xy(0, 1);
 2156              		.loc 1 492 3
 2157 03d0 0110A0E3 		mov	r1, #1
 2158 03d4 0000A0E3 		mov	r0, #0
 2159 03d8 A0309FE5 		ldr	r3, .L129+12
 2160 03dc 0FE0A0E1 		mov	lr, pc
 2161 03e0 13FF2FE1 		bx	r3
 2162              	.LVL12:
 493:main.c        ****   display_unsigned(++count, 4);
 2163              		.loc 1 493 3
 2164 03e4 98309FE5 		ldr	r3, .L129+16
 2165 03e8 003093E5 		ldr	r3, [r3]
 2166 03ec 013083E2 		add	r3, r3, #1
 2167 03f0 8C209FE5 		ldr	r2, .L129+16
 2168 03f4 003082E5 		str	r3, [r2]
 2169 03f8 84309FE5 		ldr	r3, .L129+16
 2170 03fc 003093E5 		ldr	r3, [r3]
 2171 0400 0410A0E3 		mov	r1, #4
 2172 0404 0300A0E1 		mov	r0, r3
 2173 0408 78309FE5 		ldr	r3, .L129+20
 2174 040c 0FE0A0E1 		mov	lr, pc
 2175 0410 13FF2FE1 		bx	r3
 2176              	.LVL13:
 494:main.c        ****   display_goto_xy(0, 2);
 2177              		.loc 1 494 3
 2178 0414 0210A0E3 		mov	r1, #2
 2179 0418 0000A0E3 		mov	r0, #0
 2180 041c 5C309FE5 		ldr	r3, .L129+12
 2181 0420 0FE0A0E1 		mov	lr, pc
 2182 0424 13FF2FE1 		bx	r3
 2183              	.LVL14:
 495:main.c        ****   display_string(schritt_mode2str[schrittmotor_data.schritt_mode]);
 2184              		.loc 1 495 52
 2185 0428 48309FE5 		ldr	r3, .L129+4
 2186 042c 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2187 0430 0320A0E1 		mov	r2, r3
 2188              		.loc 1 495 3
 2189 0434 50309FE5 		ldr	r3, .L129+24
 2190 0438 023193E7 		ldr	r3, [r3, r2, lsl #2]
 2191 043c 0300A0E1 		mov	r0, r3
 2192 0440 48309FE5 		ldr	r3, .L129+28
 2193 0444 0FE0A0E1 		mov	lr, pc
 2194 0448 13FF2FE1 		bx	r3
 2195              	.LVL15:
 496:main.c        ****   display_update();
 2196              		.loc 1 496 3
 2197 044c 40309FE5 		ldr	r3, .L129+32
 2198 0450 0FE0A0E1 		mov	lr, pc
 2199 0454 13FF2FE1 		bx	r3
 2200              	.LVL16:
 497:main.c        **** 
 498:main.c        ****   schrittmotor_data.button_old = button_new;
 2201              		.loc 1 498 32
 2202 0458 18209FE5 		ldr	r2, .L129+4
 2203 045c 08305BE5 		ldrb	r3, [fp, #-8]
 2204 0460 0030C2E5 		strb	r3, [r2]
 499:main.c        **** }
 2205              		.loc 1 499 1
 2206 0464 0000A0E1 		nop
 2207 0468 04D04BE2 		sub	sp, fp, #4
 2208              		.cfi_def_cfa 13, 8
 2209              		@ sp needed
 2210 046c 0048BDE8 		pop	{fp, lr}
 2211              		.cfi_restore 14
 2212              		.cfi_restore 11
 2213              		.cfi_def_cfa_offset 0
 2214 0470 1EFF2FE1 		bx	lr
 2215              	.L130:
 2216              		.align	2
 2217              	.L129:
 2218 0474 00000000 		.word	nxt_avr_get_buttons
 2219 0478 00000000 		.word	schrittmotor_data
 2220 047c 00000000 		.word	schrittmotor_init
 2221 0480 00000000 		.word	display_goto_xy
 2222 0484 28030000 		.word	count.2
 2223 0488 00000000 		.word	display_unsigned
 2224 048c 00000000 		.word	schritt_mode2str
 2225 0490 00000000 		.word	display_string
 2226 0494 00000000 		.word	display_update
 2227              		.cfi_endproc
 2228              	.LFE21:
 2230              		.section	.text.task_4ms,"ax",%progbits
 2231              		.align	2
 2232              		.global	task_4ms
 2233              		.syntax unified
 2234              		.arm
 2236              	task_4ms:
 2237              	.LFB22:
 500:main.c        **** 
 501:main.c        **** /*****************************************************************************/
 502:main.c        **** /*   Hilfsroutinen                                                           */
 503:main.c        **** /*****************************************************************************/
 504:main.c        **** 
 505:main.c        **** void task_4ms(void) {
 2238              		.loc 1 505 21
 2239              		.cfi_startproc
 2240              		@ Function supports interworking.
 2241              		@ args = 0, pretend = 0, frame = 0
 2242              		@ frame_needed = 1, uses_anonymous_args = 0
 2243 0000 00482DE9 		push	{fp, lr}
 2244              		.cfi_def_cfa_offset 8
 2245              		.cfi_offset 11, -8
 2246              		.cfi_offset 14, -4
 2247 0004 04B08DE2 		add	fp, sp, #4
 2248              		.cfi_def_cfa 11, 4
 506:main.c        ****     schrittmotor_data.current_reload = schrittmotor_data.reload_table[schrittmotor_data.speed];
 2249              		.loc 1 506 88
 2250 0008 DC309FE5 		ldr	r3, .L135
 2251 000c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2252              		.loc 1 506 70
 2253 0010 D4209FE5 		ldr	r2, .L135
 2254 0014 043083E2 		add	r3, r3, #4
 2255 0018 8330A0E1 		lsl	r3, r3, #1
 2256 001c 033082E0 		add	r3, r2, r3
 2257 0020 063083E2 		add	r3, r3, #6
 2258 0024 B030D3E1 		ldrh	r3, [r3]
 2259              		.loc 1 506 38
 2260 0028 BC209FE5 		ldr	r2, .L135
 2261 002c B831C2E1 		strh	r3, [r2, #24]	@ movhi
 507:main.c        **** 
 508:main.c        ****     if (schrittmotor_data.position_mode == POSITION_KONTINUIERLICH) {
 2262              		.loc 1 508 26
 2263 0030 B4309FE5 		ldr	r3, .L135
 2264 0034 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2265              		.loc 1 508 8
 2266 0038 010053E3 		cmp	r3, #1
 2267 003c 2000001A 		bne	.L132
 509:main.c        ****         schrittmotor_data.counter++;
 2268              		.loc 1 509 26
 2269 0040 A4309FE5 		ldr	r3, .L135
 2270 0044 BA31D3E1 		ldrh	r3, [r3, #26]
 2271              		.loc 1 509 34
 2272 0048 013083E2 		add	r3, r3, #1
 2273 004c 0338A0E1 		lsl	r3, r3, #16
 2274 0050 2338A0E1 		lsr	r3, r3, #16
 2275 0054 90209FE5 		ldr	r2, .L135
 2276 0058 BA31C2E1 		strh	r3, [r2, #26]	@ movhi
 510:main.c        ****         if (schrittmotor_data.counter >= schrittmotor_data.current_reload) {
 2277              		.loc 1 510 30
 2278 005c 88309FE5 		ldr	r3, .L135
 2279 0060 BA21D3E1 		ldrh	r2, [r3, #26]
 2280              		.loc 1 510 59
 2281 0064 80309FE5 		ldr	r3, .L135
 2282 0068 B831D3E1 		ldrh	r3, [r3, #24]
 2283              		.loc 1 510 12
 2284 006c 030052E1 		cmp	r2, r3
 2285 0070 1900003A 		bcc	.L134
 511:main.c        ****             schrittmotor_data.counter = 0;
 2286              		.loc 1 511 39
 2287 0074 70309FE5 		ldr	r3, .L135
 2288 0078 0020A0E3 		mov	r2, #0
 2289 007c BA21C3E1 		strh	r2, [r3, #26]	@ movhi
 512:main.c        ****             schrittmotor_data.pos += (int32_t)schrittmotor_data.dir;
 2290              		.loc 1 512 30
 2291 0080 64309FE5 		ldr	r3, .L135
 2292 0084 D330D3E1 		ldrsb	r3, [r3, #3]
 2293 0088 FF2003E2 		and	r2, r3, #255
 2294              		.loc 1 512 64
 2295 008c 58309FE5 		ldr	r3, .L135
 2296 0090 223E83E2 		add	r3, r3, #544
 2297 0094 D030D3E1 		ldrsb	r3, [r3]
 2298 0098 FF3003E2 		and	r3, r3, #255
 2299              		.loc 1 512 35
 2300 009c 033082E0 		add	r3, r2, r3
 2301 00a0 FF3003E2 		and	r3, r3, #255
 2302 00a4 033CA0E1 		lsl	r3, r3, #24
 2303 00a8 432CA0E1 		asr	r2, r3, #24
 2304 00ac 38309FE5 		ldr	r3, .L135
 2305 00b0 0320C3E5 		strb	r2, [r3, #3]
 513:main.c        ****             schrittmotor_process();
 2306              		.loc 1 513 13
 2307 00b4 34309FE5 		ldr	r3, .L135+4
 2308 00b8 0FE0A0E1 		mov	lr, pc
 2309 00bc 13FF2FE1 		bx	r3
 2310              	.LVL17:
 514:main.c        ****         }
 515:main.c        ****     } else {
 516:main.c        ****         schrittmotor_process();
 517:main.c        ****         schrittmotor_data.counter = 0;
 518:main.c        ****     }
 519:main.c        **** }
 2311              		.loc 1 519 1
 2312 00c0 050000EA 		b	.L134
 2313              	.L132:
 516:main.c        ****         schrittmotor_data.counter = 0;
 2314              		.loc 1 516 9
 2315 00c4 24309FE5 		ldr	r3, .L135+4
 2316 00c8 0FE0A0E1 		mov	lr, pc
 2317 00cc 13FF2FE1 		bx	r3
 2318              	.LVL18:
 517:main.c        ****     }
 2319              		.loc 1 517 35
 2320 00d0 14309FE5 		ldr	r3, .L135
 2321 00d4 0020A0E3 		mov	r2, #0
 2322 00d8 BA21C3E1 		strh	r2, [r3, #26]	@ movhi
 2323              	.L134:
 2324              		.loc 1 519 1
 2325 00dc 0000A0E1 		nop
 2326 00e0 04D04BE2 		sub	sp, fp, #4
 2327              		.cfi_def_cfa 13, 8
 2328              		@ sp needed
 2329 00e4 0048BDE8 		pop	{fp, lr}
 2330              		.cfi_restore 14
 2331              		.cfi_restore 11
 2332              		.cfi_def_cfa_offset 0
 2333 00e8 1EFF2FE1 		bx	lr
 2334              	.L136:
 2335              		.align	2
 2336              	.L135:
 2337 00ec 00000000 		.word	schrittmotor_data
 2338 00f0 00000000 		.word	schrittmotor_process
 2339              		.cfi_endproc
 2340              	.LFE22:
 2342              		.section	.text.task_8ms,"ax",%progbits
 2343              		.align	2
 2344              		.global	task_8ms
 2345              		.syntax unified
 2346              		.arm
 2348              	task_8ms:
 2349              	.LFB23:
 520:main.c        **** 
 521:main.c        **** void task_8ms(void) {
 2350              		.loc 1 521 21
 2351              		.cfi_startproc
 2352              		@ Function supports interworking.
 2353              		@ args = 0, pretend = 0, frame = 0
 2354              		@ frame_needed = 1, uses_anonymous_args = 0
 2355              		@ link register save eliminated.
 2356 0000 04B02DE5 		str	fp, [sp, #-4]!
 2357              		.cfi_def_cfa_offset 4
 2358              		.cfi_offset 11, -4
 2359 0004 00B08DE2 		add	fp, sp, #0
 2360              		.cfi_def_cfa_register 11
 522:main.c        ****   // Keine blockierende Aufrufe
 523:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 524:main.c        **** }
 2361              		.loc 1 524 1
 2362 0008 0000A0E1 		nop
 2363 000c 00D08BE2 		add	sp, fp, #0
 2364              		.cfi_def_cfa_register 13
 2365              		@ sp needed
 2366 0010 04B09DE4 		ldr	fp, [sp], #4
 2367              		.cfi_restore 11
 2368              		.cfi_def_cfa_offset 0
 2369 0014 1EFF2FE1 		bx	lr
 2370              		.cfi_endproc
 2371              	.LFE23:
 2373              		.section	.text.task_16ms,"ax",%progbits
 2374              		.align	2
 2375              		.global	task_16ms
 2376              		.syntax unified
 2377              		.arm
 2379              	task_16ms:
 2380              	.LFB24:
 525:main.c        **** 
 526:main.c        **** void task_16ms(void) {
 2381              		.loc 1 526 22
 2382              		.cfi_startproc
 2383              		@ Function supports interworking.
 2384              		@ args = 0, pretend = 0, frame = 0
 2385              		@ frame_needed = 1, uses_anonymous_args = 0
 2386              		@ link register save eliminated.
 2387 0000 04B02DE5 		str	fp, [sp, #-4]!
 2388              		.cfi_def_cfa_offset 4
 2389              		.cfi_offset 11, -4
 2390 0004 00B08DE2 		add	fp, sp, #0
 2391              		.cfi_def_cfa_register 11
 527:main.c        ****   // Keine blockierende Aufrufe
 528:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 529:main.c        **** }
 2392              		.loc 1 529 1
 2393 0008 0000A0E1 		nop
 2394 000c 00D08BE2 		add	sp, fp, #0
 2395              		.cfi_def_cfa_register 13
 2396              		@ sp needed
 2397 0010 04B09DE4 		ldr	fp, [sp], #4
 2398              		.cfi_restore 11
 2399              		.cfi_def_cfa_offset 0
 2400 0014 1EFF2FE1 		bx	lr
 2401              		.cfi_endproc
 2402              	.LFE24:
 2404              		.section	.text.task_32ms,"ax",%progbits
 2405              		.align	2
 2406              		.global	task_32ms
 2407              		.syntax unified
 2408              		.arm
 2410              	task_32ms:
 2411              	.LFB25:
 530:main.c        **** 
 531:main.c        **** void task_32ms(void) {
 2412              		.loc 1 531 22
 2413              		.cfi_startproc
 2414              		@ Function supports interworking.
 2415              		@ args = 0, pretend = 0, frame = 0
 2416              		@ frame_needed = 1, uses_anonymous_args = 0
 2417              		@ link register save eliminated.
 2418 0000 04B02DE5 		str	fp, [sp, #-4]!
 2419              		.cfi_def_cfa_offset 4
 2420              		.cfi_offset 11, -4
 2421 0004 00B08DE2 		add	fp, sp, #0
 2422              		.cfi_def_cfa_register 11
 532:main.c        ****   // Keine blockierende Aufrufe
 533:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 534:main.c        **** }
 2423              		.loc 1 534 1
 2424 0008 0000A0E1 		nop
 2425 000c 00D08BE2 		add	sp, fp, #0
 2426              		.cfi_def_cfa_register 13
 2427              		@ sp needed
 2428 0010 04B09DE4 		ldr	fp, [sp], #4
 2429              		.cfi_restore 11
 2430              		.cfi_def_cfa_offset 0
 2431 0014 1EFF2FE1 		bx	lr
 2432              		.cfi_endproc
 2433              	.LFE25:
 2435              		.section	.text.task_64ms,"ax",%progbits
 2436              		.align	2
 2437              		.global	task_64ms
 2438              		.syntax unified
 2439              		.arm
 2441              	task_64ms:
 2442              	.LFB26:
 535:main.c        **** 
 536:main.c        **** void task_64ms(void) {
 2443              		.loc 1 536 22
 2444              		.cfi_startproc
 2445              		@ Function supports interworking.
 2446              		@ args = 0, pretend = 0, frame = 0
 2447              		@ frame_needed = 1, uses_anonymous_args = 0
 2448 0000 00482DE9 		push	{fp, lr}
 2449              		.cfi_def_cfa_offset 8
 2450              		.cfi_offset 11, -8
 2451              		.cfi_offset 14, -4
 2452 0004 04B08DE2 		add	fp, sp, #4
 2453              		.cfi_def_cfa 11, 4
 537:main.c        ****   // Keine blockierende Aufrufe
 538:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 539:main.c        ****   ui_process();
 2454              		.loc 1 539 3
 2455 0008 14309FE5 		ldr	r3, .L141
 2456 000c 0FE0A0E1 		mov	lr, pc
 2457 0010 13FF2FE1 		bx	r3
 2458              	.LVL19:
 540:main.c        **** }
 2459              		.loc 1 540 1
 2460 0014 0000A0E1 		nop
 2461 0018 04D04BE2 		sub	sp, fp, #4
 2462              		.cfi_def_cfa 13, 8
 2463              		@ sp needed
 2464 001c 0048BDE8 		pop	{fp, lr}
 2465              		.cfi_restore 14
 2466              		.cfi_restore 11
 2467              		.cfi_def_cfa_offset 0
 2468 0020 1EFF2FE1 		bx	lr
 2469              	.L142:
 2470              		.align	2
 2471              	.L141:
 2472 0024 00000000 		.word	ui_process
 2473              		.cfi_endproc
 2474              	.LFE26:
 2476              		.section	.text.task_128ms,"ax",%progbits
 2477              		.align	2
 2478              		.global	task_128ms
 2479              		.syntax unified
 2480              		.arm
 2482              	task_128ms:
 2483              	.LFB27:
 541:main.c        **** 
 542:main.c        **** void task_128ms(void) {
 2484              		.loc 1 542 23
 2485              		.cfi_startproc
 2486              		@ Function supports interworking.
 2487              		@ args = 0, pretend = 0, frame = 0
 2488              		@ frame_needed = 1, uses_anonymous_args = 0
 2489              		@ link register save eliminated.
 2490 0000 04B02DE5 		str	fp, [sp, #-4]!
 2491              		.cfi_def_cfa_offset 4
 2492              		.cfi_offset 11, -4
 2493 0004 00B08DE2 		add	fp, sp, #0
 2494              		.cfi_def_cfa_register 11
 543:main.c        ****   // Keine blockierende Aufrufe
 544:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 545:main.c        **** }
 2495              		.loc 1 545 1
 2496 0008 0000A0E1 		nop
 2497 000c 00D08BE2 		add	sp, fp, #0
 2498              		.cfi_def_cfa_register 13
 2499              		@ sp needed
 2500 0010 04B09DE4 		ldr	fp, [sp], #4
 2501              		.cfi_restore 11
 2502              		.cfi_def_cfa_offset 0
 2503 0014 1EFF2FE1 		bx	lr
 2504              		.cfi_endproc
 2505              	.LFE27:
 2507              		.section	.text.task_256ms,"ax",%progbits
 2508              		.align	2
 2509              		.global	task_256ms
 2510              		.syntax unified
 2511              		.arm
 2513              	task_256ms:
 2514              	.LFB28:
 546:main.c        **** 
 547:main.c        **** void task_256ms(void) {
 2515              		.loc 1 547 23
 2516              		.cfi_startproc
 2517              		@ Function supports interworking.
 2518              		@ args = 0, pretend = 0, frame = 0
 2519              		@ frame_needed = 1, uses_anonymous_args = 0
 2520              		@ link register save eliminated.
 2521 0000 04B02DE5 		str	fp, [sp, #-4]!
 2522              		.cfi_def_cfa_offset 4
 2523              		.cfi_offset 11, -4
 2524 0004 00B08DE2 		add	fp, sp, #0
 2525              		.cfi_def_cfa_register 11
 548:main.c        ****   // Keine blockierende Aufrufe
 549:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 550:main.c        **** }
 2526              		.loc 1 550 1
 2527 0008 0000A0E1 		nop
 2528 000c 00D08BE2 		add	sp, fp, #0
 2529              		.cfi_def_cfa_register 13
 2530              		@ sp needed
 2531 0010 04B09DE4 		ldr	fp, [sp], #4
 2532              		.cfi_restore 11
 2533              		.cfi_def_cfa_offset 0
 2534 0014 1EFF2FE1 		bx	lr
 2535              		.cfi_endproc
 2536              	.LFE28:
 2538              		.section	.text.task_512ms,"ax",%progbits
 2539              		.align	2
 2540              		.global	task_512ms
 2541              		.syntax unified
 2542              		.arm
 2544              	task_512ms:
 2545              	.LFB29:
 551:main.c        **** 
 552:main.c        **** void task_512ms(void) {
 2546              		.loc 1 552 23
 2547              		.cfi_startproc
 2548              		@ Function supports interworking.
 2549              		@ args = 0, pretend = 0, frame = 0
 2550              		@ frame_needed = 1, uses_anonymous_args = 0
 2551              		@ link register save eliminated.
 2552 0000 04B02DE5 		str	fp, [sp, #-4]!
 2553              		.cfi_def_cfa_offset 4
 2554              		.cfi_offset 11, -4
 2555 0004 00B08DE2 		add	fp, sp, #0
 2556              		.cfi_def_cfa_register 11
 553:main.c        ****   // Keine blockierende Aufrufe
 554:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 555:main.c        **** }
 2557              		.loc 1 555 1
 2558 0008 0000A0E1 		nop
 2559 000c 00D08BE2 		add	sp, fp, #0
 2560              		.cfi_def_cfa_register 13
 2561              		@ sp needed
 2562 0010 04B09DE4 		ldr	fp, [sp], #4
 2563              		.cfi_restore 11
 2564              		.cfi_def_cfa_offset 0
 2565 0014 1EFF2FE1 		bx	lr
 2566              		.cfi_endproc
 2567              	.LFE29:
 2569              		.section	.text.task_1024ms,"ax",%progbits
 2570              		.align	2
 2571              		.global	task_1024ms
 2572              		.syntax unified
 2573              		.arm
 2575              	task_1024ms:
 2576              	.LFB30:
 556:main.c        **** 
 557:main.c        **** void task_1024ms(void) {
 2577              		.loc 1 557 24
 2578              		.cfi_startproc
 2579              		@ Function supports interworking.
 2580              		@ args = 0, pretend = 0, frame = 0
 2581              		@ frame_needed = 1, uses_anonymous_args = 0
 2582              		@ link register save eliminated.
 2583 0000 04B02DE5 		str	fp, [sp, #-4]!
 2584              		.cfi_def_cfa_offset 4
 2585              		.cfi_offset 11, -4
 2586 0004 00B08DE2 		add	fp, sp, #0
 2587              		.cfi_def_cfa_register 11
 558:main.c        ****   // Keine blockierende Aufrufe
 559:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 560:main.c        **** }
 2588              		.loc 1 560 1
 2589 0008 0000A0E1 		nop
 2590 000c 00D08BE2 		add	sp, fp, #0
 2591              		.cfi_def_cfa_register 13
 2592              		@ sp needed
 2593 0010 04B09DE4 		ldr	fp, [sp], #4
 2594              		.cfi_restore 11
 2595              		.cfi_def_cfa_offset 0
 2596 0014 1EFF2FE1 		bx	lr
 2597              		.cfi_endproc
 2598              	.LFE30:
 2600              		.section	.text.task_idle,"ax",%progbits
 2601              		.align	2
 2602              		.global	task_idle
 2603              		.syntax unified
 2604              		.arm
 2606              	task_idle:
 2607              	.LFB31:
 561:main.c        **** 
 562:main.c        **** void task_idle(void) {
 2608              		.loc 1 562 22
 2609              		.cfi_startproc
 2610              		@ Function supports interworking.
 2611              		@ args = 0, pretend = 0, frame = 0
 2612              		@ frame_needed = 1, uses_anonymous_args = 0
 2613              		@ link register save eliminated.
 2614 0000 04B02DE5 		str	fp, [sp, #-4]!
 2615              		.cfi_def_cfa_offset 4
 2616              		.cfi_offset 11, -4
 2617 0004 00B08DE2 		add	fp, sp, #0
 2618              		.cfi_def_cfa_register 11
 563:main.c        ****   // Keine blockierende Aufrufe
 564:main.c        ****   // Max. Bearbeitungsdauer: IDLE_MS
 565:main.c        **** }
 2619              		.loc 1 565 1
 2620 0008 0000A0E1 		nop
 2621 000c 00D08BE2 		add	sp, fp, #0
 2622              		.cfi_def_cfa_register 13
 2623              		@ sp needed
 2624 0010 04B09DE4 		ldr	fp, [sp], #4
 2625              		.cfi_restore 11
 2626              		.cfi_def_cfa_offset 0
 2627 0014 1EFF2FE1 		bx	lr
 2628              		.cfi_endproc
 2629              	.LFE31:
 2631              		.section	.text.premain_init,"ax",%progbits
 2632              		.align	2
 2633              		.global	premain_init
 2634              		.syntax unified
 2635              		.arm
 2637              	premain_init:
 2638              	.LFB32:
 566:main.c        **** 
 567:main.c        **** /*****************************************************************************/
 568:main.c        **** /*    Pre-Main-Funktion                                                      */
 569:main.c        **** /*****************************************************************************/
 570:main.c        **** // Zur Vermeidung von malloc(1024) bei der ersten Ausgabe über stdout!
 571:main.c        **** //__attribute__(constructor) stellt sicher, dass premain_init() direkt nach
 572:main.c        **** //__sinit() aufgerufen wird (beides innerhalb von __libc_init_array())
 573:main.c        **** void __attribute__((constructor)) premain_init(void) {
 2639              		.loc 1 573 54
 2640              		.cfi_startproc
 2641              		@ Function supports interworking.
 2642              		@ args = 0, pretend = 0, frame = 0
 2643              		@ frame_needed = 1, uses_anonymous_args = 0
 2644 0000 30482DE9 		push	{r4, r5, fp, lr}
 2645              		.cfi_def_cfa_offset 16
 2646              		.cfi_offset 4, -16
 2647              		.cfi_offset 5, -12
 2648              		.cfi_offset 11, -8
 2649              		.cfi_offset 14, -4
 2650 0004 0CB08DE2 		add	fp, sp, #12
 2651              		.cfi_def_cfa 11, 4
 574:main.c        **** #if 0
 575:main.c        **** 	//No linebuffering, call stdio_write() immediately
 576:main.c        **** 	//-> Langsam, da mit jedem Zeichen __sflush_r()/_write()/stdio_write() aufgerufen wird 
 577:main.c        **** 	setvbuf(stdout,NULL,_IONBF,0);
 578:main.c        **** #else
 579:main.c        ****   static char linebuf[10];
 580:main.c        ****   // LineBuffering into global Varialbe (guter Kompromiss)
 581:main.c        ****   setvbuf(stdout, linebuf, _IOLBF, sizeof(linebuf)); // Linebuffering in
 2652              		.loc 1 581 11
 2653 0008 2C309FE5 		ldr	r3, .L149
 2654 000c 003093E5 		ldr	r3, [r3]
 2655 0010 080093E5 		ldr	r0, [r3, #8]
 2656              		.loc 1 581 3
 2657 0014 0A30A0E3 		mov	r3, #10
 2658 0018 0120A0E3 		mov	r2, #1
 2659 001c 1C109FE5 		ldr	r1, .L149+4
 2660 0020 1C409FE5 		ldr	r4, .L149+8
 2661 0024 0FE0A0E1 		mov	lr, pc
 2662 0028 14FF2FE1 		bx	r4
 2663              	.LVL20:
 582:main.c        **** #endif
 583:main.c        **** }
 2664              		.loc 1 583 1
 2665 002c 0000A0E1 		nop
 2666 0030 0CD04BE2 		sub	sp, fp, #12
 2667              		.cfi_def_cfa 13, 16
 2668              		@ sp needed
 2669 0034 3048BDE8 		pop	{r4, r5, fp, lr}
 2670              		.cfi_restore 14
 2671              		.cfi_restore 11
 2672              		.cfi_restore 5
 2673              		.cfi_restore 4
 2674              		.cfi_def_cfa_offset 0
 2675 0038 1EFF2FE1 		bx	lr
 2676              	.L150:
 2677              		.align	2
 2678              	.L149:
 2679 003c 00000000 		.word	_impure_ptr
 2680 0040 2C030000 		.word	linebuf.1
 2681 0044 00000000 		.word	setvbuf
 2682              		.cfi_endproc
 2683              	.LFE32:
 2685              		.section	.init_array,"aw",%init_array
 2686              		.align	2
 2687 0000 00000000 		.word	premain_init(target1)
 2688              		.section	.rodata
 2689              		.align	2
 2690              	.LC9:
 2691 009c 68616C6C 		.ascii	"hallo\012\015\000"
 2691      6F0A0D00 
 2692              		.align	2
 2693              	.LC10:
 2694 00a4 1B5B324A 		.ascii	"\033[2J\033[H\033[0m\000"
 2694      1B5B481B 
 2694      5B306D00 
 2695              		.align	2
 2696              	.LC11:
 2697 00b0 50726F67 		.ascii	"Prog: demo\012\015Version von: Oct 29 2025 13:24:42"
 2697      3A206465 
 2697      6D6F0A0D 
 2697      56657273 
 2697      696F6E20 
 2698 00dd 0A0D00   		.ascii	"\012\015\000"
 2699              		.align	2
 2700              	.LC12:
 2701 00e0 27762E76 		.ascii	"'v.view %e schrittmotor_data' zur Variablendarstell"
 2701      69657720 
 2701      25652073 
 2701      63687269 
 2701      74746D6F 
 2702 0113 756E670A 		.ascii	"ung\012\015\000"
 2702      0D00
 2703 0119 000000   		.align	2
 2704              	.LC13:
 2705 011c 5669656C 		.ascii	"Viel Erfolg!\012\015\000"
 2705      20457266 
 2705      6F6C6721 
 2705      0A0D00
 2706 012b 00       		.align	2
 2707              	.LC14:
 2708 012c 00       		.ascii	"\000"
 2709 012d 000000   		.align	2
 2710              	.LC15:
 2711 0130 346D7300 		.ascii	"4ms\000"
 2712              		.align	2
 2713              	.LC16:
 2714 0134 386D7300 		.ascii	"8ms\000"
 2715              		.align	2
 2716              	.LC17:
 2717 0138 31366D73 		.ascii	"16ms\000"
 2717      00
 2718 013d 000000   		.align	2
 2719              	.LC18:
 2720 0140 33326D73 		.ascii	"32ms\000"
 2720      00
 2721 0145 000000   		.align	2
 2722              	.LC19:
 2723 0148 36346D73 		.ascii	"64ms\000"
 2723      00
 2724 014d 000000   		.align	2
 2725              	.LC20:
 2726 0150 3132386D 		.ascii	"128ms\000"
 2726      7300
 2727 0156 0000     		.align	2
 2728              	.LC21:
 2729 0158 3235366D 		.ascii	"256ms\000"
 2729      7300
 2730 015e 0000     		.align	2
 2731              	.LC22:
 2732 0160 3531326D 		.ascii	"512ms\000"
 2732      7300
 2733 0166 0000     		.align	2
 2734              	.LC23:
 2735 0168 49646C65 		.ascii	"Idle\000"
 2735      00
 2736 016d 000000   		.align	2
 2737              	.LC24:
 2738 0170 1B5B3331 		.ascii	"\033[31mTiming durch '\000"
 2738      6D54696D 
 2738      696E6720 
 2738      64757263 
 2738      68202700 
 2739              		.align	2
 2740              	.LC25:
 2741 0184 27207665 		.ascii	"' verletzt\012\015\033[39m\000"
 2741      726C6574 
 2741      7A740A0D 
 2741      1B5B3339 
 2741      6D00
 2742 0196 0000     		.align	2
 2743              	.LC26:
 2744 0198 1B5B3331 		.ascii	"\033[31mStack overflow durch '\000"
 2744      6D537461 
 2744      636B206F 
 2744      76657266 
 2744      6C6F7720 
 2745              		.align	2
 2746              	.LC27:
 2747 01b4 270A0D1B 		.ascii	"'\012\015\033[39m\000"
 2747      5B33396D 
 2747      00
 2748 01bd 000000   		.align	2
 2749              	.LC28:
 2750 01c0 1B5B3331 		.ascii	"\033[31m\012\015Low Battery\012\015\033[39m\000"
 2750      6D0A0D4C 
 2750      6F772042 
 2750      61747465 
 2750      72790A0D 
 2751 01da 0000     		.align	2
 2752              	.LC29:
 2753 01dc 1B5B3331 		.ascii	"\033[31m\012\015Terminal Overflow\012\015\033[39m\000"
 2753      6D0A0D54 
 2753      65726D69 
 2753      6E616C20 
 2753      4F766572 
 2754              		.section	.text.main,"ax",%progbits
 2755              		.align	2
 2756              		.global	main
 2757              		.syntax unified
 2758              		.arm
 2760              	main:
 2761              	.LFB33:
 584:main.c        **** /*****************************************************************************/
 585:main.c        **** /*    Main-Funktion                                                          */
 586:main.c        **** /*****************************************************************************/
 587:main.c        **** #if 0
 588:main.c        **** //Variante 1: Deklaration der main() Funktion
 589:main.c        **** //da es keine CLI gibt, über welcher die Anwendung getartet wird
 590:main.c        **** //sondern der start über startup.s erfolgt, macht dies kein Sinn
 591:main.c        **** //und belegt unnötige Speicherplatz auf den Stack
 592:main.c        **** int main(int argc, char *argv[]) 
 593:main.c        **** {
 594:main.c        **** 	(void) argc;
 595:main.c        **** 	(void) argv;
 596:main.c        **** #else
 597:main.c        **** // Variante 2: Deklaration der main() funktion
 598:main.c        **** int main(void) {
 2762              		.loc 1 598 16
 2763              		.cfi_startproc
 2764              		@ Function supports interworking.
 2765              		@ args = 0, pretend = 0, frame = 24
 2766              		@ frame_needed = 1, uses_anonymous_args = 0
 2767 0000 00482DE9 		push	{fp, lr}
 2768              		.cfi_def_cfa_offset 8
 2769              		.cfi_offset 11, -8
 2770              		.cfi_offset 14, -4
 2771 0004 04B08DE2 		add	fp, sp, #4
 2772              		.cfi_def_cfa 11, 4
 2773 0008 18D04DE2 		sub	sp, sp, #24
 599:main.c        **** #endif
 600:main.c        ****   /* Interrupts zu diesem Zeitpunkt disabled !!!! */
 601:main.c        **** 
 602:main.c        ****   /* 'Pflicht' Initialisierung, können nicht ausgelassen werden */
 603:main.c        ****   aic_init();          // Interrupt-Controller initialisieren
 2774              		.loc 1 603 3
 2775 000c E4359FE5 		ldr	r3, .L180
 2776 0010 0FE0A0E1 		mov	lr, pc
 2777 0014 13FF2FE1 		bx	r3
 2778              	.LVL21:
 604:main.c        ****   systick_init();      // System-Timer initialisieren
 2779              		.loc 1 604 3
 2780 0018 DC359FE5 		ldr	r3, .L180+4
 2781 001c 0FE0A0E1 		mov	lr, pc
 2782 0020 13FF2FE1 		bx	r3
 2783              	.LVL22:
 605:main.c        ****   interrupts_enable(); // Ohne Worte
 2784              		.loc 1 605 3
 2785 0024 D4359FE5 		ldr	r3, .L180+8
 2786 0028 0FE0A0E1 		mov	lr, pc
 2787 002c 13FF2FE1 		bx	r3
 2788              	.LVL23:
 606:main.c        ****   nxt_avr_init(8);
 2789              		.loc 1 606 3
 2790 0030 0800A0E3 		mov	r0, #8
 2791 0034 C8359FE5 		ldr	r3, .L180+12
 2792 0038 0FE0A0E1 		mov	lr, pc
 2793 003c 13FF2FE1 		bx	r3
 2794              	.LVL24:
 607:main.c        **** #if defined(MODE_RAM) || defined(MODE_SIM)
 608:main.c        ****   udmon3_init(); // Speicherzugriff durch den Debugger
 2795              		.loc 1 608 3
 2796 0040 C0359FE5 		ldr	r3, .L180+16
 2797 0044 0FE0A0E1 		mov	lr, pc
 2798 0048 13FF2FE1 		bx	r3
 2799              	.LVL25:
 609:main.c        ****                  // zur Programmlaufzeit mittels der
 610:main.c        ****                  // DCC Schnittstelle ermöglichen
 611:main.c        **** #endif
 612:main.c        **** 
 613:main.c        ****   /* 'Wahl' Initialisierung, hängt von den benötigten Komponenten ab */
 614:main.c        ****   term_init();
 2800              		.loc 1 614 3
 2801 004c B8359FE5 		ldr	r3, .L180+20
 2802 0050 0FE0A0E1 		mov	lr, pc
 2803 0054 13FF2FE1 		bx	r3
 2804              	.LVL26:
 615:main.c        ****   display_init();
 2805              		.loc 1 615 3
 2806 0058 B0359FE5 		ldr	r3, .L180+24
 2807 005c 0FE0A0E1 		mov	lr, pc
 2808 0060 13FF2FE1 		bx	r3
 2809              	.LVL27:
 616:main.c        **** 
 617:main.c        ****   ui_init();
 2810              		.loc 1 617 3
 2811 0064 A8359FE5 		ldr	r3, .L180+28
 2812 0068 0FE0A0E1 		mov	lr, pc
 2813 006c 13FF2FE1 		bx	r3
 2814              	.LVL28:
 618:main.c        ****   schrittmotor_init(schrittmotor_data.schritt_mode);
 2815              		.loc 1 618 3
 2816 0070 A0359FE5 		ldr	r3, .L180+32
 2817 0074 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2818 0078 0300A0E1 		mov	r0, r3
 2819 007c 98359FE5 		ldr	r3, .L180+36
 2820 0080 0FE0A0E1 		mov	lr, pc
 2821 0084 13FF2FE1 		bx	r3
 2822              	.LVL29:
 619:main.c        **** 
 620:main.c        ****   display_clear(0);
 2823              		.loc 1 620 3
 2824 0088 0000A0E3 		mov	r0, #0
 2825 008c 8C359FE5 		ldr	r3, .L180+40
 2826 0090 0FE0A0E1 		mov	lr, pc
 2827 0094 13FF2FE1 		bx	r3
 2828              	.LVL30:
 621:main.c        ****   display_update();
 2829              		.loc 1 621 3
 2830 0098 84359FE5 		ldr	r3, .L180+44
 2831 009c 0FE0A0E1 		mov	lr, pc
 2832 00a0 13FF2FE1 		bx	r3
 2833              	.LVL31:
 622:main.c        **** 
 623:main.c        ****   // ANSI Escape sequences - VT100 / VT52 (see main.h)
 624:main.c        ****   (void)term_string("hallo\n\r", ASYNCSYNC_BLOCK);
 2834              		.loc 1 624 9
 2835 00a4 0110A0E3 		mov	r1, #1
 2836 00a8 78059FE5 		ldr	r0, .L180+48
 2837 00ac 78359FE5 		ldr	r3, .L180+52
 2838 00b0 0FE0A0E1 		mov	lr, pc
 2839 00b4 13FF2FE1 		bx	r3
 2840              	.LVL32:
 625:main.c        ****   (void)term_string(
 2841              		.loc 1 625 9
 2842 00b8 0110A0E3 		mov	r1, #1
 2843 00bc 6C059FE5 		ldr	r0, .L180+56
 2844 00c0 64359FE5 		ldr	r3, .L180+52
 2845 00c4 0FE0A0E1 		mov	lr, pc
 2846 00c8 13FF2FE1 		bx	r3
 2847              	.LVL33:
 626:main.c        ****       "\033[2J" VT100_CURSORHOME // Move Cursor to home position (0,0)
 627:main.c        ****           VT100_DEFAULT,
 628:main.c        ****       ASYNCSYNC_BLOCK);
 629:main.c        ****   (void)term_string("Prog: " APP_NAME "\n\rVersion von: " __DATE__ " " __TIME__
 2848              		.loc 1 629 9
 2849 00cc 0110A0E3 		mov	r1, #1
 2850 00d0 5C059FE5 		ldr	r0, .L180+60
 2851 00d4 50359FE5 		ldr	r3, .L180+52
 2852 00d8 0FE0A0E1 		mov	lr, pc
 2853 00dc 13FF2FE1 		bx	r3
 2854              	.LVL34:
 630:main.c        ****                     "\n\r",
 631:main.c        ****                     ASYNCSYNC_BLOCK);
 632:main.c        ****   (void)term_string(
 2855              		.loc 1 632 9
 2856 00e0 0110A0E3 		mov	r1, #1
 2857 00e4 4C059FE5 		ldr	r0, .L180+64
 2858 00e8 3C359FE5 		ldr	r3, .L180+52
 2859 00ec 0FE0A0E1 		mov	lr, pc
 2860 00f0 13FF2FE1 		bx	r3
 2861              	.LVL35:
 633:main.c        ****       "'v.view %e schrittmotor_data' zur Variablendarstellung\n\r",
 634:main.c        ****       ASYNCSYNC_BLOCK);
 635:main.c        ****   (void)term_string("Viel Erfolg!\n\r", ASYNCSYNC_BLOCK);
 2862              		.loc 1 635 9
 2863 00f4 0110A0E3 		mov	r1, #1
 2864 00f8 3C059FE5 		ldr	r0, .L180+68
 2865 00fc 28359FE5 		ldr	r3, .L180+52
 2866 0100 0FE0A0E1 		mov	lr, pc
 2867 0104 13FF2FE1 		bx	r3
 2868              	.LVL36:
 636:main.c        **** 
 637:main.c        ****   // Alternativ zu term_xxx() kann auch printf() oder noch besser iprintf
 638:main.c        ****   // genutzt werden beide bedingen jedoch einen großen Speicherbedarf!
 639:main.c        ****   // Alternativ zu term_read() kann auch scanf() genutzt werden. Auch diese
 640:main.c        ****   // Funktion
 641:main.c        ****   //  bedingt einen großen Speicherbedarf
 642:main.c        **** 
 643:main.c        **** #ifndef MODE_ROM
 644:main.c        ****   /* Watchdog Disable */
 645:main.c        ****   /* Mode-Register kann nur einmal beschrieben werden */
 646:main.c        ****   AT91C_BASE_WDTC->WDTC_WDMR = 0xFFF | AT91C_WDTC_WDDIS | /*WD Disable */
 2869              		.loc 1 646 18
 2870 0108 30359FE5 		ldr	r3, .L180+72
 2871              		.loc 1 646 30
 2872 010c 30259FE5 		ldr	r2, .L180+76
 2873 0110 042083E5 		str	r2, [r3, #4]
 2874              	.LBB8:
 2875              	.LBB9:
 2876              		.file 4 "lib/../main.h"
   1:lib/../main.h **** #ifndef main_h
   2:lib/../main.h **** #define main_h
   3:lib/../main.h **** #include <stdint.h>
   4:lib/../main.h **** 
   5:lib/../main.h **** //ASCII-Zeichen
   6:lib/../main.h **** //\a The “alert” character, Ctrl-g, ASCII code 7 (BEL). (This usually makes some sort of audibl
   7:lib/../main.h **** //\b Backspace, Ctrl-h, ASCII code 8 (BS).
   8:lib/../main.h **** //\f Formfeed, Ctrl-l, ASCII code 12 (FF).
   9:lib/../main.h **** //\n Newline, Ctrl-j, ASCII code 10 (LF).
  10:lib/../main.h **** //\r Carriage return, Ctrl-m, ASCII code 13 (CR).
  11:lib/../main.h **** //\t Horizontal TAB, Ctrl-i, ASCII code 9 (HT).
  12:lib/../main.h **** //\v Vertical tab, Ctrl-k, ASCII code 11 (VT).
  13:lib/../main.h **** //\nnn The octal value nnn, where nnn stands for 1 to 3 digits between ‘0’ and ‘7’. For exa
  14:lib/../main.h **** //\xhh...The hexadecimal value hh, where hh stands for a sequence of hexadecimal digits (‘0’–
  15:lib/../main.h **** //       Like the same construct in ISO C, the escape sequence continues until 
  16:lib/../main.h **** //       the first nonhexadecimal digit is seen. (c.e.) However, using more 
  17:lib/../main.h **** //       than two hexadecimal digits produces undefined results. 
  18:lib/../main.h **** //       (The ‘\x’ escape sequence is not allowed in POSIX awk.)
  19:lib/../main.h **** //\/ A literal slash (necessary for regexp constants only). This sequence 
  20:lib/../main.h **** //       is used when you want to write a regexp constant that contains a 
  21:lib/../main.h **** //       slash. Because the regexp is delimited by slashes, you need to 
  22:lib/../main.h **** //       escape the slash that is part of the pattern, in order to tell 
  23:lib/../main.h **** //       awk to keep processing the rest of the regexp.
  24:lib/../main.h **** //\"  A literal double quote (necessary for string constants only). 
  25:lib/../main.h **** //       This sequence is used when you want to write a string constant 
  26:lib/../main.h **** //       that contains a double quote. Because the string is delimited by 
  27:lib/../main.h **** //       double quotes, you need to escape the quote that is part of 
  28:lib/../main.h **** //       the string, in order to tell awk to keep processing the rest
  29:lib/../main.h **** //       of the string.#define ANSI_BLACK   30
  30:lib/../main.h **** 
  31:lib/../main.h **** //https://www-user.tu-chemnitz.de/~heha/hsn/terminal/terminal.htm
  32:lib/../main.h **** //https://gist.github.com/ConnerWill/d4b6c776b509add763e17f9f113fd25b
  33:lib/../main.h **** //Cursor Control
  34:lib/../main.h **** #define VT100_CURSORHOME      "\e[H"
  35:lib/../main.h **** #define VT100_CLEARSCREEN     "\e[2J"
  36:lib/../main.h **** #define VT100_GOTOYX          "\e[%d;%dH"
  37:lib/../main.h **** #define VT100_SAVEPOS         "\e7"
  38:lib/../main.h **** #define VT100_RESTOREPOS      "\e8"
  39:lib/../main.h **** #define VT100_ROLLY1Y2        "\e[%d;%dr"
  40:lib/../main.h **** #define VT100_ROLLOFF         "\e[r"
  41:lib/../main.h **** //Erase Functions
  42:lib/../main.h **** #define VT100_ERASEFROMCURSOR "\e[0J"
  43:lib/../main.h **** #define VT100_ERASETOCURSOR   "\e[1J"
  44:lib/../main.h **** #define VT100_ERASESCREEN     "\e[2J"
  45:lib/../main.h **** #define VT100_DEL_UNTILEOL    "\e[K"
  46:lib/../main.h **** #define VT100_DEL_TOCUR       "\e[1K"
  47:lib/../main.h **** #define VT100_DEL_LINE        "\e[2K"
  48:lib/../main.h **** //Color/Graphics Mode
  49:lib/../main.h **** #define VT100_DEFAULT         "\e[0m"  //stellt hellgraue Schrift auf schwarzem Grund ein
  50:lib/../main.h **** #define VT100_FETT              "\e[1m"
  51:lib/../main.h **** #define VT100_FETT_AUS          "\e[22m"
  52:lib/../main.h **** #define VT100_UNTERSTRICHEN     "\e[4m"
  53:lib/../main.h **** #define VT100_UNTERSTRICHEN_AUS "\e[24m"
  54:lib/../main.h **** #define VT100_BLINKEN           "\e[5m"
  55:lib/../main.h **** #define VT100_BLINKEN_AUS       "\e[25m"
  56:lib/../main.h **** #define VT100_INVERS            "\e[7m"
  57:lib/../main.h **** #define VT100_INVERS_AUS        "\e[27m"
  58:lib/../main.h **** #define VT100_UNSICHTBAR        "\e[8m"
  59:lib/../main.h **** #define VT100_SICHTBAR          "\e[28m"
  60:lib/../main.h **** #define VT100_VORDERGRUND_SCHWARZ "\e[30m"
  61:lib/../main.h **** #define VT100_VORDERGRUND_ROT     "\e[31m"
  62:lib/../main.h **** #define VT100_VORDERGRUND_GRUEN   "\e[32m"
  63:lib/../main.h **** #define VT100_VORDERGRUND_BRAUN   "\e[33m"
  64:lib/../main.h **** #define VT100_VORDERGRUND_BLAU    "\e[34m"
  65:lib/../main.h **** #define VT100_VORDERGRUND_BLAUROT "\e[35m"
  66:lib/../main.h **** #define VT100_VORDERGRUND_ZYAN    "\e[36m"
  67:lib/../main.h **** #define VT100_VORDERGRUND_WEISS   "\e[37m"  //Default
  68:lib/../main.h **** #define VT100_VORDERGRUND_DEFAULT "\e[39m"  //Nicht VT100
  69:lib/../main.h **** #define VT100_HINTERGRUND_SCHWARZ "\e[40m"  //Default
  70:lib/../main.h **** #define VT100_HINTERGRUND_ROT     "\e[41m"  
  71:lib/../main.h **** #define VT100_HINTERGRUND_GRUEN   "\e[42m"  
  72:lib/../main.h **** #define VT100_HINTERGRUND_BRAUN   "\e[43m"  
  73:lib/../main.h **** #define VT100_HINTERGRUND_BLAU    "\e[44m"  
  74:lib/../main.h **** #define VT100_HINTERGRUND_BLAUROT "\e[45m"  
  75:lib/../main.h **** #define VT100_HINTERGRUND_ZYAN    "\e[46m"  
  76:lib/../main.h **** #define VT100_HINTERGRUND_WEISS   "\e[47m"  
  77:lib/../main.h **** #define VT100_HINTERGRUND_DEFAULT "\e[49m"
  78:lib/../main.h **** 
  79:lib/../main.h ****                                                          /* Main Clock [Hz] */
  80:lib/../main.h **** #define MAINCK            18432000
  81:lib/../main.h ****                                      /* Maseter Clock (PLLRC div by 2) [Hz] */
  82:lib/../main.h **** #define MCK               47923200
  83:lib/../main.h ****                                              /* System clock tick rate [Hz] */
  84:lib/../main.h **** #define BSP_TICKS_PER_SEC 1000
  85:lib/../main.h **** 
  86:lib/../main.h **** //#define NODISCARD __attribute__((warn_unused_result))  
  87:lib/../main.h **** #define NODISCARD  [[nodiscard]]
  88:lib/../main.h **** 
  89:lib/../main.h **** typedef enum __attribute__((packed)) {ASYNCSYNC_NONBLOCK,ASYNCSYNC_BLOCK,ASYNCSYNC_ASYNCGET} asyncs
  90:lib/../main.h **** 
  91:lib/../main.h **** typedef enum {SENSOR_1,SENSOR_2,SENSOR_3,SENSOR_4,SENSOR_MAX} sensor_t;
  92:lib/../main.h **** 
  93:lib/../main.h **** typedef enum {MOTOR_A,MOTOR_B,MOTOR_C} motor_t;
  94:lib/../main.h **** 
  95:lib/../main.h **** typedef enum {MOTOR_BREAK, MOTOR_FLOAT} motor_zustand_t;
  96:lib/../main.h **** 
  97:lib/../main.h **** typedef enum {SENSOR_OFF=0x00, SENSOR_9V_PULSED=0x01, SENSOR_9V=0x10 } sensor_power_t;
  98:lib/../main.h **** 
  99:lib/../main.h **** typedef enum {BATTERY_AA, BATTERY_ACCU} battery_t;
 100:lib/../main.h **** 
 101:lib/../main.h **** typedef struct {
 102:lib/../main.h **** 	uint8_t orange : 1;
 103:lib/../main.h **** 	uint8_t left : 1;
 104:lib/../main.h **** 	uint8_t right : 1;
 105:lib/../main.h **** 	uint8_t grey : 1;
 106:lib/../main.h **** 	uint8_t reserved : 4;
 107:lib/../main.h **** } button_t;
 108:lib/../main.h **** 
 109:lib/../main.h **** #define I2C_BAUDRATE 10000  //Orignal 9600
 110:lib/../main.h **** 
 111:lib/../main.h **** extern uint32_t __stack_start__[];   //Definiert in link.ld
 112:lib/../main.h **** extern uint32_t __stack_end__;       //Definiert in link.ld
 113:lib/../main.h **** #define STACK_FILL 0x11111111
 114:lib/../main.h **** 
 115:lib/../main.h **** static __inline__ void stack_fill(void) __attribute__((always_inline));
 116:lib/../main.h **** static __inline__ void stack_fill(void)
 117:lib/../main.h **** {
 118:lib/../main.h **** 	         uint32_t *ptr;
 119:lib/../main.h **** 	register uint32_t *sp asm("r13");
 120:lib/../main.h **** 	for(ptr=&__stack_start__[0];ptr<sp;ptr++)
 2877              		.loc 4 120 9
 2878 0114 2C359FE5 		ldr	r3, .L180+80
 2879 0118 14300BE5 		str	r3, [fp, #-20]
 2880              		.loc 4 120 2
 2881 011c 050000EA 		b	.L152
 2882              	.L153:
 121:lib/../main.h **** 		*ptr=STACK_FILL;
 2883              		.loc 4 121 7
 2884 0120 14301BE5 		ldr	r3, [fp, #-20]
 2885 0124 20259FE5 		ldr	r2, .L180+84
 2886 0128 002083E5 		str	r2, [r3]
 120:lib/../main.h **** 		*ptr=STACK_FILL;
 2887              		.loc 4 120 40 discriminator 3
 2888 012c 14301BE5 		ldr	r3, [fp, #-20]
 2889 0130 043083E2 		add	r3, r3, #4
 2890 0134 14300BE5 		str	r3, [fp, #-20]
 2891              	.L152:
 120:lib/../main.h **** 		*ptr=STACK_FILL;
 2892              		.loc 4 120 33 discriminator 1
 2893 0138 0D20A0E1 		mov	r2, sp
 2894 013c 14301BE5 		ldr	r3, [fp, #-20]
 2895 0140 020053E1 		cmp	r3, r2
 2896 0144 F5FFFF3A 		bcc	.L153
 122:lib/../main.h **** }
 2897              		.loc 4 122 1
 2898 0148 0000A0E1 		nop
 2899              	.L154:
 2900              	.LBE9:
 2901              	.LBE8:
 647:main.c        ****                                AT91C_WDTC_WDDBGHLT |      /*Debug Halt */
 648:main.c        ****                                AT91C_WDTC_WDIDLEHLT;      /*Idle Halt  */
 649:main.c        **** #else
 650:main.c        **** #if 0
 651:main.c        **** 	/* Watchdog Enable */
 652:main.c        **** 	/* Da in dieser Version kein zyklischer Reset des Watchdogs */
 653:main.c        **** 	/* vorhanden ist, wird von einem Watchdog Enable abgesehen  */
 654:main.c        **** 	/* Mit Reset wird der Wachdog aktiviert!                    */
 655:main.c        **** #else
 656:main.c        **** /* Watchdog Disable */
 657:main.c        **** /* Mode-Register kann nur einmal beschrieben werden */
 658:main.c        **** AT91C_BASE_WDTC->WDTC_WDMR = 0xFFF | AT91C_WDTC_WDDIS | /*WD Disable */
 659:main.c        ****                              AT91C_WDTC_WDDBGHLT |      /*Debug Halt */
 660:main.c        ****                              AT91C_WDTC_WDIDLEHLT;      /*Idle Halt  */
 661:main.c        **** #endif
 662:main.c        **** #endif
 663:main.c        ****   // Vorangegangenen Stackaufbau 'löschen'
 664:main.c        ****   stack_fill();
 665:main.c        ****   // Label, so das mit 'go start' hierin gesprungen werden kann
 666:main.c        **** start:
 667:main.c        ****   __attribute__((unused));
 668:main.c        ****   uint32_t start_tick = systick_get_ms();
 2902              		.loc 1 668 25
 2903 014c FC349FE5 		ldr	r3, .L180+88
 2904 0150 0FE0A0E1 		mov	lr, pc
 2905 0154 13FF2FE1 		bx	r3
 2906              	.LVL37:
 2907 0158 08000BE5 		str	r0, [fp, #-8]
 669:main.c        ****   uint32_t zeitscheibe = 0;
 2908              		.loc 1 669 12
 2909 015c 0030A0E3 		mov	r3, #0
 2910 0160 0C300BE5 		str	r3, [fp, #-12]
 670:main.c        ****   char *task_aktiv = "";
 2911              		.loc 1 670 9
 2912 0164 E8349FE5 		ldr	r3, .L180+92
 2913 0168 10300BE5 		str	r3, [fp, #-16]
 2914              	.L179:
 671:main.c        ****   while (1) {
 672:main.c        ****     // Warten bis zum nächsten TimeSlot
 673:main.c        ****     while ((int)(start_tick - systick_get_ms()) > 0)
 2915              		.loc 1 673 11
 2916 016c 0000A0E1 		nop
 2917              	.L155:
 2918              		.loc 1 673 31 discriminator 1
 2919 0170 D8349FE5 		ldr	r3, .L180+88
 2920 0174 0FE0A0E1 		mov	lr, pc
 2921 0178 13FF2FE1 		bx	r3
 2922              	.LVL38:
 2923 017c 0020A0E1 		mov	r2, r0
 2924              		.loc 1 673 29 discriminator 1
 2925 0180 08301BE5 		ldr	r3, [fp, #-8]
 2926 0184 023043E0 		sub	r3, r3, r2
 2927              		.loc 1 673 49 discriminator 1
 2928 0188 000053E3 		cmp	r3, #0
 2929 018c F7FFFFCA 		bgt	.L155
 674:main.c        ****       ;
 675:main.c        ****     start_tick += ZYKLUS_MS;
 2930              		.loc 1 675 16
 2931 0190 08301BE5 		ldr	r3, [fp, #-8]
 2932 0194 023083E2 		add	r3, r3, #2
 2933 0198 08300BE5 		str	r3, [fp, #-8]
 2934              	.L156:
 676:main.c        ****     // Label, so das mit 'go zyklus' hierhin gesprungen werden kann
 677:main.c        ****   zyklus:
 678:main.c        ****     __attribute__((unused)) if ((zeitscheibe & 0b000000001) == 0b000000001) {
 2935              		.loc 1 678 46
 2936 019c 0C301BE5 		ldr	r3, [fp, #-12]
 2937 01a0 013003E2 		and	r3, r3, #1
 2938              		.loc 1 678 32
 2939 01a4 000053E3 		cmp	r3, #0
 2940 01a8 0500000A 		beq	.L157
 679:main.c        ****       task_aktiv = "4ms";
 2941              		.loc 1 679 18
 2942 01ac A4349FE5 		ldr	r3, .L180+96
 2943 01b0 10300BE5 		str	r3, [fp, #-16]
 680:main.c        ****       task_4ms();
 2944              		.loc 1 680 7
 2945 01b4 A0349FE5 		ldr	r3, .L180+100
 2946 01b8 0FE0A0E1 		mov	lr, pc
 2947 01bc 13FF2FE1 		bx	r3
 2948              	.LVL39:
 2949 01c0 440000EA 		b	.L158
 2950              	.L157:
 681:main.c        ****     }
 682:main.c        ****     else if ((zeitscheibe & 0b000000011) == 0b000000010) {
 2951              		.loc 1 682 27
 2952 01c4 0C301BE5 		ldr	r3, [fp, #-12]
 2953 01c8 033003E2 		and	r3, r3, #3
 2954              		.loc 1 682 13
 2955 01cc 020053E3 		cmp	r3, #2
 2956 01d0 0500001A 		bne	.L159
 683:main.c        ****       task_aktiv = "8ms";
 2957              		.loc 1 683 18
 2958 01d4 84349FE5 		ldr	r3, .L180+104
 2959 01d8 10300BE5 		str	r3, [fp, #-16]
 684:main.c        ****       task_8ms();
 2960              		.loc 1 684 7
 2961 01dc 80349FE5 		ldr	r3, .L180+108
 2962 01e0 0FE0A0E1 		mov	lr, pc
 2963 01e4 13FF2FE1 		bx	r3
 2964              	.LVL40:
 2965 01e8 3A0000EA 		b	.L158
 2966              	.L159:
 685:main.c        ****     }
 686:main.c        ****     else if ((zeitscheibe & 0b000000111) == 0b000000100) {
 2967              		.loc 1 686 27
 2968 01ec 0C301BE5 		ldr	r3, [fp, #-12]
 2969 01f0 073003E2 		and	r3, r3, #7
 2970              		.loc 1 686 13
 2971 01f4 040053E3 		cmp	r3, #4
 2972 01f8 0500001A 		bne	.L160
 687:main.c        ****       task_aktiv = "16ms";
 2973              		.loc 1 687 18
 2974 01fc 64349FE5 		ldr	r3, .L180+112
 2975 0200 10300BE5 		str	r3, [fp, #-16]
 688:main.c        ****       task_16ms();
 2976              		.loc 1 688 7
 2977 0204 60349FE5 		ldr	r3, .L180+116
 2978 0208 0FE0A0E1 		mov	lr, pc
 2979 020c 13FF2FE1 		bx	r3
 2980              	.LVL41:
 2981 0210 300000EA 		b	.L158
 2982              	.L160:
 689:main.c        ****     }
 690:main.c        ****     else if ((zeitscheibe & 0b000001111) == 0b000001000) {
 2983              		.loc 1 690 27
 2984 0214 0C301BE5 		ldr	r3, [fp, #-12]
 2985 0218 0F3003E2 		and	r3, r3, #15
 2986              		.loc 1 690 13
 2987 021c 080053E3 		cmp	r3, #8
 2988 0220 0500001A 		bne	.L161
 691:main.c        ****       task_aktiv = "32ms";
 2989              		.loc 1 691 18
 2990 0224 44349FE5 		ldr	r3, .L180+120
 2991 0228 10300BE5 		str	r3, [fp, #-16]
 692:main.c        ****       task_32ms();
 2992              		.loc 1 692 7
 2993 022c 40349FE5 		ldr	r3, .L180+124
 2994 0230 0FE0A0E1 		mov	lr, pc
 2995 0234 13FF2FE1 		bx	r3
 2996              	.LVL42:
 2997 0238 260000EA 		b	.L158
 2998              	.L161:
 693:main.c        ****     }
 694:main.c        ****     else if ((zeitscheibe & 0b000011111) == 0b000010000) {
 2999              		.loc 1 694 27
 3000 023c 0C301BE5 		ldr	r3, [fp, #-12]
 3001 0240 1F3003E2 		and	r3, r3, #31
 3002              		.loc 1 694 13
 3003 0244 100053E3 		cmp	r3, #16
 3004 0248 0500001A 		bne	.L162
 695:main.c        ****       task_aktiv = "64ms";
 3005              		.loc 1 695 18
 3006 024c 24349FE5 		ldr	r3, .L180+128
 3007 0250 10300BE5 		str	r3, [fp, #-16]
 696:main.c        ****       task_64ms();
 3008              		.loc 1 696 7
 3009 0254 20349FE5 		ldr	r3, .L180+132
 3010 0258 0FE0A0E1 		mov	lr, pc
 3011 025c 13FF2FE1 		bx	r3
 3012              	.LVL43:
 3013 0260 1C0000EA 		b	.L158
 3014              	.L162:
 697:main.c        ****     }
 698:main.c        ****     else if ((zeitscheibe & 0b000111111) == 0b000100000) {
 3015              		.loc 1 698 27
 3016 0264 0C301BE5 		ldr	r3, [fp, #-12]
 3017 0268 3F3003E2 		and	r3, r3, #63
 3018              		.loc 1 698 13
 3019 026c 200053E3 		cmp	r3, #32
 3020 0270 0500001A 		bne	.L163
 699:main.c        ****       task_aktiv = "128ms";
 3021              		.loc 1 699 18
 3022 0274 04349FE5 		ldr	r3, .L180+136
 3023 0278 10300BE5 		str	r3, [fp, #-16]
 700:main.c        ****       task_128ms();
 3024              		.loc 1 700 7
 3025 027c 00349FE5 		ldr	r3, .L180+140
 3026 0280 0FE0A0E1 		mov	lr, pc
 3027 0284 13FF2FE1 		bx	r3
 3028              	.LVL44:
 3029 0288 120000EA 		b	.L158
 3030              	.L163:
 701:main.c        ****     }
 702:main.c        ****     else if ((zeitscheibe & 0b001111111) == 0b001000000) {
 3031              		.loc 1 702 27
 3032 028c 0C301BE5 		ldr	r3, [fp, #-12]
 3033 0290 7F3003E2 		and	r3, r3, #127
 3034              		.loc 1 702 13
 3035 0294 400053E3 		cmp	r3, #64
 3036 0298 0500001A 		bne	.L164
 703:main.c        ****       task_aktiv = "256ms";
 3037              		.loc 1 703 18
 3038 029c E4339FE5 		ldr	r3, .L180+144
 3039 02a0 10300BE5 		str	r3, [fp, #-16]
 704:main.c        ****       task_256ms();
 3040              		.loc 1 704 7
 3041 02a4 E0339FE5 		ldr	r3, .L180+148
 3042 02a8 0FE0A0E1 		mov	lr, pc
 3043 02ac 13FF2FE1 		bx	r3
 3044              	.LVL45:
 3045 02b0 080000EA 		b	.L158
 3046              	.L164:
 705:main.c        ****     }
 706:main.c        ****     else if ((zeitscheibe & 0b011111111) == 0b010000000) {
 3047              		.loc 1 706 27
 3048 02b4 0C301BE5 		ldr	r3, [fp, #-12]
 3049 02b8 FF3003E2 		and	r3, r3, #255
 3050              		.loc 1 706 13
 3051 02bc 800053E3 		cmp	r3, #128
 3052 02c0 0400001A 		bne	.L158
 707:main.c        ****       task_aktiv = "512ms";
 3053              		.loc 1 707 18
 3054 02c4 C4339FE5 		ldr	r3, .L180+152
 3055 02c8 10300BE5 		str	r3, [fp, #-16]
 708:main.c        ****       task_512ms();
 3056              		.loc 1 708 7
 3057 02cc C0339FE5 		ldr	r3, .L180+156
 3058 02d0 0FE0A0E1 		mov	lr, pc
 3059 02d4 13FF2FE1 		bx	r3
 3060              	.LVL46:
 3061              	.L158:
 709:main.c        ****     }
 710:main.c        ****     // Zeit für IDLE-Task verfügbar
 711:main.c        ****     if ((int)(start_tick - systick_get_ms()) >= IDLE_MS) {
 3062              		.loc 1 711 28
 3063 02d8 70339FE5 		ldr	r3, .L180+88
 3064 02dc 0FE0A0E1 		mov	lr, pc
 3065 02e0 13FF2FE1 		bx	r3
 3066              	.LVL47:
 3067 02e4 0020A0E1 		mov	r2, r0
 3068              		.loc 1 711 26 discriminator 1
 3069 02e8 08301BE5 		ldr	r3, [fp, #-8]
 3070 02ec 023043E0 		sub	r3, r3, r2
 3071              		.loc 1 711 8 discriminator 1
 3072 02f0 000053E3 		cmp	r3, #0
 3073 02f4 040000DA 		ble	.L165
 712:main.c        ****       task_aktiv = "Idle";
 3074              		.loc 1 712 18
 3075 02f8 98339FE5 		ldr	r3, .L180+160
 3076 02fc 10300BE5 		str	r3, [fp, #-16]
 713:main.c        ****       task_idle();
 3077              		.loc 1 713 7
 3078 0300 94339FE5 		ldr	r3, .L180+164
 3079 0304 0FE0A0E1 		mov	lr, pc
 3080 0308 13FF2FE1 		bx	r3
 3081              	.LVL48:
 3082              	.L165:
 714:main.c        ****     }
 715:main.c        ****     // Max. Zeitdauer einer Zeitscheibe überschritten?
 716:main.c        ****     if ((int)(start_tick - systick_get_ms()) <= 0) {
 3083              		.loc 1 716 28
 3084 030c 3C339FE5 		ldr	r3, .L180+88
 3085 0310 0FE0A0E1 		mov	lr, pc
 3086 0314 13FF2FE1 		bx	r3
 3087              	.LVL49:
 3088 0318 0020A0E1 		mov	r2, r0
 3089              		.loc 1 716 26 discriminator 1
 3090 031c 08301BE5 		ldr	r3, [fp, #-8]
 3091 0320 023043E0 		sub	r3, r3, r2
 3092              		.loc 1 716 8 discriminator 1
 3093 0324 000053E3 		cmp	r3, #0
 3094 0328 2C0000CA 		bgt	.L166
 717:main.c        ****       main_data.term_status |= term_string(
 3095              		.loc 1 717 32
 3096 032c 0010A0E3 		mov	r1, #0
 3097 0330 68039FE5 		ldr	r0, .L180+168
 3098 0334 F0329FE5 		ldr	r3, .L180+52
 3099 0338 0FE0A0E1 		mov	lr, pc
 3100 033c 13FF2FE1 		bx	r3
 3101              	.LVL50:
 3102 0340 0030A0E1 		mov	r3, r0
 3103              		.loc 1 717 16 discriminator 1
 3104 0344 58239FE5 		ldr	r2, .L180+172
 3105 0348 D020D2E1 		ldrsb	r2, [r2]
 3106              		.loc 1 717 29 discriminator 1
 3107 034c 033CA0E1 		lsl	r3, r3, #24
 3108 0350 433CA0E1 		asr	r3, r3, #24
 3109 0354 033082E1 		orr	r3, r2, r3
 3110 0358 033CA0E1 		lsl	r3, r3, #24
 3111 035c 432CA0E1 		asr	r2, r3, #24
 3112 0360 3C339FE5 		ldr	r3, .L180+172
 3113 0364 0020C3E5 		strb	r2, [r3]
 718:main.c        ****           VT100_VORDERGRUND_ROT "Timing durch '", ASYNCSYNC_NONBLOCK);
 719:main.c        ****       main_data.term_status |= term_string(task_aktiv, ASYNCSYNC_NONBLOCK);
 3114              		.loc 1 719 32
 3115 0368 0010A0E3 		mov	r1, #0
 3116 036c 10001BE5 		ldr	r0, [fp, #-16]
 3117 0370 B4329FE5 		ldr	r3, .L180+52
 3118 0374 0FE0A0E1 		mov	lr, pc
 3119 0378 13FF2FE1 		bx	r3
 3120              	.LVL51:
 3121 037c 0030A0E1 		mov	r3, r0
 3122              		.loc 1 719 16 discriminator 1
 3123 0380 1C239FE5 		ldr	r2, .L180+172
 3124 0384 D020D2E1 		ldrsb	r2, [r2]
 3125              		.loc 1 719 29 discriminator 1
 3126 0388 033CA0E1 		lsl	r3, r3, #24
 3127 038c 433CA0E1 		asr	r3, r3, #24
 3128 0390 033082E1 		orr	r3, r2, r3
 3129 0394 033CA0E1 		lsl	r3, r3, #24
 3130 0398 432CA0E1 		asr	r2, r3, #24
 3131 039c 00339FE5 		ldr	r3, .L180+172
 3132 03a0 0020C3E5 		strb	r2, [r3]
 720:main.c        ****       main_data.term_status |= term_string(
 3133              		.loc 1 720 32
 3134 03a4 0010A0E3 		mov	r1, #0
 3135 03a8 F8029FE5 		ldr	r0, .L180+176
 3136 03ac 78329FE5 		ldr	r3, .L180+52
 3137 03b0 0FE0A0E1 		mov	lr, pc
 3138 03b4 13FF2FE1 		bx	r3
 3139              	.LVL52:
 3140 03b8 0030A0E1 		mov	r3, r0
 3141              		.loc 1 720 16 discriminator 1
 3142 03bc E0229FE5 		ldr	r2, .L180+172
 3143 03c0 D020D2E1 		ldrsb	r2, [r2]
 3144              		.loc 1 720 29 discriminator 1
 3145 03c4 033CA0E1 		lsl	r3, r3, #24
 3146 03c8 433CA0E1 		asr	r3, r3, #24
 3147 03cc 033082E1 		orr	r3, r2, r3
 3148 03d0 033CA0E1 		lsl	r3, r3, #24
 3149 03d4 432CA0E1 		asr	r2, r3, #24
 3150 03d8 C4329FE5 		ldr	r3, .L180+172
 3151 03dc 0020C3E5 		strb	r2, [r3]
 3152              	.L166:
 721:main.c        ****           "' verletzt\n\r" VT100_VORDERGRUND_DEFAULT, ASYNCSYNC_NONBLOCK);
 722:main.c        ****     }
 723:main.c        ****     // Zeitscheibe erhöhen
 724:main.c        ****     zeitscheibe++;
 3153              		.loc 1 724 16
 3154 03e0 0C301BE5 		ldr	r3, [fp, #-12]
 3155 03e4 013083E2 		add	r3, r3, #1
 3156 03e8 0C300BE5 		str	r3, [fp, #-12]
 3157              	.LBB10:
 3158              	.LBB11:
 123:lib/../main.h **** 
 124:lib/../main.h **** static __inline__ int32_t stack_check(void) __attribute__((always_inline));
 125:lib/../main.h **** static __inline__ int32_t stack_check(void)
 126:lib/../main.h **** {
 127:lib/../main.h **** 	         uint32_t *ptr;
 128:lib/../main.h **** //	register uint32_t *sp asm("r13");
 129:lib/../main.h **** 	for(ptr=&__stack_start__[0];*ptr==STACK_FILL;++ptr);
 3159              		.loc 4 129 9
 3160 03ec 54329FE5 		ldr	r3, .L180+80
 3161 03f0 18300BE5 		str	r3, [fp, #-24]
 3162              		.loc 4 129 2
 3163 03f4 020000EA 		b	.L167
 3164              	.L168:
 3165              		.loc 4 129 47 discriminator 3
 3166 03f8 18301BE5 		ldr	r3, [fp, #-24]
 3167 03fc 043083E2 		add	r3, r3, #4
 3168 0400 18300BE5 		str	r3, [fp, #-24]
 3169              	.L167:
 3170              		.loc 4 129 30 discriminator 1
 3171 0404 18301BE5 		ldr	r3, [fp, #-24]
 3172 0408 003093E5 		ldr	r3, [r3]
 3173              		.loc 4 129 34 discriminator 1
 3174 040c 38229FE5 		ldr	r2, .L180+84
 3175 0410 020053E1 		cmp	r3, r2
 3176 0414 F7FFFF0A 		beq	.L168
 130:lib/../main.h **** 	return (int32_t)(ptr-&__stack_start__[0]);
 3177              		.loc 4 130 22
 3178 0418 18301BE5 		ldr	r3, [fp, #-24]
 3179 041c 24229FE5 		ldr	r2, .L180+80
 3180 0420 023043E0 		sub	r3, r3, r2
 3181              		.loc 4 130 9
 3182 0424 4331A0E1 		asr	r3, r3, #2
 3183              	.LBE11:
 3184              	.LBE10:
 725:main.c        **** 
 726:main.c        ****     // Stack Testen
 727:main.c        ****     if (stack_check() < (1 * 4)) {
 3185              		.loc 1 727 8 discriminator 1
 3186 0428 030053E3 		cmp	r3, #3
 3187 042c 350000CA 		bgt	.L170
 3188              	.LBB12:
 728:main.c        ****       static uint8_t stack_cnt = 0;
 729:main.c        ****       if (stack_cnt == 0) {
 3189              		.loc 1 729 21
 3190 0430 74329FE5 		ldr	r3, .L180+180
 3191 0434 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 3192              		.loc 1 729 10
 3193 0438 000053E3 		cmp	r3, #0
 3194 043c 3100001A 		bne	.L170
 730:main.c        ****         stack_cnt = 1;
 3195              		.loc 1 730 19
 3196 0440 64329FE5 		ldr	r3, .L180+180
 3197 0444 0120A0E3 		mov	r2, #1
 3198 0448 0020C3E5 		strb	r2, [r3]
 731:main.c        ****         main_data.term_status |= term_string(
 3199              		.loc 1 731 34
 3200 044c 0010A0E3 		mov	r1, #0
 3201 0450 58029FE5 		ldr	r0, .L180+184
 3202 0454 D0319FE5 		ldr	r3, .L180+52
 3203 0458 0FE0A0E1 		mov	lr, pc
 3204 045c 13FF2FE1 		bx	r3
 3205              	.LVL53:
 3206 0460 0030A0E1 		mov	r3, r0
 3207              		.loc 1 731 18 discriminator 1
 3208 0464 38229FE5 		ldr	r2, .L180+172
 3209 0468 D020D2E1 		ldrsb	r2, [r2]
 3210              		.loc 1 731 31 discriminator 1
 3211 046c 033CA0E1 		lsl	r3, r3, #24
 3212 0470 433CA0E1 		asr	r3, r3, #24
 3213 0474 033082E1 		orr	r3, r2, r3
 3214 0478 033CA0E1 		lsl	r3, r3, #24
 3215 047c 432CA0E1 		asr	r2, r3, #24
 3216 0480 1C329FE5 		ldr	r3, .L180+172
 3217 0484 0020C3E5 		strb	r2, [r3]
 732:main.c        ****             VT100_VORDERGRUND_ROT "Stack overflow durch '", ASYNCSYNC_NONBLOCK);
 733:main.c        ****         main_data.term_status |= term_string(task_aktiv, ASYNCSYNC_NONBLOCK);
 3218              		.loc 1 733 34
 3219 0488 0010A0E3 		mov	r1, #0
 3220 048c 10001BE5 		ldr	r0, [fp, #-16]
 3221 0490 94319FE5 		ldr	r3, .L180+52
 3222 0494 0FE0A0E1 		mov	lr, pc
 3223 0498 13FF2FE1 		bx	r3
 3224              	.LVL54:
 3225 049c 0030A0E1 		mov	r3, r0
 3226              		.loc 1 733 18 discriminator 1
 3227 04a0 FC219FE5 		ldr	r2, .L180+172
 3228 04a4 D020D2E1 		ldrsb	r2, [r2]
 3229              		.loc 1 733 31 discriminator 1
 3230 04a8 033CA0E1 		lsl	r3, r3, #24
 3231 04ac 433CA0E1 		asr	r3, r3, #24
 3232 04b0 033082E1 		orr	r3, r2, r3
 3233 04b4 033CA0E1 		lsl	r3, r3, #24
 3234 04b8 432CA0E1 		asr	r2, r3, #24
 3235 04bc E0319FE5 		ldr	r3, .L180+172
 3236 04c0 0020C3E5 		strb	r2, [r3]
 734:main.c        ****         main_data.term_status |=
 735:main.c        ****             term_string("'\n\r" VT100_VORDERGRUND_DEFAULT, ASYNCSYNC_NONBLOCK);
 3237              		.loc 1 735 13
 3238 04c4 0010A0E3 		mov	r1, #0
 3239 04c8 E4019FE5 		ldr	r0, .L180+188
 3240 04cc 58319FE5 		ldr	r3, .L180+52
 3241 04d0 0FE0A0E1 		mov	lr, pc
 3242 04d4 13FF2FE1 		bx	r3
 3243              	.LVL55:
 3244 04d8 0030A0E1 		mov	r3, r0
 734:main.c        ****         main_data.term_status |=
 3245              		.loc 1 734 18
 3246 04dc C0219FE5 		ldr	r2, .L180+172
 3247 04e0 D020D2E1 		ldrsb	r2, [r2]
 734:main.c        ****         main_data.term_status |=
 3248              		.loc 1 734 31
 3249 04e4 033CA0E1 		lsl	r3, r3, #24
 3250 04e8 433CA0E1 		asr	r3, r3, #24
 3251 04ec 033082E1 		orr	r3, r2, r3
 3252 04f0 033CA0E1 		lsl	r3, r3, #24
 3253 04f4 432CA0E1 		asr	r2, r3, #24
 3254 04f8 A4319FE5 		ldr	r3, .L180+172
 3255 04fc 0020C3E5 		strb	r2, [r3]
 3256              	.L171:
 736:main.c        ****         while (1)
 3257              		.loc 1 736 15
 3258 0500 0000A0E1 		nop
 3259 0504 FDFFFFEA 		b	.L171
 3260              	.L170:
 3261              	.LBE12:
 737:main.c        ****           ;
 738:main.c        ****       }
 739:main.c        ****     }
 740:main.c        **** 
 741:main.c        ****     // Batteriespannung überprüfen
 742:main.c        ****     // Ggf. schlägt die Unterspannungsprüfung im Akku zuvor ein!
 743:main.c        ****     if (nxt_avr_get_battery_raw() < ((2 * 3000 /*mV*/) << 10) / 14180) {
 3262              		.loc 1 743 9
 3263 0508 A8319FE5 		ldr	r3, .L180+192
 3264 050c 0FE0A0E1 		mov	lr, pc
 3265 0510 13FF2FE1 		bx	r3
 3266              	.LVL56:
 3267 0514 0030A0E1 		mov	r3, r0
 3268              		.loc 1 743 8 discriminator 1
 3269 0518 1B0E53E3 		cmp	r3, #432
 3270 051c 1D00008A 		bhi	.L172
 744:main.c        ****       if (main_data.lowbat_cnt++ > 100)
 3271              		.loc 1 744 20
 3272 0520 7C319FE5 		ldr	r3, .L180+172
 3273 0524 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3274              		.loc 1 744 31
 3275 0528 012083E2 		add	r2, r3, #1
 3276 052c FF1002E2 		and	r1, r2, #255
 3277 0530 6C219FE5 		ldr	r2, .L180+172
 3278 0534 0210C2E5 		strb	r1, [r2, #2]
 3279              		.loc 1 744 10
 3280 0538 640053E3 		cmp	r3, #100
 3281 053c 0100009A 		bls	.L173
 3282              	.L174:
 745:main.c        ****         while (1)
 3283              		.loc 1 745 15
 3284 0540 0000A0E1 		nop
 3285 0544 FDFFFFEA 		b	.L174
 3286              	.L173:
 746:main.c        ****           ;
 747:main.c        ****       else if (main_data.lowbat_cnt == 10)
 3287              		.loc 1 747 25
 3288 0548 54319FE5 		ldr	r3, .L180+172
 3289 054c 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3290              		.loc 1 747 15
 3291 0550 0A0053E3 		cmp	r3, #10
 3292 0554 1200001A 		bne	.L175
 748:main.c        ****         main_data.term_status |=
 749:main.c        ****             term_string(VT100_VORDERGRUND_ROT
 3293              		.loc 1 749 13
 3294 0558 0010A0E3 		mov	r1, #0
 3295 055c 58019FE5 		ldr	r0, .L180+196
 3296 0560 C4309FE5 		ldr	r3, .L180+52
 3297 0564 0FE0A0E1 		mov	lr, pc
 3298 0568 13FF2FE1 		bx	r3
 3299              	.LVL57:
 3300 056c 0030A0E1 		mov	r3, r0
 748:main.c        ****         main_data.term_status |=
 3301              		.loc 1 748 18
 3302 0570 2C219FE5 		ldr	r2, .L180+172
 3303 0574 D020D2E1 		ldrsb	r2, [r2]
 748:main.c        ****         main_data.term_status |=
 3304              		.loc 1 748 31
 3305 0578 033CA0E1 		lsl	r3, r3, #24
 3306 057c 433CA0E1 		asr	r3, r3, #24
 3307 0580 033082E1 		orr	r3, r2, r3
 3308 0584 033CA0E1 		lsl	r3, r3, #24
 3309 0588 432CA0E1 		asr	r2, r3, #24
 3310 058c 10319FE5 		ldr	r3, .L180+172
 3311 0590 0020C3E5 		strb	r2, [r3]
 3312 0594 020000EA 		b	.L175
 3313              	.L172:
 750:main.c        ****                         "\n\rLow Battery\n\r" VT100_VORDERGRUND_DEFAULT,
 751:main.c        ****                         ASYNCSYNC_NONBLOCK);
 752:main.c        ****     } else {
 753:main.c        ****       main_data.lowbat_cnt = 0;
 3314              		.loc 1 753 28
 3315 0598 04319FE5 		ldr	r3, .L180+172
 3316 059c 0020A0E3 		mov	r2, #0
 3317 05a0 0220C3E5 		strb	r2, [r3, #2]
 3318              	.L175:
 754:main.c        ****     }
 755:main.c        **** 
 756:main.c        ****     // Termstatus ueberpruefen
 757:main.c        ****     if (main_data.term_cnt == 0 && main_data.term_status != 0) {
 3319              		.loc 1 757 18
 3320 05a4 F8309FE5 		ldr	r3, .L180+172
 3321 05a8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3322              		.loc 1 757 8
 3323 05ac 000053E3 		cmp	r3, #0
 3324 05b0 EDFEFF1A 		bne	.L179
 3325              		.loc 1 757 45 discriminator 1
 3326 05b4 E8309FE5 		ldr	r3, .L180+172
 3327 05b8 D030D3E1 		ldrsb	r3, [r3]
 3328              		.loc 1 757 33 discriminator 1
 3329 05bc 000053E3 		cmp	r3, #0
 3330 05c0 E9FEFF0A 		beq	.L179
 758:main.c        ****       main_data.term_cnt++;
 3331              		.loc 1 758 16
 3332 05c4 D8309FE5 		ldr	r3, .L180+172
 3333 05c8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3334              		.loc 1 758 25
 3335 05cc 013083E2 		add	r3, r3, #1
 3336 05d0 FF2003E2 		and	r2, r3, #255
 3337 05d4 C8309FE5 		ldr	r3, .L180+172
 3338 05d8 0120C3E5 		strb	r2, [r3, #1]
 3339              	.L177:
 759:main.c        ****     overflow:
 760:main.c        ****       __attribute__((unused));
 761:main.c        **** 
 762:main.c        ****       (void)term_string(VT100_VORDERGRUND_ROT
 3340              		.loc 1 762 13
 3341 05dc 0110A0E3 		mov	r1, #1
 3342 05e0 D8009FE5 		ldr	r0, .L180+200
 3343 05e4 40309FE5 		ldr	r3, .L180+52
 3344 05e8 0FE0A0E1 		mov	lr, pc
 3345 05ec 13FF2FE1 		bx	r3
 3346              	.LVL58:
 3347              	.L178:
 763:main.c        ****                         "\n\rTerminal Overflow\n\r" VT100_VORDERGRUND_DEFAULT,
 764:main.c        ****                         ASYNCSYNC_BLOCK);
 765:main.c        ****       while (1)
 3348              		.loc 1 765 13
 3349 05f0 0000A0E1 		nop
 3350 05f4 FDFFFFEA 		b	.L178
 3351              	.L181:
 3352              		.align	2
 3353              	.L180:
 3354 05f8 00000000 		.word	aic_init
 3355 05fc 00000000 		.word	systick_init
 3356 0600 00000000 		.word	interrupts_enable
 3357 0604 00000000 		.word	nxt_avr_init
 3358 0608 00000000 		.word	udmon3_init
 3359 060c 00000000 		.word	term_init
 3360 0610 00000000 		.word	display_init
 3361 0614 00000000 		.word	ui_init
 3362 0618 00000000 		.word	schrittmotor_data
 3363 061c 00000000 		.word	schrittmotor_init
 3364 0620 00000000 		.word	display_clear
 3365 0624 00000000 		.word	display_update
 3366 0628 9C000000 		.word	.LC9
 3367 062c 00000000 		.word	term_string
 3368 0630 A4000000 		.word	.LC10
 3369 0634 B0000000 		.word	.LC11
 3370 0638 E0000000 		.word	.LC12
 3371 063c 1C010000 		.word	.LC13
 3372 0640 40FDFFFF 		.word	-704
 3373 0644 FF8F0030 		.word	805343231
 3374 0648 00000000 		.word	__stack_start__
 3375 064c 11111111 		.word	286331153
 3376 0650 00000000 		.word	systick_get_ms
 3377 0654 2C010000 		.word	.LC14
 3378 0658 30010000 		.word	.LC15
 3379 065c 00000000 		.word	task_4ms
 3380 0660 34010000 		.word	.LC16
 3381 0664 00000000 		.word	task_8ms
 3382 0668 38010000 		.word	.LC17
 3383 066c 00000000 		.word	task_16ms
 3384 0670 40010000 		.word	.LC18
 3385 0674 00000000 		.word	task_32ms
 3386 0678 48010000 		.word	.LC19
 3387 067c 00000000 		.word	task_64ms
 3388 0680 50010000 		.word	.LC20
 3389 0684 00000000 		.word	task_128ms
 3390 0688 58010000 		.word	.LC21
 3391 068c 00000000 		.word	task_256ms
 3392 0690 60010000 		.word	.LC22
 3393 0694 00000000 		.word	task_512ms
 3394 0698 68010000 		.word	.LC23
 3395 069c 00000000 		.word	task_idle
 3396 06a0 70010000 		.word	.LC24
 3397 06a4 00000000 		.word	main_data
 3398 06a8 84010000 		.word	.LC25
 3399 06ac 36030000 		.word	stack_cnt.0
 3400 06b0 98010000 		.word	.LC26
 3401 06b4 B4010000 		.word	.LC27
 3402 06b8 00000000 		.word	nxt_avr_get_battery_raw
 3403 06bc C0010000 		.word	.LC28
 3404 06c0 DC010000 		.word	.LC29
 3405              		.cfi_endproc
 3406              	.LFE33:
 3408              		.bss
 3409              		.align	2
 3410              	trace_index.3:
 3411 0324 00000000 		.space	4
 3413              		.align	2
 3414              	count.2:
 3415 0328 00000000 		.space	4
 3417              		.align	2
 3418              	linebuf.1:
 3419 032c 00000000 		.space	10
 3419      00000000 
 3419      0000
 3421              	stack_cnt.0:
 3422 0336 00       		.space	1
 3424              		.text
 3425              	.Letext0:
 3426              		.file 5 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/lib/gcc/arm-none-eabi/14.3.
 3427              		.file 6 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/machi
 3428              		.file 7 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/_
 3429              		.file 8 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/r
 3430              		.file 9 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/l
 3431              		.file 10 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/
 3432              		.file 11 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/stdi
 3433              		.file 12 "AT91SAM7S64.h"
 3434              		.file 13 "lib/nxt_avr.h"
 3435              		.file 14 "lib/systick.h"
 3436              		.file 15 "lib/display.h"
 3437              		.file 16 "lib/term.h"
 3438              		.file 17 "trace32/udmon3.h"
 3439              		.file 18 "lib/isr.h"
 3440              		.file 19 "lib/aic.h"
 3441              		.file 20 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccdVMVfm.s:19     .text.byte_fifo_put_possible:00000000 $a
     /tmp/ccdVMVfm.s:23     .text.byte_fifo_put_possible:00000000 byte_fifo_put_possible
     /tmp/ccdVMVfm.s:75     .text.byte_fifo_remain:00000000 $a
     /tmp/ccdVMVfm.s:79     .text.byte_fifo_remain:00000000 byte_fifo_remain
     /tmp/ccdVMVfm.s:133    .text.byte_fifo_used:00000000 $a
     /tmp/ccdVMVfm.s:137    .text.byte_fifo_used:00000000 byte_fifo_used
     /tmp/ccdVMVfm.s:188    .text.byte_fifo_put:00000000 $a
     /tmp/ccdVMVfm.s:192    .text.byte_fifo_put:00000000 byte_fifo_put
     /tmp/ccdVMVfm.s:277    .text.byte_fifo_get_possible:00000000 $a
     /tmp/ccdVMVfm.s:281    .text.byte_fifo_get_possible:00000000 byte_fifo_get_possible
     /tmp/ccdVMVfm.s:325    .text.byte_fifo_get:00000000 $a
     /tmp/ccdVMVfm.s:329    .text.byte_fifo_get:00000000 byte_fifo_get
     /tmp/ccdVMVfm.s:408    .text.byte_fifo_cb_put_possible:00000000 $a
     /tmp/ccdVMVfm.s:412    .text.byte_fifo_cb_put_possible:00000000 byte_fifo_cb_put_possible
     /tmp/ccdVMVfm.s:450    .text.byte_fifo_cb_put_possible:0000003c $d
     /tmp/ccdVMVfm.s:455    .text.byte_fifo_cb_put:00000000 $a
     /tmp/ccdVMVfm.s:459    .text.byte_fifo_cb_put:00000000 byte_fifo_cb_put
     /tmp/ccdVMVfm.s:520    .text.byte_fifo_cb_put:0000007c $d
     /tmp/ccdVMVfm.s:525    .text.byte_fifo_cb_get_possible:00000000 $a
     /tmp/ccdVMVfm.s:529    .text.byte_fifo_cb_get_possible:00000000 byte_fifo_cb_get_possible
     /tmp/ccdVMVfm.s:566    .text.byte_fifo_cb_get_possible:0000003c $d
     /tmp/ccdVMVfm.s:571    .text.byte_fifo_cb_get:00000000 $a
     /tmp/ccdVMVfm.s:575    .text.byte_fifo_cb_get:00000000 byte_fifo_cb_get
     /tmp/ccdVMVfm.s:614    .text.byte_fifo_cb_get:00000044 $d
     /tmp/ccdVMVfm.s:623    .bss:00000000 main_data
     /tmp/ccdVMVfm.s:620    .bss:00000000 $d
     /tmp/ccdVMVfm.s:626    .text._exit:00000000 $a
     /tmp/ccdVMVfm.s:631    .text._exit:00000000 _exit
     /tmp/ccdVMVfm.s:658    .bss:00000004 trace_buf0
     /tmp/ccdVMVfm.s:664    .bss:00000194 trace_buf1
     /tmp/ccdVMVfm.s:667    .text.trace_scope:00000000 $a
     /tmp/ccdVMVfm.s:672    .text.trace_scope:00000000 trace_scope
     /tmp/ccdVMVfm.s:760    .text.trace_scope:000000c8 $d
     /tmp/ccdVMVfm.s:3410   .bss:00000324 trace_index.3
     /tmp/ccdVMVfm.s:771    .data:00000000 pio
     /tmp/ccdVMVfm.s:768    .data:00000000 $d
     /tmp/ccdVMVfm.s:777    .data:00000004 pmc
     /tmp/ccdVMVfm.s:783    .data:00000008 pwm_ctl
     /tmp/ccdVMVfm.s:803    .data:0000000c schritt_mode2str
     /tmp/ccdVMVfm.s:787    .rodata:00000000 $d
     /tmp/ccdVMVfm.s:812    .data:00000020 schrittmotor_data
     /tmp/ccdVMVfm.s:865    .text.schrittmotor_init:00000000 $a
     /tmp/ccdVMVfm.s:870    .text.schrittmotor_init:00000000 schrittmotor_init
     /tmp/ccdVMVfm.s:1042   .text.schrittmotor_init:000001a0 $d
     /tmp/ccdVMVfm.s:1058   .text.schrittmotor_update:00000000 $a
     /tmp/ccdVMVfm.s:1063   .text.schrittmotor_update:00000000 schrittmotor_update
     /tmp/ccdVMVfm.s:1220   .text.schrittmotor_update:00000168 $d
     /tmp/ccdVMVfm.s:1226   .text.schrittmotor_process:00000000 $a
     /tmp/ccdVMVfm.s:1231   .text.schrittmotor_process:00000000 schrittmotor_process
     /tmp/ccdVMVfm.s:1740   .text.schrittmotor_process:00000440 $d
     /tmp/ccdVMVfm.s:1759   .text.ui_init:00000000 $a
     /tmp/ccdVMVfm.s:1764   .text.ui_init:00000000 ui_init
     /tmp/ccdVMVfm.s:1790   .text.ui_process:00000000 $a
     /tmp/ccdVMVfm.s:1795   .text.ui_process:00000000 ui_process
     /tmp/ccdVMVfm.s:2218   .text.ui_process:00000474 $d
     /tmp/ccdVMVfm.s:3414   .bss:00000328 count.2
     /tmp/ccdVMVfm.s:2231   .text.task_4ms:00000000 $a
     /tmp/ccdVMVfm.s:2236   .text.task_4ms:00000000 task_4ms
     /tmp/ccdVMVfm.s:2337   .text.task_4ms:000000ec $d
     /tmp/ccdVMVfm.s:2343   .text.task_8ms:00000000 $a
     /tmp/ccdVMVfm.s:2348   .text.task_8ms:00000000 task_8ms
     /tmp/ccdVMVfm.s:2374   .text.task_16ms:00000000 $a
     /tmp/ccdVMVfm.s:2379   .text.task_16ms:00000000 task_16ms
     /tmp/ccdVMVfm.s:2405   .text.task_32ms:00000000 $a
     /tmp/ccdVMVfm.s:2410   .text.task_32ms:00000000 task_32ms
     /tmp/ccdVMVfm.s:2436   .text.task_64ms:00000000 $a
     /tmp/ccdVMVfm.s:2441   .text.task_64ms:00000000 task_64ms
     /tmp/ccdVMVfm.s:2472   .text.task_64ms:00000024 $d
     /tmp/ccdVMVfm.s:2477   .text.task_128ms:00000000 $a
     /tmp/ccdVMVfm.s:2482   .text.task_128ms:00000000 task_128ms
     /tmp/ccdVMVfm.s:2508   .text.task_256ms:00000000 $a
     /tmp/ccdVMVfm.s:2513   .text.task_256ms:00000000 task_256ms
     /tmp/ccdVMVfm.s:2539   .text.task_512ms:00000000 $a
     /tmp/ccdVMVfm.s:2544   .text.task_512ms:00000000 task_512ms
     /tmp/ccdVMVfm.s:2570   .text.task_1024ms:00000000 $a
     /tmp/ccdVMVfm.s:2575   .text.task_1024ms:00000000 task_1024ms
     /tmp/ccdVMVfm.s:2601   .text.task_idle:00000000 $a
     /tmp/ccdVMVfm.s:2606   .text.task_idle:00000000 task_idle
     /tmp/ccdVMVfm.s:2632   .text.premain_init:00000000 $a
     /tmp/ccdVMVfm.s:2637   .text.premain_init:00000000 premain_init
     /tmp/ccdVMVfm.s:2679   .text.premain_init:0000003c $d
     /tmp/ccdVMVfm.s:3418   .bss:0000032c linebuf.1
     /tmp/ccdVMVfm.s:2686   .init_array:00000000 $d
     /tmp/ccdVMVfm.s:2755   .text.main:00000000 $a
     /tmp/ccdVMVfm.s:2760   .text.main:00000000 main
     /tmp/ccdVMVfm.s:3354   .text.main:000005f8 $d
     /tmp/ccdVMVfm.s:3421   .bss:00000336 stack_cnt.0

UNDEFINED SYMBOLS
nxt_avr_get_buttons
display_goto_xy
display_unsigned
display_string
display_update
_impure_ptr
setvbuf
aic_init
systick_init
interrupts_enable
nxt_avr_init
udmon3_init
term_init
display_init
display_clear
term_string
__stack_start__
systick_get_ms
nxt_avr_get_battery_raw
