   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "main.c"
  18              		.section	.text.byte_fifo_put_possible,"ax",%progbits
  19              		.align	2
  20              		.syntax unified
  21              		.arm
  23              	byte_fifo_put_possible:
  24              	.LFB5:
  25              		.file 2 "trace32/../lib/byte_fifo.h"
   1:trace32/../lib/byte_fifo.h **** /* Byte FIFO queue implementation.
   2:trace32/../lib/byte_fifo.h ****  *
   3:trace32/../lib/byte_fifo.h ****  * Implements a simple reader/write save byte FIFO on top of a data buffer, that lets
   4:trace32/../lib/byte_fifo.h ****  * you enqueue and dequeue single bytes.
   5:trace32/../lib/byte_fifo.h ****  */
   6:trace32/../lib/byte_fifo.h **** 
   7:trace32/../lib/byte_fifo.h **** #ifndef __BYTE_FIFO_H__
   8:trace32/../lib/byte_fifo.h **** #define __BYTE_FIFO_H__
   9:trace32/../lib/byte_fifo.h **** 
  10:trace32/../lib/byte_fifo.h **** 
  11:trace32/../lib/byte_fifo.h **** typedef struct
  12:trace32/../lib/byte_fifo.h **** {
  13:trace32/../lib/byte_fifo.h **** 	unsigned short rd;
  14:trace32/../lib/byte_fifo.h **** 	unsigned short wr;
  15:trace32/../lib/byte_fifo.h ****     unsigned short mask;
  16:trace32/../lib/byte_fifo.h **** 	unsigned char  buf[];
  17:trace32/../lib/byte_fifo.h **** } byte_fifo_t;
  18:trace32/../lib/byte_fifo.h **** 
  19:trace32/../lib/byte_fifo.h **** #define TEST_2erPOTENZ(x) (((x) & ((x) - 1))?0:(x))
  20:trace32/../lib/byte_fifo.h **** #define TEST_64k(x)       ((x)>0x10000?0:(x))
  21:trace32/../lib/byte_fifo.h **** #define TEST_SIZE(x)      (TEST_64k(TEST_2erPOTENZ(x)))
  22:trace32/../lib/byte_fifo.h **** 
  23:trace32/../lib/byte_fifo.h **** //size muss einer 2er Potenzzahl sein, andernfalls gibt der Compiler
  24:trace32/../lib/byte_fifo.h **** //die Fehlermeldung aus, dass die Array-Größe (hier -1) ungültit ist
  25:trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_INIT(size)  (byte_fifo_t) {.rd=0,\
  26:trace32/../lib/byte_fifo.h ****                                              .wr=0,\
  27:trace32/../lib/byte_fifo.h **** 						        	         .mask=TEST_SIZE(size)-1,\
  28:trace32/../lib/byte_fifo.h **** 								    		 .buf={[TEST_SIZE(size)-1]=0}\
  29:trace32/../lib/byte_fifo.h **** 									    	}
  30:trace32/../lib/byte_fifo.h **** 
  31:trace32/../lib/byte_fifo.h **** #define BYTE_FIFO_TYPEOF_RDWR typeof (((byte_fifo_t *)0)->rd)
  32:trace32/../lib/byte_fifo.h **** 
  33:trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic push
  34:trace32/../lib/byte_fifo.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  35:trace32/../lib/byte_fifo.h **** 
  36:trace32/../lib/byte_fifo.h **** static int byte_fifo_put_possible(byte_fifo_t *fifo)
  37:trace32/../lib/byte_fifo.h **** {
  26              		.loc 2 37 1
  27              		.cfi_startproc
  28              		@ Function supports interworking.
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 04B02DE5 		str	fp, [sp, #-4]!
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 11, -4
  35 0004 00B08DE2 		add	fp, sp, #0
  36              		.cfi_def_cfa_register 11
  37 0008 0CD04DE2 		sub	sp, sp, #12
  38 000c 08000BE5 		str	r0, [fp, #-8]
  38:trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
  39              		.loc 2 38 11
  40 0010 08301BE5 		ldr	r3, [fp, #-8]
  41 0014 B230D3E1 		ldrh	r3, [r3, #2]
  42              		.loc 2 38 15
  43 0018 013083E2 		add	r3, r3, #1
  44              		.loc 2 38 24
  45 001c 08201BE5 		ldr	r2, [fp, #-8]
  46 0020 B420D2E1 		ldrh	r2, [r2, #4]
  47              		.loc 2 38 18
  48 0024 023003E0 		and	r3, r3, r2
  49              		.loc 2 38 40
  50 0028 08201BE5 		ldr	r2, [fp, #-8]
  51 002c B020D2E1 		ldrh	r2, [r2]
  52              		.loc 2 38 4
  53 0030 020053E1 		cmp	r3, r2
  54 0034 0100001A 		bne	.L2
  39:trace32/../lib/byte_fifo.h **** 		return -1;
  55              		.loc 2 39 10
  56 0038 0030E0E3 		mvn	r3, #0
  57 003c 000000EA 		b	.L3
  58              	.L2:
  40:trace32/../lib/byte_fifo.h **** 	
  41:trace32/../lib/byte_fifo.h **** 	return 0;
  59              		.loc 2 41 9
  60 0040 0030A0E3 		mov	r3, #0
  61              	.L3:
  42:trace32/../lib/byte_fifo.h **** }
  62              		.loc 2 42 1
  63 0044 0300A0E1 		mov	r0, r3
  64 0048 00D08BE2 		add	sp, fp, #0
  65              		.cfi_def_cfa_register 13
  66              		@ sp needed
  67 004c 04B09DE4 		ldr	fp, [sp], #4
  68              		.cfi_restore 11
  69              		.cfi_def_cfa_offset 0
  70 0050 1EFF2FE1 		bx	lr
  71              		.cfi_endproc
  72              	.LFE5:
  74              		.section	.text.byte_fifo_remain,"ax",%progbits
  75              		.align	2
  76              		.syntax unified
  77              		.arm
  79              	byte_fifo_remain:
  80              	.LFB6:
  43:trace32/../lib/byte_fifo.h **** 
  44:trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_remain(byte_fifo_t *fifo)
  45:trace32/../lib/byte_fifo.h **** {
  81              		.loc 2 45 1
  82              		.cfi_startproc
  83              		@ Function supports interworking.
  84              		@ args = 0, pretend = 0, frame = 8
  85              		@ frame_needed = 1, uses_anonymous_args = 0
  86              		@ link register save eliminated.
  87 0000 04B02DE5 		str	fp, [sp, #-4]!
  88              		.cfi_def_cfa_offset 4
  89              		.cfi_offset 11, -4
  90 0004 00B08DE2 		add	fp, sp, #0
  91              		.cfi_def_cfa_register 11
  92 0008 0CD04DE2 		sub	sp, sp, #12
  93 000c 08000BE5 		str	r0, [fp, #-8]
  46:trace32/../lib/byte_fifo.h **** 	return fifo->mask - ((fifo->wr-fifo->rd)&fifo->mask);
  94              		.loc 2 46 37
  95 0010 08301BE5 		ldr	r3, [fp, #-8]
  96 0014 B020D3E1 		ldrh	r2, [r3]
  97              		.loc 2 46 28
  98 0018 08301BE5 		ldr	r3, [fp, #-8]
  99 001c B230D3E1 		ldrh	r3, [r3, #2]
 100              		.loc 2 46 20
 101 0020 033042E0 		sub	r3, r2, r3
 102 0024 0338A0E1 		lsl	r3, r3, #16
 103 0028 2338A0E1 		lsr	r3, r3, #16
 104 002c 013043E2 		sub	r3, r3, #1
 105 0030 0338A0E1 		lsl	r3, r3, #16
 106 0034 2338A0E1 		lsr	r3, r3, #16
 107 0038 0338A0E1 		lsl	r3, r3, #16
 108 003c 4328A0E1 		asr	r2, r3, #16
 109              		.loc 2 46 47
 110 0040 08301BE5 		ldr	r3, [fp, #-8]
 111 0044 B430D3E1 		ldrh	r3, [r3, #4]
 112 0048 0338A0E1 		lsl	r3, r3, #16
 113 004c 4338A0E1 		asr	r3, r3, #16
 114              		.loc 2 46 20
 115 0050 023003E0 		and	r3, r3, r2
 116 0054 0338A0E1 		lsl	r3, r3, #16
 117 0058 4338A0E1 		asr	r3, r3, #16
 118 005c 0338A0E1 		lsl	r3, r3, #16
 119 0060 2338A0E1 		lsr	r3, r3, #16
  47:trace32/../lib/byte_fifo.h **** }
 120              		.loc 2 47 1
 121 0064 0300A0E1 		mov	r0, r3
 122 0068 00D08BE2 		add	sp, fp, #0
 123              		.cfi_def_cfa_register 13
 124              		@ sp needed
 125 006c 04B09DE4 		ldr	fp, [sp], #4
 126              		.cfi_restore 11
 127              		.cfi_def_cfa_offset 0
 128 0070 1EFF2FE1 		bx	lr
 129              		.cfi_endproc
 130              	.LFE6:
 132              		.section	.text.byte_fifo_used,"ax",%progbits
 133              		.align	2
 134              		.syntax unified
 135              		.arm
 137              	byte_fifo_used:
 138              	.LFB7:
  48:trace32/../lib/byte_fifo.h **** 	
  49:trace32/../lib/byte_fifo.h **** static BYTE_FIFO_TYPEOF_RDWR byte_fifo_used(byte_fifo_t *fifo)
  50:trace32/../lib/byte_fifo.h **** {
 139              		.loc 2 50 1
 140              		.cfi_startproc
 141              		@ Function supports interworking.
 142              		@ args = 0, pretend = 0, frame = 8
 143              		@ frame_needed = 1, uses_anonymous_args = 0
 144              		@ link register save eliminated.
 145 0000 04B02DE5 		str	fp, [sp, #-4]!
 146              		.cfi_def_cfa_offset 4
 147              		.cfi_offset 11, -4
 148 0004 00B08DE2 		add	fp, sp, #0
 149              		.cfi_def_cfa_register 11
 150 0008 0CD04DE2 		sub	sp, sp, #12
 151 000c 08000BE5 		str	r0, [fp, #-8]
  51:trace32/../lib/byte_fifo.h **** 	return (fifo->wr-fifo->rd)&fifo->mask;
 152              		.loc 2 51 14
 153 0010 08301BE5 		ldr	r3, [fp, #-8]
 154 0014 B220D3E1 		ldrh	r2, [r3, #2]
 155              		.loc 2 51 23
 156 0018 08301BE5 		ldr	r3, [fp, #-8]
 157 001c B030D3E1 		ldrh	r3, [r3]
 158              		.loc 2 51 18
 159 0020 033042E0 		sub	r3, r2, r3
 160 0024 0338A0E1 		lsl	r3, r3, #16
 161 0028 2338A0E1 		lsr	r3, r3, #16
 162 002c 0338A0E1 		lsl	r3, r3, #16
 163 0030 4328A0E1 		asr	r2, r3, #16
 164              		.loc 2 51 33
 165 0034 08301BE5 		ldr	r3, [fp, #-8]
 166 0038 B430D3E1 		ldrh	r3, [r3, #4]
 167 003c 0338A0E1 		lsl	r3, r3, #16
 168 0040 4338A0E1 		asr	r3, r3, #16
 169              		.loc 2 51 28
 170 0044 023003E0 		and	r3, r3, r2
 171 0048 0338A0E1 		lsl	r3, r3, #16
 172 004c 4338A0E1 		asr	r3, r3, #16
 173 0050 0338A0E1 		lsl	r3, r3, #16
 174 0054 2338A0E1 		lsr	r3, r3, #16
  52:trace32/../lib/byte_fifo.h **** }
 175              		.loc 2 52 1
 176 0058 0300A0E1 		mov	r0, r3
 177 005c 00D08BE2 		add	sp, fp, #0
 178              		.cfi_def_cfa_register 13
 179              		@ sp needed
 180 0060 04B09DE4 		ldr	fp, [sp], #4
 181              		.cfi_restore 11
 182              		.cfi_def_cfa_offset 0
 183 0064 1EFF2FE1 		bx	lr
 184              		.cfi_endproc
 185              	.LFE7:
 187              		.section	.text.byte_fifo_put,"ax",%progbits
 188              		.align	2
 189              		.syntax unified
 190              		.arm
 192              	byte_fifo_put:
 193              	.LFB8:
  53:trace32/../lib/byte_fifo.h **** 	
  54:trace32/../lib/byte_fifo.h **** static int byte_fifo_put(byte_fifo_t *fifo,unsigned char val)
  55:trace32/../lib/byte_fifo.h **** {
 194              		.loc 2 55 1
 195              		.cfi_startproc
 196              		@ Function supports interworking.
 197              		@ args = 0, pretend = 0, frame = 8
 198              		@ frame_needed = 1, uses_anonymous_args = 0
 199              		@ link register save eliminated.
 200 0000 04B02DE5 		str	fp, [sp, #-4]!
 201              		.cfi_def_cfa_offset 4
 202              		.cfi_offset 11, -4
 203 0004 00B08DE2 		add	fp, sp, #0
 204              		.cfi_def_cfa_register 11
 205 0008 0CD04DE2 		sub	sp, sp, #12
 206 000c 08000BE5 		str	r0, [fp, #-8]
 207 0010 0130A0E1 		mov	r3, r1
 208 0014 09304BE5 		strb	r3, [fp, #-9]
  56:trace32/../lib/byte_fifo.h **** 	if(((fifo->wr+1)&(fifo->mask)) == fifo->rd)
 209              		.loc 2 56 11
 210 0018 08301BE5 		ldr	r3, [fp, #-8]
 211 001c B230D3E1 		ldrh	r3, [r3, #2]
 212              		.loc 2 56 15
 213 0020 013083E2 		add	r3, r3, #1
 214              		.loc 2 56 24
 215 0024 08201BE5 		ldr	r2, [fp, #-8]
 216 0028 B420D2E1 		ldrh	r2, [r2, #4]
 217              		.loc 2 56 18
 218 002c 023003E0 		and	r3, r3, r2
 219              		.loc 2 56 40
 220 0030 08201BE5 		ldr	r2, [fp, #-8]
 221 0034 B020D2E1 		ldrh	r2, [r2]
 222              		.loc 2 56 4
 223 0038 020053E1 		cmp	r3, r2
 224 003c 0100001A 		bne	.L9
  57:trace32/../lib/byte_fifo.h **** 		return -1;
 225              		.loc 2 57 10
 226 0040 0030E0E3 		mvn	r3, #0
 227 0044 190000EA 		b	.L10
 228              	.L9:
  58:trace32/../lib/byte_fifo.h **** 	
  59:trace32/../lib/byte_fifo.h **** 	fifo->buf[fifo->wr]=val;
 229              		.loc 2 59 16
 230 0048 08301BE5 		ldr	r3, [fp, #-8]
 231 004c B230D3E1 		ldrh	r3, [r3, #2]
 232 0050 0320A0E1 		mov	r2, r3
 233              		.loc 2 59 21
 234 0054 08301BE5 		ldr	r3, [fp, #-8]
 235 0058 023083E0 		add	r3, r3, r2
 236 005c 09205BE5 		ldrb	r2, [fp, #-9]
 237 0060 0620C3E5 		strb	r2, [r3, #6]
  60:trace32/../lib/byte_fifo.h **** 	fifo->wr=(fifo->wr+1)&(fifo->mask);
 238              		.loc 2 60 16
 239 0064 08301BE5 		ldr	r3, [fp, #-8]
 240 0068 B230D3E1 		ldrh	r3, [r3, #2]
 241              		.loc 2 60 20
 242 006c 013083E2 		add	r3, r3, #1
 243 0070 0338A0E1 		lsl	r3, r3, #16
 244 0074 2338A0E1 		lsr	r3, r3, #16
 245 0078 0338A0E1 		lsl	r3, r3, #16
 246 007c 4328A0E1 		asr	r2, r3, #16
 247              		.loc 2 60 29
 248 0080 08301BE5 		ldr	r3, [fp, #-8]
 249 0084 B430D3E1 		ldrh	r3, [r3, #4]
 250 0088 0338A0E1 		lsl	r3, r3, #16
 251 008c 4338A0E1 		asr	r3, r3, #16
 252              		.loc 2 60 23
 253 0090 023003E0 		and	r3, r3, r2
 254 0094 0338A0E1 		lsl	r3, r3, #16
 255 0098 4338A0E1 		asr	r3, r3, #16
 256 009c 0338A0E1 		lsl	r3, r3, #16
 257 00a0 2328A0E1 		lsr	r2, r3, #16
 258              		.loc 2 60 10
 259 00a4 08301BE5 		ldr	r3, [fp, #-8]
 260 00a8 B220C3E1 		strh	r2, [r3, #2]	@ movhi
  61:trace32/../lib/byte_fifo.h **** 	return 0;
 261              		.loc 2 61 9
 262 00ac 0030A0E3 		mov	r3, #0
 263              	.L10:
  62:trace32/../lib/byte_fifo.h **** }
 264              		.loc 2 62 1
 265 00b0 0300A0E1 		mov	r0, r3
 266 00b4 00D08BE2 		add	sp, fp, #0
 267              		.cfi_def_cfa_register 13
 268              		@ sp needed
 269 00b8 04B09DE4 		ldr	fp, [sp], #4
 270              		.cfi_restore 11
 271              		.cfi_def_cfa_offset 0
 272 00bc 1EFF2FE1 		bx	lr
 273              		.cfi_endproc
 274              	.LFE8:
 276              		.section	.text.byte_fifo_get_possible,"ax",%progbits
 277              		.align	2
 278              		.syntax unified
 279              		.arm
 281              	byte_fifo_get_possible:
 282              	.LFB9:
  63:trace32/../lib/byte_fifo.h **** 
  64:trace32/../lib/byte_fifo.h **** static int byte_fifo_get_possible(byte_fifo_t *fifo)
  65:trace32/../lib/byte_fifo.h **** {
 283              		.loc 2 65 1
 284              		.cfi_startproc
 285              		@ Function supports interworking.
 286              		@ args = 0, pretend = 0, frame = 8
 287              		@ frame_needed = 1, uses_anonymous_args = 0
 288              		@ link register save eliminated.
 289 0000 04B02DE5 		str	fp, [sp, #-4]!
 290              		.cfi_def_cfa_offset 4
 291              		.cfi_offset 11, -4
 292 0004 00B08DE2 		add	fp, sp, #0
 293              		.cfi_def_cfa_register 11
 294 0008 0CD04DE2 		sub	sp, sp, #12
 295 000c 08000BE5 		str	r0, [fp, #-8]
  66:trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 296              		.loc 2 66 9
 297 0010 08301BE5 		ldr	r3, [fp, #-8]
 298 0014 B020D3E1 		ldrh	r2, [r3]
 299              		.loc 2 66 21
 300 0018 08301BE5 		ldr	r3, [fp, #-8]
 301 001c B230D3E1 		ldrh	r3, [r3, #2]
 302              		.loc 2 66 4
 303 0020 030052E1 		cmp	r2, r3
 304 0024 0100001A 		bne	.L12
  67:trace32/../lib/byte_fifo.h **** 		return -1;
 305              		.loc 2 67 10
 306 0028 0030E0E3 		mvn	r3, #0
 307 002c 000000EA 		b	.L13
 308              	.L12:
  68:trace32/../lib/byte_fifo.h **** 		
  69:trace32/../lib/byte_fifo.h **** 	return 0;
 309              		.loc 2 69 9
 310 0030 0030A0E3 		mov	r3, #0
 311              	.L13:
  70:trace32/../lib/byte_fifo.h **** }
 312              		.loc 2 70 1
 313 0034 0300A0E1 		mov	r0, r3
 314 0038 00D08BE2 		add	sp, fp, #0
 315              		.cfi_def_cfa_register 13
 316              		@ sp needed
 317 003c 04B09DE4 		ldr	fp, [sp], #4
 318              		.cfi_restore 11
 319              		.cfi_def_cfa_offset 0
 320 0040 1EFF2FE1 		bx	lr
 321              		.cfi_endproc
 322              	.LFE9:
 324              		.section	.text.byte_fifo_get,"ax",%progbits
 325              		.align	2
 326              		.syntax unified
 327              		.arm
 329              	byte_fifo_get:
 330              	.LFB10:
  71:trace32/../lib/byte_fifo.h **** 
  72:trace32/../lib/byte_fifo.h **** static int byte_fifo_get(byte_fifo_t *fifo,unsigned char *val)
  73:trace32/../lib/byte_fifo.h **** {
 331              		.loc 2 73 1
 332              		.cfi_startproc
 333              		@ Function supports interworking.
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 1, uses_anonymous_args = 0
 336              		@ link register save eliminated.
 337 0000 04B02DE5 		str	fp, [sp, #-4]!
 338              		.cfi_def_cfa_offset 4
 339              		.cfi_offset 11, -4
 340 0004 00B08DE2 		add	fp, sp, #0
 341              		.cfi_def_cfa_register 11
 342 0008 0CD04DE2 		sub	sp, sp, #12
 343 000c 08000BE5 		str	r0, [fp, #-8]
 344 0010 0C100BE5 		str	r1, [fp, #-12]
  74:trace32/../lib/byte_fifo.h **** 	if(fifo->rd == fifo->wr)
 345              		.loc 2 74 9
 346 0014 08301BE5 		ldr	r3, [fp, #-8]
 347 0018 B020D3E1 		ldrh	r2, [r3]
 348              		.loc 2 74 21
 349 001c 08301BE5 		ldr	r3, [fp, #-8]
 350 0020 B230D3E1 		ldrh	r3, [r3, #2]
 351              		.loc 2 74 4
 352 0024 030052E1 		cmp	r2, r3
 353 0028 0100001A 		bne	.L15
  75:trace32/../lib/byte_fifo.h **** 		return -1;
 354              		.loc 2 75 10
 355 002c 0030E0E3 		mvn	r3, #0
 356 0030 1A0000EA 		b	.L16
 357              	.L15:
  76:trace32/../lib/byte_fifo.h **** 		
  77:trace32/../lib/byte_fifo.h **** 	*val=fifo->buf[fifo->rd];
 358              		.loc 2 77 21
 359 0034 08301BE5 		ldr	r3, [fp, #-8]
 360 0038 B030D3E1 		ldrh	r3, [r3]
 361 003c 0320A0E1 		mov	r2, r3
 362              		.loc 2 77 16
 363 0040 08301BE5 		ldr	r3, [fp, #-8]
 364 0044 023083E0 		add	r3, r3, r2
 365 0048 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 366              		.loc 2 77 6
 367 004c 0C301BE5 		ldr	r3, [fp, #-12]
 368 0050 0020C3E5 		strb	r2, [r3]
  78:trace32/../lib/byte_fifo.h **** 	fifo->rd=(fifo->rd+1)&(fifo->mask);
 369              		.loc 2 78 16
 370 0054 08301BE5 		ldr	r3, [fp, #-8]
 371 0058 B030D3E1 		ldrh	r3, [r3]
 372              		.loc 2 78 20
 373 005c 013083E2 		add	r3, r3, #1
 374 0060 0338A0E1 		lsl	r3, r3, #16
 375 0064 2338A0E1 		lsr	r3, r3, #16
 376 0068 0338A0E1 		lsl	r3, r3, #16
 377 006c 4328A0E1 		asr	r2, r3, #16
 378              		.loc 2 78 29
 379 0070 08301BE5 		ldr	r3, [fp, #-8]
 380 0074 B430D3E1 		ldrh	r3, [r3, #4]
 381 0078 0338A0E1 		lsl	r3, r3, #16
 382 007c 4338A0E1 		asr	r3, r3, #16
 383              		.loc 2 78 23
 384 0080 023003E0 		and	r3, r3, r2
 385 0084 0338A0E1 		lsl	r3, r3, #16
 386 0088 4338A0E1 		asr	r3, r3, #16
 387 008c 0338A0E1 		lsl	r3, r3, #16
 388 0090 2328A0E1 		lsr	r2, r3, #16
 389              		.loc 2 78 10
 390 0094 08301BE5 		ldr	r3, [fp, #-8]
 391 0098 B020C3E1 		strh	r2, [r3]	@ movhi
  79:trace32/../lib/byte_fifo.h **** 	return 0;
 392              		.loc 2 79 9
 393 009c 0030A0E3 		mov	r3, #0
 394              	.L16:
  80:trace32/../lib/byte_fifo.h **** }
 395              		.loc 2 80 1
 396 00a0 0300A0E1 		mov	r0, r3
 397 00a4 00D08BE2 		add	sp, fp, #0
 398              		.cfi_def_cfa_register 13
 399              		@ sp needed
 400 00a8 04B09DE4 		ldr	fp, [sp], #4
 401              		.cfi_restore 11
 402              		.cfi_def_cfa_offset 0
 403 00ac 1EFF2FE1 		bx	lr
 404              		.cfi_endproc
 405              	.LFE10:
 407              		.section	.text.byte_fifo_cb_put_possible,"ax",%progbits
 408              		.align	2
 409              		.syntax unified
 410              		.arm
 412              	byte_fifo_cb_put_possible:
 413              	.LFB11:
 414              		.file 3 "trace32/../lib/byte_fifo_cb.h"
   1:trace32/../lib/byte_fifo_cb.h **** /* Byte FIFO with CallBack
   2:trace32/../lib/byte_fifo_cb.h ****  *
   3:trace32/../lib/byte_fifo_cb.h ****  * Appends the Byte_Fifo with a callback function, which is called
   4:trace32/../lib/byte_fifo_cb.h ****  * when putting some stuff into the fifo (e.g. Enable transmitting interrupt)
   5:trace32/../lib/byte_fifo_cb.h ****  */
   6:trace32/../lib/byte_fifo_cb.h **** 
   7:trace32/../lib/byte_fifo_cb.h **** #ifndef __BYTE_FIFO_CB_H__
   8:trace32/../lib/byte_fifo_cb.h **** #define __BYTE_FIFO_CB_H__
   9:trace32/../lib/byte_fifo_cb.h **** 
  10:trace32/../lib/byte_fifo_cb.h **** #include "byte_fifo.h"
  11:trace32/../lib/byte_fifo_cb.h **** 
  12:trace32/../lib/byte_fifo_cb.h **** typedef void (*byte_fifo_cb)(void);
  13:trace32/../lib/byte_fifo_cb.h **** 
  14:trace32/../lib/byte_fifo_cb.h **** typedef struct {
  15:trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_cb cb;
  16:trace32/../lib/byte_fifo_cb.h **** 	byte_fifo_t  byte_fifo; //Aufgrund des Flexible Array Member hier hinter keine weiteren Strukturel
  17:trace32/../lib/byte_fifo_cb.h **** } byte_fifo_cb_t;
  18:trace32/../lib/byte_fifo_cb.h **** 
  19:trace32/../lib/byte_fifo_cb.h **** #define BYTE_FIFO_CB_INIT(size,func)  (byte_fifo_cb_t) {.cb=func, \
  20:trace32/../lib/byte_fifo_cb.h ****                                                         .byte_fifo=BYTE_FIFO_INIT(size) \
  21:trace32/../lib/byte_fifo_cb.h **** 									    			   }
  22:trace32/../lib/byte_fifo_cb.h **** 
  23:trace32/../lib/byte_fifo_cb.h **** size_t byte_fifo_cb_putsize(byte_fifo_cb_t *fifo,const unsigned char *start,size_t len);
  24:trace32/../lib/byte_fifo_cb.h **** 
  25:trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic push
  26:trace32/../lib/byte_fifo_cb.h **** #pragma GCC diagnostic ignored "-Wunused-function"
  27:trace32/../lib/byte_fifo_cb.h **** 
  28:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put_possible(byte_fifo_cb_t *fifo)
  29:trace32/../lib/byte_fifo_cb.h **** {
 415              		.loc 3 29 1
 416              		.cfi_startproc
 417              		@ Function supports interworking.
 418              		@ args = 0, pretend = 0, frame = 8
 419              		@ frame_needed = 1, uses_anonymous_args = 0
 420 0000 00482DE9 		push	{fp, lr}
 421              		.cfi_def_cfa_offset 8
 422              		.cfi_offset 11, -8
 423              		.cfi_offset 14, -4
 424 0004 04B08DE2 		add	fp, sp, #4
 425              		.cfi_def_cfa 11, 4
 426 0008 08D04DE2 		sub	sp, sp, #8
 427 000c 08000BE5 		str	r0, [fp, #-8]
  30:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_put_possible(&fifo->byte_fifo);
 428              		.loc 3 30 9
 429 0010 08301BE5 		ldr	r3, [fp, #-8]
 430 0014 043083E2 		add	r3, r3, #4
 431 0018 0300A0E1 		mov	r0, r3
 432 001c 18309FE5 		ldr	r3, .L19
 433 0020 0FE0A0E1 		mov	lr, pc
 434 0024 13FF2FE1 		bx	r3
 435              	.LVL0:
 436 0028 0030A0E1 		mov	r3, r0
  31:trace32/../lib/byte_fifo_cb.h **** }
 437              		.loc 3 31 1
 438 002c 0300A0E1 		mov	r0, r3
 439 0030 04D04BE2 		sub	sp, fp, #4
 440              		.cfi_def_cfa 13, 8
 441              		@ sp needed
 442 0034 0048BDE8 		pop	{fp, lr}
 443              		.cfi_restore 14
 444              		.cfi_restore 11
 445              		.cfi_def_cfa_offset 0
 446 0038 1EFF2FE1 		bx	lr
 447              	.L20:
 448              		.align	2
 449              	.L19:
 450 003c 00000000 		.word	byte_fifo_put_possible
 451              		.cfi_endproc
 452              	.LFE11:
 454              		.section	.text.byte_fifo_cb_put,"ax",%progbits
 455              		.align	2
 456              		.syntax unified
 457              		.arm
 459              	byte_fifo_cb_put:
 460              	.LFB12:
  32:trace32/../lib/byte_fifo_cb.h **** 	
  33:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_put(byte_fifo_cb_t *fifo,unsigned char val)
  34:trace32/../lib/byte_fifo_cb.h **** {
 461              		.loc 3 34 1
 462              		.cfi_startproc
 463              		@ Function supports interworking.
 464              		@ args = 0, pretend = 0, frame = 16
 465              		@ frame_needed = 1, uses_anonymous_args = 0
 466 0000 00482DE9 		push	{fp, lr}
 467              		.cfi_def_cfa_offset 8
 468              		.cfi_offset 11, -8
 469              		.cfi_offset 14, -4
 470 0004 04B08DE2 		add	fp, sp, #4
 471              		.cfi_def_cfa 11, 4
 472 0008 10D04DE2 		sub	sp, sp, #16
 473 000c 10000BE5 		str	r0, [fp, #-16]
 474 0010 0130A0E1 		mov	r3, r1
 475 0014 11304BE5 		strb	r3, [fp, #-17]
  35:trace32/../lib/byte_fifo_cb.h **** 	int ret=byte_fifo_put(&fifo->byte_fifo,val);
 476              		.loc 3 35 10
 477 0018 10301BE5 		ldr	r3, [fp, #-16]
 478 001c 043083E2 		add	r3, r3, #4
 479 0020 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 480 0024 0210A0E1 		mov	r1, r2
 481 0028 0300A0E1 		mov	r0, r3
 482 002c 48309FE5 		ldr	r3, .L24
 483 0030 0FE0A0E1 		mov	lr, pc
 484 0034 13FF2FE1 		bx	r3
 485              	.LVL1:
 486 0038 08000BE5 		str	r0, [fp, #-8]
  36:trace32/../lib/byte_fifo_cb.h **** 	if( !ret && fifo->cb)
 487              		.loc 3 36 4
 488 003c 08301BE5 		ldr	r3, [fp, #-8]
 489 0040 000053E3 		cmp	r3, #0
 490 0044 0700001A 		bne	.L22
 491              		.loc 3 36 18 discriminator 1
 492 0048 10301BE5 		ldr	r3, [fp, #-16]
 493 004c 003093E5 		ldr	r3, [r3]
 494              		.loc 3 36 11 discriminator 1
 495 0050 000053E3 		cmp	r3, #0
 496 0054 0300000A 		beq	.L22
  37:trace32/../lib/byte_fifo_cb.h **** 		fifo->cb();
 497              		.loc 3 37 7
 498 0058 10301BE5 		ldr	r3, [fp, #-16]
 499 005c 003093E5 		ldr	r3, [r3]
 500              		.loc 3 37 3
 501 0060 0FE0A0E1 		mov	lr, pc
 502 0064 13FF2FE1 		bx	r3
 503              	.LVL2:
 504              	.L22:
  38:trace32/../lib/byte_fifo_cb.h **** 	return ret;
 505              		.loc 3 38 9
 506 0068 08301BE5 		ldr	r3, [fp, #-8]
  39:trace32/../lib/byte_fifo_cb.h **** }
 507              		.loc 3 39 1
 508 006c 0300A0E1 		mov	r0, r3
 509 0070 04D04BE2 		sub	sp, fp, #4
 510              		.cfi_def_cfa 13, 8
 511              		@ sp needed
 512 0074 0048BDE8 		pop	{fp, lr}
 513              		.cfi_restore 14
 514              		.cfi_restore 11
 515              		.cfi_def_cfa_offset 0
 516 0078 1EFF2FE1 		bx	lr
 517              	.L25:
 518              		.align	2
 519              	.L24:
 520 007c 00000000 		.word	byte_fifo_put
 521              		.cfi_endproc
 522              	.LFE12:
 524              		.section	.text.byte_fifo_cb_get_possible,"ax",%progbits
 525              		.align	2
 526              		.syntax unified
 527              		.arm
 529              	byte_fifo_cb_get_possible:
 530              	.LFB13:
  40:trace32/../lib/byte_fifo_cb.h **** 
  41:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get_possible(byte_fifo_cb_t *fifo)
  42:trace32/../lib/byte_fifo_cb.h **** {
 531              		.loc 3 42 1
 532              		.cfi_startproc
 533              		@ Function supports interworking.
 534              		@ args = 0, pretend = 0, frame = 8
 535              		@ frame_needed = 1, uses_anonymous_args = 0
 536 0000 00482DE9 		push	{fp, lr}
 537              		.cfi_def_cfa_offset 8
 538              		.cfi_offset 11, -8
 539              		.cfi_offset 14, -4
 540 0004 04B08DE2 		add	fp, sp, #4
 541              		.cfi_def_cfa 11, 4
 542 0008 08D04DE2 		sub	sp, sp, #8
 543 000c 08000BE5 		str	r0, [fp, #-8]
  43:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get_possible(&fifo->byte_fifo);
 544              		.loc 3 43 9
 545 0010 08301BE5 		ldr	r3, [fp, #-8]
 546 0014 043083E2 		add	r3, r3, #4
 547 0018 0300A0E1 		mov	r0, r3
 548 001c 18309FE5 		ldr	r3, .L28
 549 0020 0FE0A0E1 		mov	lr, pc
 550 0024 13FF2FE1 		bx	r3
 551              	.LVL3:
 552 0028 0030A0E1 		mov	r3, r0
  44:trace32/../lib/byte_fifo_cb.h **** }
 553              		.loc 3 44 1
 554 002c 0300A0E1 		mov	r0, r3
 555 0030 04D04BE2 		sub	sp, fp, #4
 556              		.cfi_def_cfa 13, 8
 557              		@ sp needed
 558 0034 0048BDE8 		pop	{fp, lr}
 559              		.cfi_restore 14
 560              		.cfi_restore 11
 561              		.cfi_def_cfa_offset 0
 562 0038 1EFF2FE1 		bx	lr
 563              	.L29:
 564              		.align	2
 565              	.L28:
 566 003c 00000000 		.word	byte_fifo_get_possible
 567              		.cfi_endproc
 568              	.LFE13:
 570              		.section	.text.byte_fifo_cb_get,"ax",%progbits
 571              		.align	2
 572              		.syntax unified
 573              		.arm
 575              	byte_fifo_cb_get:
 576              	.LFB14:
  45:trace32/../lib/byte_fifo_cb.h **** 
  46:trace32/../lib/byte_fifo_cb.h **** static int byte_fifo_cb_get(byte_fifo_cb_t *fifo,unsigned char *val)
  47:trace32/../lib/byte_fifo_cb.h **** {
 577              		.loc 3 47 1
 578              		.cfi_startproc
 579              		@ Function supports interworking.
 580              		@ args = 0, pretend = 0, frame = 8
 581              		@ frame_needed = 1, uses_anonymous_args = 0
 582 0000 00482DE9 		push	{fp, lr}
 583              		.cfi_def_cfa_offset 8
 584              		.cfi_offset 11, -8
 585              		.cfi_offset 14, -4
 586 0004 04B08DE2 		add	fp, sp, #4
 587              		.cfi_def_cfa 11, 4
 588 0008 08D04DE2 		sub	sp, sp, #8
 589 000c 08000BE5 		str	r0, [fp, #-8]
 590 0010 0C100BE5 		str	r1, [fp, #-12]
  48:trace32/../lib/byte_fifo_cb.h **** 	return byte_fifo_get(&fifo->byte_fifo,val);
 591              		.loc 3 48 9
 592 0014 08301BE5 		ldr	r3, [fp, #-8]
 593 0018 043083E2 		add	r3, r3, #4
 594 001c 0C101BE5 		ldr	r1, [fp, #-12]
 595 0020 0300A0E1 		mov	r0, r3
 596 0024 18309FE5 		ldr	r3, .L32
 597 0028 0FE0A0E1 		mov	lr, pc
 598 002c 13FF2FE1 		bx	r3
 599              	.LVL4:
 600 0030 0030A0E1 		mov	r3, r0
  49:trace32/../lib/byte_fifo_cb.h **** }
 601              		.loc 3 49 1
 602 0034 0300A0E1 		mov	r0, r3
 603 0038 04D04BE2 		sub	sp, fp, #4
 604              		.cfi_def_cfa 13, 8
 605              		@ sp needed
 606 003c 0048BDE8 		pop	{fp, lr}
 607              		.cfi_restore 14
 608              		.cfi_restore 11
 609              		.cfi_def_cfa_offset 0
 610 0040 1EFF2FE1 		bx	lr
 611              	.L33:
 612              		.align	2
 613              	.L32:
 614 0044 00000000 		.word	byte_fifo_get
 615              		.cfi_endproc
 616              	.LFE14:
 618              		.global	main_data
 619              		.bss
 620              		.align	2
 623              	main_data:
 624 0000 000000   		.space	3
 625              		.section	.text._exit,"ax",%progbits
 626              		.align	2
 627              		.global	_exit
 628              		.syntax unified
 629              		.arm
 631              	_exit:
 632              	.LFB15:
   1:main.c        **** #include <math.h>
   2:main.c        **** #include <stdint.h>
   3:main.c        **** #include <stdio.h>
   4:main.c        **** #include <string.h>
   5:main.c        **** #include <unistd.h> //fuer _exit()
   6:main.c        **** 
   7:main.c        **** #include "AT91SAM7S64.h"
   8:main.c        **** #include "lib/aic.h"
   9:main.c        **** #include "lib/display.h"
  10:main.c        **** #include "lib/nxt_avr.h"
  11:main.c        **** #include "lib/systick.h"
  12:main.c        **** #include "lib/term.h"
  13:main.c        **** #include "main.h"
  14:main.c        **** // #include "lib/adc.h"
  15:main.c        **** #if defined(MODE_RAM) || defined(MODE_SIM)
  16:main.c        **** #include "trace32/udmon3.h"
  17:main.c        **** #endif
  18:main.c        **** 
  19:main.c        **** #define ZYKLUS_MS 2
  20:main.c        **** #define IDLE_MS 1
  21:main.c        **** 
  22:main.c        **** #if IDLE_MS >= ZYKLUS_MS
  23:main.c        **** #error "Idle_ms muss kleiner als zyklus_ms sein"
  24:main.c        **** #endif
  25:main.c        **** 
  26:main.c        **** /*****************************************************************************/
  27:main.c        **** /*   Globale Variablen                                                       */
  28:main.c        **** /*****************************************************************************/
  29:main.c        **** struct {
  30:main.c        ****   signed char term_status; // 0->false->Alles Bestens   -1->true->Overflow
  31:main.c        ****   unsigned char term_cnt;
  32:main.c        ****   unsigned char lowbat_cnt;
  33:main.c        **** } main_data = {
  34:main.c        ****     .term_status = 0,
  35:main.c        ****     .term_cnt = 0,
  36:main.c        ****     .lowbat_cnt = 0,
  37:main.c        **** };
  38:main.c        **** 
  39:main.c        **** /*****************************************************************************/
  40:main.c        **** /*   Hilfsroutinen                                                           */
  41:main.c        **** /*   Standard-C-Library (weitere befinden sich in newlib_syscalls.c)         */
  42:main.c        **** /*****************************************************************************/
  43:main.c        **** // Routine wird von C-Lib aufgerufen (bspw. printf() abort())
  44:main.c        **** void _exit(int status) {
 633              		.loc 1 44 24
 634              		.cfi_startproc
 635              		@ Function supports interworking.
 636              		@ args = 0, pretend = 0, frame = 8
 637              		@ frame_needed = 1, uses_anonymous_args = 0
 638              		@ link register save eliminated.
 639 0000 04B02DE5 		str	fp, [sp, #-4]!
 640              		.cfi_def_cfa_offset 4
 641              		.cfi_offset 11, -4
 642 0004 00B08DE2 		add	fp, sp, #0
 643              		.cfi_def_cfa_register 11
 644 0008 0CD04DE2 		sub	sp, sp, #12
 645 000c 08000BE5 		str	r0, [fp, #-8]
 646              	.L35:
  45:main.c        ****   (void)status;
  46:main.c        ****   // LED-Blinken lassen
  47:main.c        ****   // Breakpoint setzen
  48:main.c        ****   while (1)
 647              		.loc 1 48 9
 648 0010 0000A0E1 		nop
 649 0014 FDFFFFEA 		b	.L35
 650              		.cfi_endproc
 651              	.LFE15:
 653              		.global	trace_buf0
 654              		.bss
 655 0003 00       		.align	2
 658              	trace_buf0:
 659 0004 00000000 		.space	400
 659      00000000 
 659      00000000 
 659      00000000 
 659      00000000 
 660              		.global	trace_buf1
 661              		.align	2
 664              	trace_buf1:
 665 0194 00000000 		.space	400
 665      00000000 
 665      00000000 
 665      00000000 
 665      00000000 
 666              		.section	.text.trace_scope,"ax",%progbits
 667              		.align	2
 668              		.global	trace_scope
 669              		.syntax unified
 670              		.arm
 672              	trace_scope:
 673              	.LFB16:
  49:main.c        ****     ;
  50:main.c        **** }
  51:main.c        **** 
  52:main.c        **** /************************************************************************/
  53:main.c        **** /*   Hilfsroutine zur Darstellung eines analogen Verlaufes entsprechend */
  54:main.c        **** /*   einem Oszillosop                                                   */
  55:main.c        **** /************************************************************************/
  56:main.c        **** #define TRACE_SIZE 200
  57:main.c        **** int16_t trace_buf0[TRACE_SIZE];
  58:main.c        **** int16_t trace_buf1[TRACE_SIZE];
  59:main.c        **** // Darstellung des Puffers über 'v.draw %e trace_buf0 trace_buf1'
  60:main.c        **** void trace_scope(int channel, int16_t value) {
 674              		.loc 1 60 46
 675              		.cfi_startproc
 676              		@ Function supports interworking.
 677              		@ args = 0, pretend = 0, frame = 8
 678              		@ frame_needed = 1, uses_anonymous_args = 0
 679              		@ link register save eliminated.
 680 0000 04B02DE5 		str	fp, [sp, #-4]!
 681              		.cfi_def_cfa_offset 4
 682              		.cfi_offset 11, -4
 683 0004 00B08DE2 		add	fp, sp, #0
 684              		.cfi_def_cfa_register 11
 685 0008 0CD04DE2 		sub	sp, sp, #12
 686 000c 08000BE5 		str	r0, [fp, #-8]
 687 0010 0130A0E1 		mov	r3, r1
 688 0014 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
  61:main.c        ****   // #define TRACE_ROLL
  62:main.c        **** #ifdef TRACE_ROLL
  63:main.c        ****   if (channel == 0) {
  64:main.c        ****     for (int lauf = 0; lauf < (TRACE_SIZE - 1); lauf++)
  65:main.c        ****       trace_buf0[lauf] = trace_buf0[lauf + 1];
  66:main.c        ****     trace_buf0[TRACE_SIZE - 1] = value;
  67:main.c        ****   } else {
  68:main.c        ****     for (int lauf = 0; lauf < (TRACE_SIZE - 1); lauf++)
  69:main.c        ****       trace_buf1[lauf] = trace_buf1[lauf + 1];
  70:main.c        ****     trace_buf1[TRACE_SIZE - 1] = value;
  71:main.c        ****   }
  72:main.c        **** #else
  73:main.c        ****   static int trace_index = 0;
  74:main.c        ****   if (trace_index < TRACE_SIZE) {
 689              		.loc 1 74 19
 690 0018 A8309FE5 		ldr	r3, .L43
 691 001c 003093E5 		ldr	r3, [r3]
 692              		.loc 1 74 6
 693 0020 C70053E3 		cmp	r3, #199
 694 0024 110000CA 		bgt	.L37
  75:main.c        ****     if (channel == 0)
 695              		.loc 1 75 8
 696 0028 08301BE5 		ldr	r3, [fp, #-8]
 697 002c 000053E3 		cmp	r3, #0
 698 0030 0700001A 		bne	.L38
  76:main.c        ****       trace_buf0[trace_index] = value;
 699              		.loc 1 76 17
 700 0034 8C309FE5 		ldr	r3, .L43
 701 0038 003093E5 		ldr	r3, [r3]
 702              		.loc 1 76 31
 703 003c 88209FE5 		ldr	r2, .L43+4
 704 0040 8330A0E1 		lsl	r3, r3, #1
 705 0044 033082E0 		add	r3, r2, r3
 706 0048 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 707 004c B020C3E1 		strh	r2, [r3]	@ movhi
 708 0050 060000EA 		b	.L37
 709              	.L38:
  77:main.c        ****     else
  78:main.c        ****       trace_buf1[trace_index] = value;
 710              		.loc 1 78 17
 711 0054 6C309FE5 		ldr	r3, .L43
 712 0058 003093E5 		ldr	r3, [r3]
 713              		.loc 1 78 31
 714 005c 6C209FE5 		ldr	r2, .L43+8
 715 0060 8330A0E1 		lsl	r3, r3, #1
 716 0064 033082E0 		add	r3, r2, r3
 717 0068 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 718 006c B020C3E1 		strh	r2, [r3]	@ movhi
 719              	.L37:
  79:main.c        ****   } else {
  80:main.c        ****     // Pause, damit der Debugger in 'Ruhe' den gesamten Speicher auslesen kann
  81:main.c        ****   }
  82:main.c        ****   if (channel == 1) {
 720              		.loc 1 82 6
 721 0070 08301BE5 		ldr	r3, [fp, #-8]
 722 0074 010053E3 		cmp	r3, #1
 723 0078 0E00001A 		bne	.L42
  83:main.c        ****     trace_index++;
 724              		.loc 1 83 16
 725 007c 44309FE5 		ldr	r3, .L43
 726 0080 003093E5 		ldr	r3, [r3]
 727 0084 013083E2 		add	r3, r3, #1
 728 0088 38209FE5 		ldr	r2, .L43
 729 008c 003082E5 		str	r3, [r2]
  84:main.c        ****     trace_index = trace_index >= (3 * TRACE_SIZE) ? 0 : trace_index;
 730              		.loc 1 84 31
 731 0090 30309FE5 		ldr	r3, .L43
 732 0094 003093E5 		ldr	r3, [r3]
 733              		.loc 1 84 55
 734 0098 960F53E3 		cmp	r3, #600
 735 009c 020000AA 		bge	.L40
 736              		.loc 1 84 55 is_stmt 0 discriminator 1
 737 00a0 20309FE5 		ldr	r3, .L43
 738 00a4 003093E5 		ldr	r3, [r3]
 739 00a8 000000EA 		b	.L41
 740              	.L40:
 741              		.loc 1 84 55 discriminator 2
 742 00ac 0030A0E3 		mov	r3, #0
 743              	.L41:
 744              		.loc 1 84 17 is_stmt 1 discriminator 4
 745 00b0 10209FE5 		ldr	r2, .L43
 746 00b4 003082E5 		str	r3, [r2]
 747              	.L42:
  85:main.c        ****   }
  86:main.c        **** #endif
  87:main.c        **** }
 748              		.loc 1 87 1
 749 00b8 0000A0E1 		nop
 750 00bc 00D08BE2 		add	sp, fp, #0
 751              		.cfi_def_cfa_register 13
 752              		@ sp needed
 753 00c0 04B09DE4 		ldr	fp, [sp], #4
 754              		.cfi_restore 11
 755              		.cfi_def_cfa_offset 0
 756 00c4 1EFF2FE1 		bx	lr
 757              	.L44:
 758              		.align	2
 759              	.L43:
 760 00c8 24030000 		.word	trace_index.3
 761 00cc 00000000 		.word	trace_buf0
 762 00d0 00000000 		.word	trace_buf1
 763              		.cfi_endproc
 764              	.LFE16:
 766              		.global	pio
 767              		.data
 768              		.align	2
 771              	pio:
 772 0000 00F4FFFF 		.word	-3072
 773              		.global	pmc
 774              		.align	2
 777              	pmc:
 778 0004 00FCFFFF 		.word	-1024
 779              		.global	pwm_ctl
 780              		.align	2
 783              	pwm_ctl:
 784 0008 00C0FCFF 		.word	-212992
 785              		.global	pwm_pa23
 786              		.align	2
 789              	pwm_pa23:
 790 000c 00C2FCFF 		.word	-212480
 791              		.global	pwm_pa2
 792              		.align	2
 795              	pwm_pa2:
 796 0010 40C2FCFF 		.word	-212416
 797              		.global	schritt_mode2str
 798              		.section	.rodata
 799              		.align	2
 800              	.LC0:
 801 0000 566F6C6C 		.ascii	"Vollschritt 1\000"
 801      73636872 
 801      69747420 
 801      3100
 802 000e 0000     		.align	2
 803              	.LC1:
 804 0010 566F6C6C 		.ascii	"Vollschritt 2\000"
 804      73636872 
 804      69747420 
 804      3200
 805 001e 0000     		.align	2
 806              	.LC2:
 807 0020 48616C62 		.ascii	"Halbschritt\000"
 807      73636872 
 807      69747400 
 808              		.align	2
 809              	.LC3:
 810 002c 53696E75 		.ascii	"SinusSchritt\000"
 810      73536368 
 810      72697474 
 810      00
 811              		.data
 812              		.align	2
 815              	schritt_mode2str:
 816 0014 00000000 		.word	.LC0
 817 0018 10000000 		.word	.LC1
 818 001c 20000000 		.word	.LC2
 819 0020 2C000000 		.word	.LC3
 820              		.global	schrittmotor_data
 821 0024 00000000 		.align	3
 824              	schrittmotor_data:
 825 0028 00       		.space	1
 826 0029 00       		.byte	0
 827 002a 00       		.byte	0
 828 002b 00       		.byte	0
 829 002c 00       		.byte	0
 830 002d 000000   		.space	3
 831 0030 00000000 		.word	0
 832 0034 00       		.byte	0
 833 0035 00       		.space	1
 834 0036 0001     		.short	256
 835 0038 8000     		.short	128
 836 003a 4000     		.short	64
 837 003c 2000     		.short	32
 838 003e 0100     		.short	1
 839 0040 0000     		.short	0
 840 0042 0000     		.short	0
 841 0044 00000000 		.space	388
 841      00000000 
 841      00000000 
 841      00000000 
 841      00000000 
 842 01c8 00000000 		.word	0
 843 01cc 4A120000 		.word	4682
 844 01d0 E0230000 		.word	9184
 845 01d4 16340000 		.word	13334
 846 01d8 4B420000 		.word	16971
 847 01dc F34D0000 		.word	19955
 848 01e0 9D560000 		.word	22173
 849 01e4 F35B0000 		.word	23539
 850 01e8 C05D0000 		.word	24000
 851 01ec F35B0000 		.word	23539
 852 01f0 9D560000 		.word	22173
 853 01f4 F34D0000 		.word	19955
 854 01f8 4B420000 		.word	16971
 855 01fc 16340000 		.word	13334
 856 0200 E0230000 		.word	9184
 857 0204 4A120000 		.word	4682
 858 0208 00000000 		.word	0
 859 020c B6EDFFFF 		.word	-4682
 860 0210 20DCFFFF 		.word	-9184
 861 0214 EACBFFFF 		.word	-13334
 862 0218 B5BDFFFF 		.word	-16971
 863 021c 0DB2FFFF 		.word	-19955
 864 0220 63A9FFFF 		.word	-22173
 865 0224 0DA4FFFF 		.word	-23539
 866 0228 40A2FFFF 		.word	-24000
 867 022c 0DA4FFFF 		.word	-23539
 868 0230 63A9FFFF 		.word	-22173
 869 0234 0DB2FFFF 		.word	-19955
 870 0238 B5BDFFFF 		.word	-16971
 871 023c EACBFFFF 		.word	-13334
 872 0240 20DCFFFF 		.word	-9184
 873 0244 B6EDFFFF 		.word	-4682
 874 0248 01       		.byte	1
 875 0249 00000000 		.space	7
 875      000000
 876              		.section	.text.schrittmotor_init,"ax",%progbits
 877              		.align	2
 878              		.global	schrittmotor_init
 879              		.syntax unified
 880              		.arm
 882              	schrittmotor_init:
 883              	.LFB17:
  88:main.c        **** 
  89:main.c        **** /*****************************************************************************/
  90:main.c        **** /*   Ihr Programm                                                            */
  91:main.c        **** /*****************************************************************************/
  92:main.c        **** // AT91S_PIO, *AT91PS_PIO
  93:main.c        **** #define SPULE1_PWM (1 << 23)
  94:main.c        **** #define SPULE2_PWM (1 << 2)
  95:main.c        **** #define SPULE1_DIR (1 << 18)
  96:main.c        **** #define SPULE2_DIR (1 << 30)
  97:main.c        **** #define NXT_PORT4_ENABLE (1 << 7)
  98:main.c        **** #define ALL                                                                    \
  99:main.c        ****   (SPULE1_DIR | SPULE2_DIR | SPULE1_PWM | SPULE2_PWM | NXT_PORT4_ENABLE)
 100:main.c        **** #define SPULE1_PWM_BASE AT91C_BASE_PWMC_CH2
 101:main.c        **** #define SPULE2_PWM_BASE AT91C_BASE_PWMC_CH0
 102:main.c        **** 
 103:main.c        **** #define PA30 SPULE2_DIR
 104:main.c        **** #define PA2  SPULE2_PWM
 105:main.c        **** #define PA18 SPULE1_DIR
 106:main.c        **** #define PA23 SPULE1_PWM
 107:main.c        **** #define PA7 NXT_PORT4_ENABLE
 108:main.c        **** 
 109:main.c        **** #define MASK_FULL1   3
 110:main.c        **** #define MASK_FULL2   3
 111:main.c        **** #define MASK_HALF    7
 112:main.c        **** #define MASK_MICRO   31
 113:main.c        **** 
 114:main.c        **** #define PWM_FREQ_HZ   2000
 115:main.c        **** #define MCK_HZ        48000000
 116:main.c        **** #define CPRD_2KHZ     (MCK_HZ / PWM_FREQ_HZ) // = 24000 
 117:main.c        **** #define STEPS_MICRO   32
 118:main.c        **** 
 119:main.c        **** 
 120:main.c        **** 
 121:main.c        **** AT91PS_PIO pio = (AT91PS_PIO)AT91C_BASE_PIOA;
 122:main.c        **** AT91PS_PMC pmc = (AT91PS_PMC)AT91C_BASE_PMC;
 123:main.c        **** AT91PS_PWMC pwm_ctl = (AT91PS_PWMC)AT91C_BASE_PWMC;
 124:main.c        **** 
 125:main.c        **** // AT91PS_PWMC_CH pwm_sp1 = &pwm_ctl->PWMC_CH[0]; AT91PS_PWMC_CH pwm_sp2 =
 126:main.c        **** // &pwm_ctl->PWMC_CH[2];
 127:main.c        **** AT91PS_PWMC_CH pwm_pa23 = (AT91PS_PWMC_CH)AT91C_BASE_PWMC_CH0;
 128:main.c        **** AT91PS_PWMC_CH pwm_pa2 = (AT91PS_PWMC_CH)AT91C_BASE_PWMC_CH2;
 129:main.c        **** 
 130:main.c        **** // PWM=0  DIR=x   Off=Kurzschluss
 131:main.c        **** // PWM=1  DIR=0   Positive
 132:main.c        **** // PWM=1  DIR=1   Negative
 133:main.c        **** 
 134:main.c        **** //  AT91S_PMC, *AT91PS_PMC;
 135:main.c        **** // PA7=0  zum Deaktivieren des RS485 Treibers
 136:main.c        **** 
 137:main.c        **** typedef enum {
 138:main.c        ****   SCHRITT_VOLL_1,
 139:main.c        ****   SCHRITT_VOLL_2,
 140:main.c        ****   SCHRITT_HALB,
 141:main.c        ****   SCHRITT_SINUS,
 142:main.c        ****   SCHRITT_END
 143:main.c        **** } SCHRITT_MODE;
 144:main.c        **** typedef enum {
 145:main.c        ****   POSITION_MANUELL,
 146:main.c        ****   POSITION_KONTINUIERLICH,
 147:main.c        ****   POSITION_END
 148:main.c        **** } POSITION_MODE;
 149:main.c        **** const char *schritt_mode2str[] = {
 150:main.c        ****     [SCHRITT_VOLL_1] = "Vollschritt 1",
 151:main.c        ****     [SCHRITT_VOLL_2] = "Vollschritt 2",
 152:main.c        ****     [SCHRITT_HALB] = "Halbschritt",
 153:main.c        ****     [SCHRITT_SINUS] = "SinusSchritt",
 154:main.c        **** };
 155:main.c        **** 
 156:main.c        **** struct {
 157:main.c        ****   button_t button_old;
 158:main.c        ****   SCHRITT_MODE schritt_mode;
 159:main.c        ****   POSITION_MODE position_mode;
 160:main.c        ****   int8_t pos;
 161:main.c        ****   uint8_t speed;
 162:main.c        ****   uint32_t mode;
 163:main.c        ****   uint8_t step;
 164:main.c        ****   uint16_t reload_table[5];
 165:main.c        ****   uint16_t current_reload;
 166:main.c        ****   uint16_t counter;
 167:main.c        ****   double micro_sign[STEPS_MICRO];
 168:main.c        ****   uint32_t micro_duty[STEPS_MICRO];
 169:main.c        ****   int32_t micro[32];
 170:main.c        ****   int8_t dir;            
 171:main.c        **** 
 172:main.c        **** } schrittmotor_data = {
 173:main.c        ****     .schritt_mode = SCHRITT_VOLL_1,
 174:main.c        ****     .position_mode = POSITION_MANUELL,
 175:main.c        ****     .pos = 0,
 176:main.c        ****     .speed = 0,
 177:main.c        ****     .mode = 0,
 178:main.c        ****     .step = 0,
 179:main.c        ****     .current_reload = 0,
 180:main.c        ****     .dir = 1,
 181:main.c        ****     .counter = 0,
 182:main.c        ****     .reload_table = {
 183:main.c        ****       256, /* speed 0 -> 256*4ms = 1024 ms */
 184:main.c        ****       128, /* speed 1 -> 512 ms */
 185:main.c        ****       64, /* speed 2 -> 256 ms */
 186:main.c        ****       32, /* speed 3 -> 128 ms */
 187:main.c        ****       1  /* speed 4 -> 4 ms  -> schnellster */
 188:main.c        ****     },
 189:main.c        ****     .micro = {
 190:main.c        ****       0,
 191:main.c        ****       4682,
 192:main.c        ****       9184,
 193:main.c        ****       13334,
 194:main.c        ****       16971,
 195:main.c        ****       19955,
 196:main.c        ****       22173,
 197:main.c        ****       23539,
 198:main.c        ****       24000,
 199:main.c        ****       23539,
 200:main.c        ****       22173,
 201:main.c        ****       19955,
 202:main.c        ****       16971,
 203:main.c        ****       13334,
 204:main.c        ****       9184,
 205:main.c        ****       4682,
 206:main.c        ****       0,
 207:main.c        ****       -4682,
 208:main.c        ****       -9184,
 209:main.c        ****       -13334,
 210:main.c        ****       -16971,
 211:main.c        ****       -19955,
 212:main.c        ****       -22173,
 213:main.c        ****       -23539,
 214:main.c        ****       -24000,
 215:main.c        ****       -23539,
 216:main.c        ****       -22173,
 217:main.c        ****       -19955,
 218:main.c        ****       -16971,
 219:main.c        ****       -13334,
 220:main.c        ****       -9184,
 221:main.c        ****       -4682
 222:main.c        **** 
 223:main.c        ****     }
 224:main.c        **** }; 
 225:main.c        **** 
 226:main.c        **** 
 227:main.c        **** 
 228:main.c        **** void schrittmotor_init(SCHRITT_MODE mode) {
 884              		.loc 1 228 43
 885              		.cfi_startproc
 886              		@ Function supports interworking.
 887              		@ args = 0, pretend = 0, frame = 8
 888              		@ frame_needed = 1, uses_anonymous_args = 0
 889              		@ link register save eliminated.
 890 0000 04B02DE5 		str	fp, [sp, #-4]!
 891              		.cfi_def_cfa_offset 4
 892              		.cfi_offset 11, -4
 893 0004 00B08DE2 		add	fp, sp, #0
 894              		.cfi_def_cfa_register 11
 895 0008 0CD04DE2 		sub	sp, sp, #12
 896 000c 0030A0E1 		mov	r3, r0
 897 0010 05304BE5 		strb	r3, [fp, #-5]
 229:main.c        ****   schrittmotor_data.schritt_mode = mode;
 898              		.loc 1 229 34
 899 0014 84219FE5 		ldr	r2, .L49
 900 0018 05305BE5 		ldrb	r3, [fp, #-5]
 901 001c 0130C2E5 		strb	r3, [r2, #1]
 230:main.c        ****   if (mode != SCHRITT_SINUS) {
 902              		.loc 1 230 6
 903 0020 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 904 0024 030053E3 		cmp	r3, #3
 905 0028 1800000A 		beq	.L46
 231:main.c        ****     pmc->PMC_PCER = ((1 << 2) | (1 << 10));
 906              		.loc 1 231 8
 907 002c 70319FE5 		ldr	r3, .L49+4
 908 0030 003093E5 		ldr	r3, [r3]
 909              		.loc 1 231 19
 910 0034 6C219FE5 		ldr	r2, .L49+8
 911 0038 102083E5 		str	r2, [r3, #16]
 232:main.c        ****     pio->PIO_CODR = (1 << 7);
 912              		.loc 1 232 8
 913 003c 68319FE5 		ldr	r3, .L49+12
 914 0040 003093E5 		ldr	r3, [r3]
 915              		.loc 1 232 19
 916 0044 8020A0E3 		mov	r2, #128
 917 0048 342083E5 		str	r2, [r3, #52]
 233:main.c        ****     pio->PIO_MDDR = ALL;
 918              		.loc 1 233 8
 919 004c 58319FE5 		ldr	r3, .L49+12
 920 0050 003093E5 		ldr	r3, [r3]
 921              		.loc 1 233 19
 922 0054 54219FE5 		ldr	r2, .L49+16
 923 0058 542083E5 		str	r2, [r3, #84]
 234:main.c        ****     pio->PIO_PER = ALL;
 924              		.loc 1 234 8
 925 005c 48319FE5 		ldr	r3, .L49+12
 926 0060 003093E5 		ldr	r3, [r3]
 927              		.loc 1 234 18
 928 0064 44219FE5 		ldr	r2, .L49+16
 929 0068 002083E5 		str	r2, [r3]
 235:main.c        ****     pio->PIO_OER = ALL;
 930              		.loc 1 235 8
 931 006c 38319FE5 		ldr	r3, .L49+12
 932 0070 003093E5 		ldr	r3, [r3]
 933              		.loc 1 235 18
 934 0074 34219FE5 		ldr	r2, .L49+16
 935 0078 102083E5 		str	r2, [r3, #16]
 236:main.c        ****     pio->PIO_SODR = (SPULE1_DIR | SPULE2_DIR | SPULE2_PWM | SPULE1_PWM);
 936              		.loc 1 236 8
 937 007c 28319FE5 		ldr	r3, .L49+12
 938 0080 003093E5 		ldr	r3, [r3]
 939              		.loc 1 236 19
 940 0084 28219FE5 		ldr	r2, .L49+20
 941 0088 302083E5 		str	r2, [r3, #48]
 237:main.c        **** 
 238:main.c        ****   } else {
 239:main.c        ****     pmc->PMC_PCER = ((1 << 2) | (1 << 10));
 240:main.c        ****     
 241:main.c        ****     pio->PIO_MDDR = (PA30 | PA18 | PA7);
 242:main.c        ****     pio->PIO_PER = (PA30 | PA18 | PA7);
 243:main.c        ****     pio->PIO_OER = (PA30 | PA18 | PA7);
 244:main.c        ****     pio->PIO_CODR = PA7;
 245:main.c        ****     pio->PIO_SODR = (PA30 | PA18);
 246:main.c        **** 
 247:main.c        ****     pio->PIO_PDR = (PA23 | PA2);
 248:main.c        ****     pio->PIO_ASR = PA2;
 249:main.c        ****     pio->PIO_BSR = PA23;
 250:main.c        **** 
 251:main.c        ****     /* 4) PWMC: Configure channels (set polarity/CPRE BEFORE enabling channel) */
 252:main.c        ****     /* Channel 0 (PA23 -> PWM0) */
 253:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CMR = AT91C_PWMC_CPRE_MCK; /* CPRE = MCK (no prescaler) */
 254:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CPRDR = CPRD_2KHZ;         // Period
 255:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CDTYR = (CPRD_2KHZ / 2);   /* duty = 50% (avoid 0/CPRD) */
 256:main.c        **** 
 257:main.c        ****     /* Channel 2 (PA2 -> PWM2) */
 258:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CMR = AT91C_PWMC_CPRE_MCK; /* CPRE = MCK */
 259:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CPRDR = CPRD_2KHZ;
 260:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CDTYR = (CPRD_2KHZ / 2);
 261:main.c        ****     
 262:main.c        **** 
 263:main.c        ****     /* 5) Optional: Set PWMC global MR if you want CLKA/CLKB (here leave defaults):
 264:main.c        ****        Example: pwm_ctl->PWMC_MR = (AT91C_PWMC_PREA_MCK | AT91C_PWMC_PREB_MCK);
 265:main.c        ****        (not required when using CPRE=MCK)
 266:main.c        ****     */
 267:main.c        **** 
 268:main.c        **** 
 269:main.c        ****     /* 6) Enable channels (enable AFTER CMR/CPRD/CDTY are set and polarity chosen) */
 270:main.c        ****     pwm_ctl->PWMC_ENA = (AT91C_PWMC_CHID0 | AT91C_PWMC_CHID2);
 271:main.c        **** 
 272:main.c        **** 
 273:main.c        ****     // Ausgangs-Multiplexer für PWM auf entsprechende Peripherie setzen
 274:main.c        ****     //- Die Zuordnung, auf welchen Peripheriekanal die PWM Einheit an PA23 /
 275:main.c        ****     // PA2
 276:main.c        ****     // liegt, kann aus Kapitel 10.4 entnommen werden
 277:main.c        ****     //- Für die Microstepping Aufgabe muss PA23 / PA2 weg von Ausgabe auf
 278:main.c        ****     // Peripherie A oder B umprogrammiert werden PA30 und PA18 bitte
 279:main.c        ****     // weiterhin als normale GPIO Ausgabe Konfigurieren (incl. PA7) PA2 ->
 280:main.c        ****     // PWM2 Multiplexer auf A
 281:main.c        **** 
 282:main.c        ****     //pio->PIO_ASR = SPULE2_PWM;
 283:main.c        ****     //pio->PIO_BSR = SPULE1_PWM;
 284:main.c        **** 
 285:main.c        ****     // PWM-Konfigurieren (Kapitel 34)
 286:main.c        ****     //- Für die korrekte Konfiguration der beiden PWM-Channels lesen sie bitte
 287:main.c        ****     // das Kapitel 34 durch. Beachten sie bitte den abschließenden Satz aus
 288:main.c        ****     // Kap 34.5.2.2: The waveform polarity must be set before enabling the
 289:main.c        ****     // channel. This immediately affects the channel output level. Changes on
 290:main.c        ****     // channel polarity are not taken into account while the channel is enabled.
 291:main.c        ****     //- Die Konfigurationsreihenfolge ist ergänzend im Kapitel 34.5.3.1
 292:main.c        ****     // beschrieben
 293:main.c        ****     //- Für das setzen eines neunen Duty-Cycles beachten sie Kapitel 34.5.3.3
 294:main.c        ****     //
 295:main.c        ****     // pwm_ctl->PWMC_ENA;
 296:main.c        **** 
 297:main.c        ****     // configure clock generator
 298:main.c        **** 
 299:main.c        ****     // configure CPRE for sp1->ch sp2-ch
 300:main.c        ****   }
 301:main.c        **** }
 942              		.loc 1 301 1
 943 008c 3F0000EA 		b	.L48
 944              	.L46:
 239:main.c        ****     
 945              		.loc 1 239 8
 946 0090 0C319FE5 		ldr	r3, .L49+4
 947 0094 003093E5 		ldr	r3, [r3]
 239:main.c        ****     
 948              		.loc 1 239 19
 949 0098 08219FE5 		ldr	r2, .L49+8
 950 009c 102083E5 		str	r2, [r3, #16]
 241:main.c        ****     pio->PIO_PER = (PA30 | PA18 | PA7);
 951              		.loc 1 241 8
 952 00a0 04319FE5 		ldr	r3, .L49+12
 953 00a4 003093E5 		ldr	r3, [r3]
 241:main.c        ****     pio->PIO_PER = (PA30 | PA18 | PA7);
 954              		.loc 1 241 19
 955 00a8 08219FE5 		ldr	r2, .L49+24
 956 00ac 542083E5 		str	r2, [r3, #84]
 242:main.c        ****     pio->PIO_OER = (PA30 | PA18 | PA7);
 957              		.loc 1 242 8
 958 00b0 F4309FE5 		ldr	r3, .L49+12
 959 00b4 003093E5 		ldr	r3, [r3]
 242:main.c        ****     pio->PIO_OER = (PA30 | PA18 | PA7);
 960              		.loc 1 242 18
 961 00b8 F8209FE5 		ldr	r2, .L49+24
 962 00bc 002083E5 		str	r2, [r3]
 243:main.c        ****     pio->PIO_CODR = PA7;
 963              		.loc 1 243 8
 964 00c0 E4309FE5 		ldr	r3, .L49+12
 965 00c4 003093E5 		ldr	r3, [r3]
 243:main.c        ****     pio->PIO_CODR = PA7;
 966              		.loc 1 243 18
 967 00c8 E8209FE5 		ldr	r2, .L49+24
 968 00cc 102083E5 		str	r2, [r3, #16]
 244:main.c        ****     pio->PIO_SODR = (PA30 | PA18);
 969              		.loc 1 244 8
 970 00d0 D4309FE5 		ldr	r3, .L49+12
 971 00d4 003093E5 		ldr	r3, [r3]
 244:main.c        ****     pio->PIO_SODR = (PA30 | PA18);
 972              		.loc 1 244 19
 973 00d8 8020A0E3 		mov	r2, #128
 974 00dc 342083E5 		str	r2, [r3, #52]
 245:main.c        **** 
 975              		.loc 1 245 8
 976 00e0 C4309FE5 		ldr	r3, .L49+12
 977 00e4 003093E5 		ldr	r3, [r3]
 245:main.c        **** 
 978              		.loc 1 245 19
 979 00e8 CC209FE5 		ldr	r2, .L49+28
 980 00ec 302083E5 		str	r2, [r3, #48]
 247:main.c        ****     pio->PIO_ASR = PA2;
 981              		.loc 1 247 8
 982 00f0 B4309FE5 		ldr	r3, .L49+12
 983 00f4 003093E5 		ldr	r3, [r3]
 247:main.c        ****     pio->PIO_ASR = PA2;
 984              		.loc 1 247 18
 985 00f8 C0209FE5 		ldr	r2, .L49+32
 986 00fc 042083E5 		str	r2, [r3, #4]
 248:main.c        ****     pio->PIO_BSR = PA23;
 987              		.loc 1 248 8
 988 0100 A4309FE5 		ldr	r3, .L49+12
 989 0104 003093E5 		ldr	r3, [r3]
 248:main.c        ****     pio->PIO_BSR = PA23;
 990              		.loc 1 248 18
 991 0108 0420A0E3 		mov	r2, #4
 992 010c 702083E5 		str	r2, [r3, #112]
 249:main.c        **** 
 993              		.loc 1 249 8
 994 0110 94309FE5 		ldr	r3, .L49+12
 995 0114 003093E5 		ldr	r3, [r3]
 249:main.c        **** 
 996              		.loc 1 249 18
 997 0118 0225A0E3 		mov	r2, #8388608
 998 011c 742083E5 		str	r2, [r3, #116]
 253:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CPRDR = CPRD_2KHZ;         // Period
 999              		.loc 1 253 12
 1000 0120 9C309FE5 		ldr	r3, .L49+36
 1001 0124 003093E5 		ldr	r3, [r3]
 253:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CPRDR = CPRD_2KHZ;         // Period
 1002              		.loc 1 253 34
 1003 0128 0020A0E3 		mov	r2, #0
 1004 012c 002283E5 		str	r2, [r3, #512]
 254:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CDTYR = (CPRD_2KHZ / 2);   /* duty = 50% (avoid 0/CPRD) */
 1005              		.loc 1 254 12
 1006 0130 8C309FE5 		ldr	r3, .L49+36
 1007 0134 003093E5 		ldr	r3, [r3]
 254:main.c        ****     pwm_ctl->PWMC_CH[0].PWMC_CDTYR = (CPRD_2KHZ / 2);   /* duty = 50% (avoid 0/CPRD) */
 1008              		.loc 1 254 36
 1009 0138 88209FE5 		ldr	r2, .L49+40
 1010 013c 082283E5 		str	r2, [r3, #520]
 255:main.c        **** 
 1011              		.loc 1 255 12
 1012 0140 7C309FE5 		ldr	r3, .L49+36
 1013 0144 003093E5 		ldr	r3, [r3]
 255:main.c        **** 
 1014              		.loc 1 255 36
 1015 0148 7C209FE5 		ldr	r2, .L49+44
 1016 014c 042283E5 		str	r2, [r3, #516]
 258:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CPRDR = CPRD_2KHZ;
 1017              		.loc 1 258 12
 1018 0150 6C309FE5 		ldr	r3, .L49+36
 1019 0154 003093E5 		ldr	r3, [r3]
 258:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CPRDR = CPRD_2KHZ;
 1020              		.loc 1 258 34
 1021 0158 0020A0E3 		mov	r2, #0
 1022 015c 402283E5 		str	r2, [r3, #576]
 259:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CDTYR = (CPRD_2KHZ / 2);
 1023              		.loc 1 259 12
 1024 0160 5C309FE5 		ldr	r3, .L49+36
 1025 0164 003093E5 		ldr	r3, [r3]
 259:main.c        ****     pwm_ctl->PWMC_CH[2].PWMC_CDTYR = (CPRD_2KHZ / 2);
 1026              		.loc 1 259 36
 1027 0168 58209FE5 		ldr	r2, .L49+40
 1028 016c 482283E5 		str	r2, [r3, #584]
 260:main.c        ****     
 1029              		.loc 1 260 12
 1030 0170 4C309FE5 		ldr	r3, .L49+36
 1031 0174 003093E5 		ldr	r3, [r3]
 260:main.c        ****     
 1032              		.loc 1 260 36
 1033 0178 4C209FE5 		ldr	r2, .L49+44
 1034 017c 442283E5 		str	r2, [r3, #580]
 270:main.c        **** 
 1035              		.loc 1 270 12
 1036 0180 3C309FE5 		ldr	r3, .L49+36
 1037 0184 003093E5 		ldr	r3, [r3]
 270:main.c        **** 
 1038              		.loc 1 270 23
 1039 0188 0520A0E3 		mov	r2, #5
 1040 018c 042083E5 		str	r2, [r3, #4]
 1041              	.L48:
 1042              		.loc 1 301 1
 1043 0190 0000A0E1 		nop
 1044 0194 00D08BE2 		add	sp, fp, #0
 1045              		.cfi_def_cfa_register 13
 1046              		@ sp needed
 1047 0198 04B09DE4 		ldr	fp, [sp], #4
 1048              		.cfi_restore 11
 1049              		.cfi_def_cfa_offset 0
 1050 019c 1EFF2FE1 		bx	lr
 1051              	.L50:
 1052              		.align	2
 1053              	.L49:
 1054 01a0 00000000 		.word	schrittmotor_data
 1055 01a4 00000000 		.word	pmc
 1056 01a8 04040000 		.word	1028
 1057 01ac 00000000 		.word	pio
 1058 01b0 84008440 		.word	1082392708
 1059 01b4 04008440 		.word	1082392580
 1060 01b8 80000440 		.word	1074004096
 1061 01bc 00000440 		.word	1074003968
 1062 01c0 04008000 		.word	8388612
 1063 01c4 00000000 		.word	pwm_ctl
 1064 01c8 C05D0000 		.word	24000
 1065 01cc E02E0000 		.word	12000
 1066              		.cfi_endproc
 1067              	.LFE17:
 1069              		.section	.text.schrittmotor_update,"ax",%progbits
 1070              		.align	2
 1071              		.global	schrittmotor_update
 1072              		.syntax unified
 1073              		.arm
 1075              	schrittmotor_update:
 1076              	.LFB18:
 302:main.c        **** void schrittmotor_update(void)
 303:main.c        **** {
 1077              		.loc 1 303 1
 1078              		.cfi_startproc
 1079              		@ Function supports interworking.
 1080              		@ args = 0, pretend = 0, frame = 8
 1081              		@ frame_needed = 1, uses_anonymous_args = 0
 1082              		@ link register save eliminated.
 1083 0000 04B02DE5 		str	fp, [sp, #-4]!
 1084              		.cfi_def_cfa_offset 4
 1085              		.cfi_offset 11, -4
 1086 0004 00B08DE2 		add	fp, sp, #0
 1087              		.cfi_def_cfa_register 11
 1088 0008 0CD04DE2 		sub	sp, sp, #12
 304:main.c        ****     uint16_t max_steps;
 305:main.c        ****     switch (schrittmotor_data.schritt_mode) {
 1089              		.loc 1 305 30
 1090 000c 54319FE5 		ldr	r3, .L62
 1091 0010 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1092 0014 0320A0E1 		mov	r2, r3
 1093              		.loc 1 305 5
 1094 0018 4C319FE5 		ldr	r3, .L62+4
 1095 001c 030052E3 		cmp	r2, #3
 1096 0020 0D00008A 		bhi	.L52
 1097 0024 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1098              	.Lrtx54:
 1099 0028 0000A0E1 		nop
 1100              		.section	.rodata
 1101 0039 000000   		.align	2
 1102              	.L54:
 1103 003c 2C000000 		.word	.L57
 1104 0040 38000000 		.word	.L56
 1105 0044 44000000 		.word	.L55
 1106 0048 50000000 		.word	.L53
 1107              		.section	.text.schrittmotor_update
 1108              		.p2align 2
 1109              	.L57:
 306:main.c        ****         case SCHRITT_VOLL_1: max_steps = 3; break;
 1110              		.loc 1 306 40
 1111 002c 0330A0E3 		mov	r3, #3
 1112 0030 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1113              		.loc 1 306 45
 1114 0034 0B0000EA 		b	.L58
 1115              	.L56:
 307:main.c        ****         case SCHRITT_VOLL_2: max_steps = 3; break;
 1116              		.loc 1 307 40
 1117 0038 0330A0E3 		mov	r3, #3
 1118 003c B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1119              		.loc 1 307 45
 1120 0040 080000EA 		b	.L58
 1121              	.L55:
 308:main.c        ****         case SCHRITT_HALB:   max_steps = 7;  break;
 1122              		.loc 1 308 40
 1123 0044 0730A0E3 		mov	r3, #7
 1124 0048 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1125              		.loc 1 308 46
 1126 004c 050000EA 		b	.L58
 1127              	.L53:
 309:main.c        ****         case SCHRITT_SINUS:  max_steps = 31; break;
 1128              		.loc 1 309 40
 1129 0050 1F30A0E3 		mov	r3, #31
 1130 0054 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1131              		.loc 1 309 46
 1132 0058 020000EA 		b	.L58
 1133              	.L52:
 310:main.c        ****         default:             max_steps = 3; break;
 1134              		.loc 1 310 40
 1135 005c 0330A0E3 		mov	r3, #3
 1136 0060 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1137              		.loc 1 310 45
 1138 0064 0000A0E1 		nop
 1139              	.L58:
 311:main.c        ****     }
 312:main.c        **** 
 313:main.c        **** 	if (schrittmotor_data.pos !=0) {
 1140              		.loc 1 313 23
 1141 0068 F8309FE5 		ldr	r3, .L62
 1142 006c D330D3E1 		ldrsb	r3, [r3, #3]
 1143              		.loc 1 313 5
 1144 0070 000053E3 		cmp	r3, #0
 1145 0074 3700000A 		beq	.L61
 314:main.c        **** 				if(schrittmotor_data.pos >0){
 1146              		.loc 1 314 25
 1147 0078 E8309FE5 		ldr	r3, .L62
 1148 007c D330D3E1 		ldrsb	r3, [r3, #3]
 1149              		.loc 1 314 7
 1150 0080 000053E3 		cmp	r3, #0
 1151 0084 170000DA 		ble	.L60
 315:main.c        **** 					schrittmotor_data.step = (schrittmotor_data.step+1) & max_steps;
 1152              		.loc 1 315 49
 1153 0088 D8309FE5 		ldr	r3, .L62
 1154 008c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1155              		.loc 1 315 54
 1156 0090 013083E2 		add	r3, r3, #1
 1157 0094 FF3003E2 		and	r3, r3, #255
 1158 0098 033CA0E1 		lsl	r3, r3, #24
 1159 009c 432CA0E1 		asr	r2, r3, #24
 1160              		.loc 1 315 58
 1161 00a0 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 1162 00a4 033CA0E1 		lsl	r3, r3, #24
 1163 00a8 433CA0E1 		asr	r3, r3, #24
 1164 00ac 023003E0 		and	r3, r3, r2
 1165 00b0 033CA0E1 		lsl	r3, r3, #24
 1166 00b4 433CA0E1 		asr	r3, r3, #24
 1167 00b8 FF2003E2 		and	r2, r3, #255
 1168              		.loc 1 315 29
 1169 00bc A4309FE5 		ldr	r3, .L62
 1170 00c0 0C20C3E5 		strb	r2, [r3, #12]
 316:main.c        **** 					schrittmotor_data.pos--;
 1171              		.loc 1 316 23
 1172 00c4 9C309FE5 		ldr	r3, .L62
 1173 00c8 D330D3E1 		ldrsb	r3, [r3, #3]
 1174              		.loc 1 316 27
 1175 00cc FF3003E2 		and	r3, r3, #255
 1176 00d0 013043E2 		sub	r3, r3, #1
 1177 00d4 FF3003E2 		and	r3, r3, #255
 1178 00d8 033CA0E1 		lsl	r3, r3, #24
 1179 00dc 432CA0E1 		asr	r2, r3, #24
 1180 00e0 80309FE5 		ldr	r3, .L62
 1181 00e4 0320C3E5 		strb	r2, [r3, #3]
 1182              	.L60:
 317:main.c        **** 				}
 318:main.c        **** 
 319:main.c        **** 				if(schrittmotor_data.pos <0){
 1183              		.loc 1 319 25
 1184 00e8 78309FE5 		ldr	r3, .L62
 1185 00ec D330D3E1 		ldrsb	r3, [r3, #3]
 1186              		.loc 1 319 7
 1187 00f0 000053E3 		cmp	r3, #0
 1188 00f4 170000AA 		bge	.L61
 320:main.c        **** 					schrittmotor_data.step = (schrittmotor_data.step-1) & max_steps;
 1189              		.loc 1 320 49
 1190 00f8 68309FE5 		ldr	r3, .L62
 1191 00fc 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1192              		.loc 1 320 54
 1193 0100 013043E2 		sub	r3, r3, #1
 1194 0104 FF3003E2 		and	r3, r3, #255
 1195 0108 033CA0E1 		lsl	r3, r3, #24
 1196 010c 432CA0E1 		asr	r2, r3, #24
 1197              		.loc 1 320 58
 1198 0110 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 1199 0114 033CA0E1 		lsl	r3, r3, #24
 1200 0118 433CA0E1 		asr	r3, r3, #24
 1201 011c 023003E0 		and	r3, r3, r2
 1202 0120 033CA0E1 		lsl	r3, r3, #24
 1203 0124 433CA0E1 		asr	r3, r3, #24
 1204 0128 FF2003E2 		and	r2, r3, #255
 1205              		.loc 1 320 29
 1206 012c 34309FE5 		ldr	r3, .L62
 1207 0130 0C20C3E5 		strb	r2, [r3, #12]
 321:main.c        **** 					schrittmotor_data.pos++;
 1208              		.loc 1 321 23
 1209 0134 2C309FE5 		ldr	r3, .L62
 1210 0138 D330D3E1 		ldrsb	r3, [r3, #3]
 1211              		.loc 1 321 27
 1212 013c FF3003E2 		and	r3, r3, #255
 1213 0140 013083E2 		add	r3, r3, #1
 1214 0144 FF3003E2 		and	r3, r3, #255
 1215 0148 033CA0E1 		lsl	r3, r3, #24
 1216 014c 432CA0E1 		asr	r2, r3, #24
 1217 0150 10309FE5 		ldr	r3, .L62
 1218 0154 0320C3E5 		strb	r2, [r3, #3]
 1219              	.L61:
 322:main.c        **** 
 323:main.c        **** 				}
 324:main.c        **** 
 325:main.c        **** 	}
 326:main.c        **** }
 1220              		.loc 1 326 1
 1221 0158 0000A0E1 		nop
 1222 015c 00D08BE2 		add	sp, fp, #0
 1223              		.cfi_def_cfa_register 13
 1224              		@ sp needed
 1225 0160 04B09DE4 		ldr	fp, [sp], #4
 1226              		.cfi_restore 11
 1227              		.cfi_def_cfa_offset 0
 1228 0164 1EFF2FE1 		bx	lr
 1229              	.L63:
 1230              		.align	2
 1231              	.L62:
 1232 0168 00000000 		.word	schrittmotor_data
 1233 016c 3C000000 		.word	.L54
 1234              		.cfi_endproc
 1235              	.LFE18:
 1237              		.section	.text.schrittmotor_process,"ax",%progbits
 1238              		.align	2
 1239              		.global	schrittmotor_process
 1240              		.syntax unified
 1241              		.arm
 1243              	schrittmotor_process:
 1244              	.LFB19:
 327:main.c        **** 
 328:main.c        **** 
 329:main.c        **** void schrittmotor_process(void) {
 1245              		.loc 1 329 33
 1246              		.cfi_startproc
 1247              		@ Function supports interworking.
 1248              		@ args = 0, pretend = 0, frame = 24
 1249              		@ frame_needed = 1, uses_anonymous_args = 0
 1250 0000 00482DE9 		push	{fp, lr}
 1251              		.cfi_def_cfa_offset 8
 1252              		.cfi_offset 11, -8
 1253              		.cfi_offset 14, -4
 1254 0004 04B08DE2 		add	fp, sp, #4
 1255              		.cfi_def_cfa 11, 4
 1256 0008 18D04DE2 		sub	sp, sp, #24
 330:main.c        ****     switch (schrittmotor_data.schritt_mode) {
 1257              		.loc 1 330 30
 1258 000c 2C349FE5 		ldr	r3, .L109
 1259 0010 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1260 0014 0320A0E1 		mov	r2, r3
 1261              		.loc 1 330 5
 1262 0018 24349FE5 		ldr	r3, .L109+4
 1263 001c 030052E3 		cmp	r2, #3
 1264 0020 FB00008A 		bhi	.L101
 1265 0024 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1266              	.Lrtx67:
 1267 0028 0000A0E1 		nop
 1268              		.section	.rodata
 1269              		.align	2
 1270              	.L67:
 1271 004c 2C000000 		.word	.L70
 1272 0050 00010000 		.word	.L69
 1273 0054 C4010000 		.word	.L68
 1274 0058 18030000 		.word	.L66
 1275              		.section	.text.schrittmotor_process
 1276              		.p2align 2
 1277              	.L70:
 331:main.c        **** 
 332:main.c        ****         case SCHRITT_VOLL_1: {
 333:main.c        ****             if ((schrittmotor_data.pos != 0)) {
 1278              		.loc 1 333 35
 1279 002c 0C349FE5 		ldr	r3, .L109
 1280 0030 D330D3E1 		ldrsb	r3, [r3, #3]
 1281              		.loc 1 333 16
 1282 0034 000053E3 		cmp	r3, #0
 1283 0038 F700000A 		beq	.L102
 334:main.c        ****               schrittmotor_update();
 1284              		.loc 1 334 15
 1285 003c 04349FE5 		ldr	r3, .L109+8
 1286 0040 0FE0A0E1 		mov	lr, pc
 1287 0044 13FF2FE1 		bx	r3
 1288              	.LVL5:
 335:main.c        ****                 switch (schrittmotor_data.step) {
 1289              		.loc 1 335 42
 1290 0048 F0339FE5 		ldr	r3, .L109
 1291 004c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1292 0050 0320A0E1 		mov	r2, r3
 1293              		.loc 1 335 17
 1294 0054 F0339FE5 		ldr	r3, .L109+12
 1295 0058 030052E3 		cmp	r2, #3
 1296 005c 2500008A 		bhi	.L103
 1297 0060 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1298              	.Lrtx74:
 1299 0064 0000A0E1 		nop
 1300              		.section	.rodata
 1301              		.align	2
 1302              	.L74:
 1303 005c 68000000 		.word	.L77
 1304 0060 8C000000 		.word	.L76
 1305 0064 B0000000 		.word	.L75
 1306 0068 D4000000 		.word	.L73
 1307              		.section	.text.schrittmotor_process
 1308              		.p2align 2
 1309              	.L77:
 336:main.c        ****                     case 0:
 337:main.c        ****                         pio->PIO_SODR = SPULE1_PWM;
 1310              		.loc 1 337 28
 1311 0068 E0339FE5 		ldr	r3, .L109+16
 1312 006c 003093E5 		ldr	r3, [r3]
 1313              		.loc 1 337 39
 1314 0070 0225A0E3 		mov	r2, #8388608
 1315 0074 302083E5 		str	r2, [r3, #48]
 338:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE2_PWM);
 1316              		.loc 1 338 28
 1317 0078 D0339FE5 		ldr	r3, .L109+16
 1318 007c 003093E5 		ldr	r3, [r3]
 1319              		.loc 1 338 39
 1320 0080 CC239FE5 		ldr	r2, .L109+20
 1321 0084 342083E5 		str	r2, [r3, #52]
 339:main.c        ****                         break;
 1322              		.loc 1 339 25
 1323 0088 1B0000EA 		b	.L71
 1324              	.L76:
 340:main.c        ****                     case 1:
 341:main.c        ****                         pio->PIO_SODR = SPULE2_PWM;
 1325              		.loc 1 341 28
 1326 008c BC339FE5 		ldr	r3, .L109+16
 1327 0090 003093E5 		ldr	r3, [r3]
 1328              		.loc 1 341 39
 1329 0094 0420A0E3 		mov	r2, #4
 1330 0098 302083E5 		str	r2, [r3, #48]
 342:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE1_PWM);
 1331              		.loc 1 342 28
 1332 009c AC339FE5 		ldr	r3, .L109+16
 1333 00a0 003093E5 		ldr	r3, [r3]
 1334              		.loc 1 342 39
 1335 00a4 AC239FE5 		ldr	r2, .L109+24
 1336 00a8 342083E5 		str	r2, [r3, #52]
 343:main.c        ****                         break;
 1337              		.loc 1 343 25
 1338 00ac 120000EA 		b	.L71
 1339              	.L75:
 344:main.c        ****                     case 2:
 345:main.c        ****                         pio->PIO_SODR = (SPULE1_DIR | SPULE1_PWM);
 1340              		.loc 1 345 28
 1341 00b0 98339FE5 		ldr	r3, .L109+16
 1342 00b4 003093E5 		ldr	r3, [r3]
 1343              		.loc 1 345 39
 1344 00b8 2127A0E3 		mov	r2, #8650752
 1345 00bc 302083E5 		str	r2, [r3, #48]
 346:main.c        ****                         pio->PIO_CODR = (SPULE2_DIR | SPULE2_PWM);
 1346              		.loc 1 346 28
 1347 00c0 88339FE5 		ldr	r3, .L109+16
 1348 00c4 003093E5 		ldr	r3, [r3]
 1349              		.loc 1 346 39
 1350 00c8 1121A0E3 		mov	r2, #1073741828
 1351 00cc 342083E5 		str	r2, [r3, #52]
 347:main.c        ****                         break;
 1352              		.loc 1 347 25
 1353 00d0 090000EA 		b	.L71
 1354              	.L73:
 348:main.c        ****                     case 3:
 349:main.c        ****                         pio->PIO_SODR = (SPULE2_DIR | SPULE2_PWM);
 1355              		.loc 1 349 28
 1356 00d4 74339FE5 		ldr	r3, .L109+16
 1357 00d8 003093E5 		ldr	r3, [r3]
 1358              		.loc 1 349 39
 1359 00dc 1121A0E3 		mov	r2, #1073741828
 1360 00e0 302083E5 		str	r2, [r3, #48]
 350:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE1_PWM);
 1361              		.loc 1 350 28
 1362 00e4 64339FE5 		ldr	r3, .L109+16
 1363 00e8 003093E5 		ldr	r3, [r3]
 1364              		.loc 1 350 39
 1365 00ec 2127A0E3 		mov	r2, #8650752
 1366 00f0 342083E5 		str	r2, [r3, #52]
 351:main.c        ****                         break;
 1367              		.loc 1 351 25
 1368 00f4 000000EA 		b	.L71
 1369              	.L103:
 352:main.c        ****                     default:
 353:main.c        ****                         break;
 1370              		.loc 1 353 25
 1371 00f8 0000A0E1 		nop
 1372              	.L71:
 354:main.c        ****                 }
 355:main.c        ****             }
 356:main.c        ****             break;
 1373              		.loc 1 356 13
 1374 00fc C60000EA 		b	.L102
 1375              	.L69:
 357:main.c        ****         }
 358:main.c        **** 
 359:main.c        ****         case SCHRITT_VOLL_2: {
 360:main.c        ****             if ((schrittmotor_data.pos != 0)) {
 1376              		.loc 1 360 35
 1377 0100 38339FE5 		ldr	r3, .L109
 1378 0104 D330D3E1 		ldrsb	r3, [r3, #3]
 1379              		.loc 1 360 16
 1380 0108 000053E3 		cmp	r3, #0
 1381 010c C400000A 		beq	.L104
 361:main.c        ****               schrittmotor_update();
 1382              		.loc 1 361 15
 1383 0110 30339FE5 		ldr	r3, .L109+8
 1384 0114 0FE0A0E1 		mov	lr, pc
 1385 0118 13FF2FE1 		bx	r3
 1386              	.LVL6:
 362:main.c        ****                 switch (schrittmotor_data.step) {
 1387              		.loc 1 362 42
 1388 011c 1C339FE5 		ldr	r3, .L109
 1389 0120 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1390 0124 0320A0E1 		mov	r2, r3
 1391              		.loc 1 362 17
 1392 0128 2C339FE5 		ldr	r3, .L109+28
 1393 012c 030052E3 		cmp	r2, #3
 1394 0130 2100008A 		bhi	.L105
 1395 0134 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1396              	.Lrtx82:
 1397 0138 0000A0E1 		nop
 1398              		.section	.rodata
 1399              		.align	2
 1400              	.L82:
 1401 006c 3C010000 		.word	.L85
 1402 0070 60010000 		.word	.L84
 1403 0074 84010000 		.word	.L83
 1404 0078 98010000 		.word	.L81
 1405              		.section	.text.schrittmotor_process
 1406              		.p2align 2
 1407              	.L85:
 363:main.c        ****                     case 0:
 364:main.c        ****                         pio->PIO_SODR = (PA2 | PA23);
 1408              		.loc 1 364 28
 1409 013c 0C339FE5 		ldr	r3, .L109+16
 1410 0140 003093E5 		ldr	r3, [r3]
 1411              		.loc 1 364 39
 1412 0144 14239FE5 		ldr	r2, .L109+32
 1413 0148 302083E5 		str	r2, [r3, #48]
 365:main.c        ****                         pio->PIO_CODR = (PA30 | PA18);
 1414              		.loc 1 365 28
 1415 014c FC329FE5 		ldr	r3, .L109+16
 1416 0150 003093E5 		ldr	r3, [r3]
 1417              		.loc 1 365 39
 1418 0154 08239FE5 		ldr	r2, .L109+36
 1419 0158 342083E5 		str	r2, [r3, #52]
 366:main.c        ****                         break;
 1420              		.loc 1 366 25
 1421 015c 170000EA 		b	.L79
 1422              	.L84:
 367:main.c        ****                     case 1:
 368:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18);
 1423              		.loc 1 368 28
 1424 0160 E8329FE5 		ldr	r3, .L109+16
 1425 0164 003093E5 		ldr	r3, [r3]
 1426              		.loc 1 368 39
 1427 0168 F8229FE5 		ldr	r2, .L109+40
 1428 016c 302083E5 		str	r2, [r3, #48]
 369:main.c        ****                         pio->PIO_CODR = (PA30);
 1429              		.loc 1 369 28
 1430 0170 D8329FE5 		ldr	r3, .L109+16
 1431 0174 003093E5 		ldr	r3, [r3]
 1432              		.loc 1 369 39
 1433 0178 0121A0E3 		mov	r2, #1073741824
 1434 017c 342083E5 		str	r2, [r3, #52]
 370:main.c        ****                         break;
 1435              		.loc 1 370 25
 1436 0180 0E0000EA 		b	.L79
 1437              	.L83:
 371:main.c        ****                     case 2:
 372:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18 | PA30);
 1438              		.loc 1 372 28
 1439 0184 C4329FE5 		ldr	r3, .L109+16
 1440 0188 003093E5 		ldr	r3, [r3]
 1441              		.loc 1 372 39
 1442 018c D8229FE5 		ldr	r2, .L109+44
 1443 0190 302083E5 		str	r2, [r3, #48]
 373:main.c        ****                         break;
 1444              		.loc 1 373 25
 1445 0194 090000EA 		b	.L79
 1446              	.L81:
 374:main.c        ****                     case 3:
 375:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA30);
 1447              		.loc 1 375 28
 1448 0198 B0329FE5 		ldr	r3, .L109+16
 1449 019c 003093E5 		ldr	r3, [r3]
 1450              		.loc 1 375 39
 1451 01a0 C8229FE5 		ldr	r2, .L109+48
 1452 01a4 302083E5 		str	r2, [r3, #48]
 376:main.c        ****                         pio->PIO_CODR = (PA18);
 1453              		.loc 1 376 28
 1454 01a8 A0329FE5 		ldr	r3, .L109+16
 1455 01ac 003093E5 		ldr	r3, [r3]
 1456              		.loc 1 376 39
 1457 01b0 0127A0E3 		mov	r2, #262144
 1458 01b4 342083E5 		str	r2, [r3, #52]
 377:main.c        ****                         break;
 1459              		.loc 1 377 25
 1460 01b8 000000EA 		b	.L79
 1461              	.L105:
 378:main.c        ****                     default:
 379:main.c        ****                         break;
 1462              		.loc 1 379 25
 1463 01bc 0000A0E1 		nop
 1464              	.L79:
 380:main.c        ****                 }
 381:main.c        ****             }
 382:main.c        ****             break;
 1465              		.loc 1 382 13
 1466 01c0 970000EA 		b	.L104
 1467              	.L68:
 383:main.c        ****         }
 384:main.c        **** 
 385:main.c        ****         case SCHRITT_HALB: {
 386:main.c        ****             if ((schrittmotor_data.pos != 0)) {
 1468              		.loc 1 386 35
 1469 01c4 74329FE5 		ldr	r3, .L109
 1470 01c8 D330D3E1 		ldrsb	r3, [r3, #3]
 1471              		.loc 1 386 16
 1472 01cc 000053E3 		cmp	r3, #0
 1473 01d0 9500000A 		beq	.L106
 387:main.c        ****               schrittmotor_update();
 1474              		.loc 1 387 15
 1475 01d4 6C329FE5 		ldr	r3, .L109+8
 1476 01d8 0FE0A0E1 		mov	lr, pc
 1477 01dc 13FF2FE1 		bx	r3
 1478              	.LVL7:
 388:main.c        ****                 switch (schrittmotor_data.step) {
 1479              		.loc 1 388 42
 1480 01e0 58329FE5 		ldr	r3, .L109
 1481 01e4 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1482 01e8 0320A0E1 		mov	r2, r3
 1483              		.loc 1 388 17
 1484 01ec 80329FE5 		ldr	r3, .L109+52
 1485 01f0 070052E3 		cmp	r2, #7
 1486 01f4 4500008A 		bhi	.L107
 1487 01f8 02F193E7 		ldr	pc, [r3, r2, lsl #2]
 1488              	.Lrtx89:
 1489 01fc 0000A0E1 		nop
 1490              		.section	.rodata
 1491              		.align	2
 1492              	.L89:
 1493 007c 00020000 		.word	.L96
 1494 0080 24020000 		.word	.L95
 1495 0084 48020000 		.word	.L94
 1496 0088 6C020000 		.word	.L93
 1497 008c 90020000 		.word	.L92
 1498 0090 B4020000 		.word	.L91
 1499 0094 C8020000 		.word	.L90
 1500 0098 EC020000 		.word	.L88
 1501              		.section	.text.schrittmotor_process
 1502              		.p2align 2
 1503              	.L96:
 389:main.c        ****                     case 0:
 390:main.c        ****                         pio->PIO_SODR = SPULE1_PWM;
 1504              		.loc 1 390 28
 1505 0200 48329FE5 		ldr	r3, .L109+16
 1506 0204 003093E5 		ldr	r3, [r3]
 1507              		.loc 1 390 39
 1508 0208 0225A0E3 		mov	r2, #8388608
 1509 020c 302083E5 		str	r2, [r3, #48]
 391:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE2_PWM);
 1510              		.loc 1 391 28
 1511 0210 38329FE5 		ldr	r3, .L109+16
 1512 0214 003093E5 		ldr	r3, [r3]
 1513              		.loc 1 391 39
 1514 0218 34229FE5 		ldr	r2, .L109+20
 1515 021c 342083E5 		str	r2, [r3, #52]
 392:main.c        ****                         break;
 1516              		.loc 1 392 25
 1517 0220 3B0000EA 		b	.L86
 1518              	.L95:
 393:main.c        ****                     case 1:
 394:main.c        ****                         pio->PIO_SODR = (PA2 | PA23);
 1519              		.loc 1 394 28
 1520 0224 24329FE5 		ldr	r3, .L109+16
 1521 0228 003093E5 		ldr	r3, [r3]
 1522              		.loc 1 394 39
 1523 022c 2C229FE5 		ldr	r2, .L109+32
 1524 0230 302083E5 		str	r2, [r3, #48]
 395:main.c        ****                         pio->PIO_CODR = (PA30 | PA18);
 1525              		.loc 1 395 28
 1526 0234 14329FE5 		ldr	r3, .L109+16
 1527 0238 003093E5 		ldr	r3, [r3]
 1528              		.loc 1 395 39
 1529 023c 20229FE5 		ldr	r2, .L109+36
 1530 0240 342083E5 		str	r2, [r3, #52]
 396:main.c        ****                         break;
 1531              		.loc 1 396 25
 1532 0244 320000EA 		b	.L86
 1533              	.L94:
 397:main.c        ****                     case 2:
 398:main.c        ****                         pio->PIO_SODR = SPULE2_PWM;
 1534              		.loc 1 398 28
 1535 0248 00329FE5 		ldr	r3, .L109+16
 1536 024c 003093E5 		ldr	r3, [r3]
 1537              		.loc 1 398 39
 1538 0250 0420A0E3 		mov	r2, #4
 1539 0254 302083E5 		str	r2, [r3, #48]
 399:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE2_DIR | SPULE1_PWM);
 1540              		.loc 1 399 28
 1541 0258 F0319FE5 		ldr	r3, .L109+16
 1542 025c 003093E5 		ldr	r3, [r3]
 1543              		.loc 1 399 39
 1544 0260 F0219FE5 		ldr	r2, .L109+24
 1545 0264 342083E5 		str	r2, [r3, #52]
 400:main.c        ****                         break;
 1546              		.loc 1 400 25
 1547 0268 290000EA 		b	.L86
 1548              	.L93:
 401:main.c        ****                     case 3:
 402:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18);
 1549              		.loc 1 402 28
 1550 026c DC319FE5 		ldr	r3, .L109+16
 1551 0270 003093E5 		ldr	r3, [r3]
 1552              		.loc 1 402 39
 1553 0274 EC219FE5 		ldr	r2, .L109+40
 1554 0278 302083E5 		str	r2, [r3, #48]
 403:main.c        ****                         pio->PIO_CODR = (PA30);
 1555              		.loc 1 403 28
 1556 027c CC319FE5 		ldr	r3, .L109+16
 1557 0280 003093E5 		ldr	r3, [r3]
 1558              		.loc 1 403 39
 1559 0284 0121A0E3 		mov	r2, #1073741824
 1560 0288 342083E5 		str	r2, [r3, #52]
 404:main.c        ****                         break;
 1561              		.loc 1 404 25
 1562 028c 200000EA 		b	.L86
 1563              	.L92:
 405:main.c        ****                     case 4:
 406:main.c        ****                         pio->PIO_SODR = (SPULE1_DIR | SPULE1_PWM);
 1564              		.loc 1 406 28
 1565 0290 B8319FE5 		ldr	r3, .L109+16
 1566 0294 003093E5 		ldr	r3, [r3]
 1567              		.loc 1 406 39
 1568 0298 2127A0E3 		mov	r2, #8650752
 1569 029c 302083E5 		str	r2, [r3, #48]
 407:main.c        ****                         pio->PIO_CODR = (SPULE2_DIR | SPULE2_PWM);
 1570              		.loc 1 407 28
 1571 02a0 A8319FE5 		ldr	r3, .L109+16
 1572 02a4 003093E5 		ldr	r3, [r3]
 1573              		.loc 1 407 39
 1574 02a8 1121A0E3 		mov	r2, #1073741828
 1575 02ac 342083E5 		str	r2, [r3, #52]
 408:main.c        ****                         break;
 1576              		.loc 1 408 25
 1577 02b0 170000EA 		b	.L86
 1578              	.L91:
 409:main.c        ****                     case 5:
 410:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA18 | PA30);
 1579              		.loc 1 410 28
 1580 02b4 94319FE5 		ldr	r3, .L109+16
 1581 02b8 003093E5 		ldr	r3, [r3]
 1582              		.loc 1 410 39
 1583 02bc A8219FE5 		ldr	r2, .L109+44
 1584 02c0 302083E5 		str	r2, [r3, #48]
 411:main.c        ****                         break;
 1585              		.loc 1 411 25
 1586 02c4 120000EA 		b	.L86
 1587              	.L90:
 412:main.c        ****                     case 6:
 413:main.c        ****                         pio->PIO_SODR = (SPULE2_DIR | SPULE2_PWM);
 1588              		.loc 1 413 28
 1589 02c8 80319FE5 		ldr	r3, .L109+16
 1590 02cc 003093E5 		ldr	r3, [r3]
 1591              		.loc 1 413 39
 1592 02d0 1121A0E3 		mov	r2, #1073741828
 1593 02d4 302083E5 		str	r2, [r3, #48]
 414:main.c        ****                         pio->PIO_CODR = (SPULE1_DIR | SPULE1_PWM);
 1594              		.loc 1 414 28
 1595 02d8 70319FE5 		ldr	r3, .L109+16
 1596 02dc 003093E5 		ldr	r3, [r3]
 1597              		.loc 1 414 39
 1598 02e0 2127A0E3 		mov	r2, #8650752
 1599 02e4 342083E5 		str	r2, [r3, #52]
 415:main.c        ****                         break;
 1600              		.loc 1 415 25
 1601 02e8 090000EA 		b	.L86
 1602              	.L88:
 416:main.c        ****                     case 7:
 417:main.c        ****                         pio->PIO_SODR = (PA2 | PA23 | PA30);
 1603              		.loc 1 417 28
 1604 02ec 5C319FE5 		ldr	r3, .L109+16
 1605 02f0 003093E5 		ldr	r3, [r3]
 1606              		.loc 1 417 39
 1607 02f4 74219FE5 		ldr	r2, .L109+48
 1608 02f8 302083E5 		str	r2, [r3, #48]
 418:main.c        ****                         pio->PIO_CODR = (PA18);
 1609              		.loc 1 418 28
 1610 02fc 4C319FE5 		ldr	r3, .L109+16
 1611 0300 003093E5 		ldr	r3, [r3]
 1612              		.loc 1 418 39
 1613 0304 0127A0E3 		mov	r2, #262144
 1614 0308 342083E5 		str	r2, [r3, #52]
 419:main.c        ****                         break;
 1615              		.loc 1 419 25
 1616 030c 000000EA 		b	.L86
 1617              	.L107:
 420:main.c        ****                     default:
 421:main.c        ****                         break;
 1618              		.loc 1 421 25
 1619 0310 0000A0E1 		nop
 1620              	.L86:
 422:main.c        ****                 }
 423:main.c        ****             }
 424:main.c        ****             break;
 1621              		.loc 1 424 13
 1622 0314 440000EA 		b	.L106
 1623              	.L66:
 1624              	.LBB7:
 425:main.c        ****         }
 426:main.c        **** 
 427:main.c        ****         case SCHRITT_SINUS: {
 428:main.c        **** 
 429:main.c        ****             schrittmotor_update();
 1625              		.loc 1 429 13
 1626 0318 28319FE5 		ldr	r3, .L109+8
 1627 031c 0FE0A0E1 		mov	lr, pc
 1628 0320 13FF2FE1 		bx	r3
 1629              	.LVL8:
 430:main.c        **** 
 431:main.c        ****             // A = sin, B = cos = sin + 90deg
 432:main.c        ****             uint8_t idxA = schrittmotor_data.step & MASK_MICRO;
 1630              		.loc 1 432 45
 1631 0324 14319FE5 		ldr	r3, .L109
 1632 0328 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1633              		.loc 1 432 21
 1634 032c 1F3003E2 		and	r3, r3, #31
 1635 0330 05304BE5 		strb	r3, [fp, #-5]
 433:main.c        ****             uint8_t idxB = (idxA + (STEPS_MICRO / 4)) & MASK_MICRO; 
 1636              		.loc 1 433 34
 1637 0334 05305BE5 		ldrb	r3, [fp, #-5]
 1638 0338 083083E2 		add	r3, r3, #8
 1639 033c FF3003E2 		and	r3, r3, #255
 1640              		.loc 1 433 21
 1641 0340 1F3003E2 		and	r3, r3, #31
 1642 0344 06304BE5 		strb	r3, [fp, #-6]
 434:main.c        **** 
 435:main.c        ****             //Array auslesen
 436:main.c        ****             int32_t sampleA = (int32_t) schrittmotor_data.micro[idxA];
 1643              		.loc 1 436 31
 1644 0348 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1645              		.loc 1 436 21
 1646 034c EC209FE5 		ldr	r2, .L109
 1647 0350 683083E2 		add	r3, r3, #104
 1648 0354 033192E7 		ldr	r3, [r2, r3, lsl #2]
 1649 0358 0C300BE5 		str	r3, [fp, #-12]
 437:main.c        ****             int32_t sampleB = (int32_t) schrittmotor_data.micro[idxB];
 1650              		.loc 1 437 31
 1651 035c 06305BE5 		ldrb	r3, [fp, #-6]	@ zero_extendqisi2
 1652              		.loc 1 437 21
 1653 0360 D8209FE5 		ldr	r2, .L109
 1654 0364 683083E2 		add	r3, r3, #104
 1655 0368 033192E7 		ldr	r3, [r2, r3, lsl #2]
 1656 036c 10300BE5 		str	r3, [fp, #-16]
 438:main.c        **** 
 439:main.c        ****            
 440:main.c        ****             if (sampleB >= 0) {
 1657              		.loc 1 440 16
 1658 0370 10301BE5 		ldr	r3, [fp, #-16]
 1659 0374 000053E3 		cmp	r3, #0
 1660 0378 040000BA 		blt	.L97
 441:main.c        ****                 pio->PIO_CODR = SPULE1_DIR;
 1661              		.loc 1 441 20
 1662 037c CC309FE5 		ldr	r3, .L109+16
 1663 0380 003093E5 		ldr	r3, [r3]
 1664              		.loc 1 441 31
 1665 0384 0127A0E3 		mov	r2, #262144
 1666 0388 342083E5 		str	r2, [r3, #52]
 1667 038c 030000EA 		b	.L98
 1668              	.L97:
 442:main.c        ****             } else {
 443:main.c        ****                 pio->PIO_SODR = SPULE1_DIR;
 1669              		.loc 1 443 20
 1670 0390 B8309FE5 		ldr	r3, .L109+16
 1671 0394 003093E5 		ldr	r3, [r3]
 1672              		.loc 1 443 31
 1673 0398 0127A0E3 		mov	r2, #262144
 1674 039c 302083E5 		str	r2, [r3, #48]
 1675              	.L98:
 444:main.c        ****             }
 445:main.c        **** 
 446:main.c        ****             if (sampleA >= 0) {
 1676              		.loc 1 446 16
 1677 03a0 0C301BE5 		ldr	r3, [fp, #-12]
 1678 03a4 000053E3 		cmp	r3, #0
 1679 03a8 040000BA 		blt	.L99
 447:main.c        ****                 pio->PIO_CODR = SPULE2_DIR;
 1680              		.loc 1 447 20
 1681 03ac 9C309FE5 		ldr	r3, .L109+16
 1682 03b0 003093E5 		ldr	r3, [r3]
 1683              		.loc 1 447 31
 1684 03b4 0121A0E3 		mov	r2, #1073741824
 1685 03b8 342083E5 		str	r2, [r3, #52]
 1686 03bc 030000EA 		b	.L100
 1687              	.L99:
 448:main.c        ****             } else {
 449:main.c        ****                 pio->PIO_SODR = SPULE2_DIR;
 1688              		.loc 1 449 20
 1689 03c0 88309FE5 		ldr	r3, .L109+16
 1690 03c4 003093E5 		ldr	r3, [r3]
 1691              		.loc 1 449 31
 1692 03c8 0121A0E3 		mov	r2, #1073741824
 1693 03cc 302083E5 		str	r2, [r3, #48]
 1694              	.L100:
 450:main.c        ****             }
 451:main.c        **** 
 452:main.c        ****             uint32_t dutyA = (uint32_t)(sampleA >= 0 ? sampleA : -sampleA);
 1695              		.loc 1 452 30
 1696 03d0 0C301BE5 		ldr	r3, [fp, #-12]
 1697 03d4 000053E3 		cmp	r3, #0
 1698 03d8 003063B2 		rsblt	r3, r3, #0
 1699              		.loc 1 452 22
 1700 03dc 14300BE5 		str	r3, [fp, #-20]
 453:main.c        ****             uint32_t dutyB = (uint32_t)(sampleB >= 0 ? sampleB : -sampleB);
 1701              		.loc 1 453 30
 1702 03e0 10301BE5 		ldr	r3, [fp, #-16]
 1703 03e4 000053E3 		cmp	r3, #0
 1704 03e8 003063B2 		rsblt	r3, r3, #0
 1705              		.loc 1 453 22
 1706 03ec 18300BE5 		str	r3, [fp, #-24]
 454:main.c        **** 
 455:main.c        ****  
 456:main.c        ****             pwm_ctl->PWMC_CH[0].PWMC_CUPDR = dutyA; // PA23 -> channel 0 
 1707              		.loc 1 456 20
 1708 03f0 80309FE5 		ldr	r3, .L109+56
 1709 03f4 003093E5 		ldr	r3, [r3]
 1710              		.loc 1 456 44
 1711 03f8 14201BE5 		ldr	r2, [fp, #-20]
 1712 03fc 102283E5 		str	r2, [r3, #528]
 457:main.c        ****             pwm_ctl->PWMC_CH[2].PWMC_CUPDR = dutyB; // PA2  -> channel 2 
 1713              		.loc 1 457 20
 1714 0400 70309FE5 		ldr	r3, .L109+56
 1715 0404 003093E5 		ldr	r3, [r3]
 1716              		.loc 1 457 44
 1717 0408 18201BE5 		ldr	r2, [fp, #-24]
 1718 040c 502283E5 		str	r2, [r3, #592]
 458:main.c        **** 
 459:main.c        ****             break;
 1719              		.loc 1 459 13
 1720 0410 060000EA 		b	.L78
 1721              	.L101:
 1722              	.LBE7:
 460:main.c        ****         }
 461:main.c        **** 
 462:main.c        ****         default: {
 463:main.c        ****             
 464:main.c        ****             break;
 1723              		.loc 1 464 13
 1724 0414 0000A0E1 		nop
 1725 0418 040000EA 		b	.L108
 1726              	.L102:
 356:main.c        ****         }
 1727              		.loc 1 356 13
 1728 041c 0000A0E1 		nop
 1729 0420 020000EA 		b	.L108
 1730              	.L104:
 382:main.c        ****         }
 1731              		.loc 1 382 13
 1732 0424 0000A0E1 		nop
 1733 0428 000000EA 		b	.L108
 1734              	.L106:
 424:main.c        ****         }
 1735              		.loc 1 424 13
 1736 042c 0000A0E1 		nop
 1737              	.L78:
 1738              	.L108:
 465:main.c        ****         }
 466:main.c        ****     } 
 467:main.c        **** } 
 1739              		.loc 1 467 1
 1740 0430 0000A0E1 		nop
 1741 0434 04D04BE2 		sub	sp, fp, #4
 1742              		.cfi_def_cfa 13, 8
 1743              		@ sp needed
 1744 0438 0048BDE8 		pop	{fp, lr}
 1745              		.cfi_restore 14
 1746              		.cfi_restore 11
 1747              		.cfi_def_cfa_offset 0
 1748 043c 1EFF2FE1 		bx	lr
 1749              	.L110:
 1750              		.align	2
 1751              	.L109:
 1752 0440 00000000 		.word	schrittmotor_data
 1753 0444 4C000000 		.word	.L67
 1754 0448 00000000 		.word	schrittmotor_update
 1755 044c 5C000000 		.word	.L74
 1756 0450 00000000 		.word	pio
 1757 0454 04000440 		.word	1074003972
 1758 0458 00008440 		.word	1082392576
 1759 045c 6C000000 		.word	.L82
 1760 0460 04008000 		.word	8388612
 1761 0464 00000440 		.word	1074003968
 1762 0468 04008400 		.word	8650756
 1763 046c 04008440 		.word	1082392580
 1764 0470 04008040 		.word	1082130436
 1765 0474 7C000000 		.word	.L89
 1766 0478 00000000 		.word	pwm_ctl
 1767              		.cfi_endproc
 1768              	.LFE19:
 1770              		.section	.text.ui_init,"ax",%progbits
 1771              		.align	2
 1772              		.global	ui_init
 1773              		.syntax unified
 1774              		.arm
 1776              	ui_init:
 1777              	.LFB20:
 468:main.c        **** 
 469:main.c        **** 
 470:main.c        ****   // wird von der task_4ms() zyklisch alle 4ms aufgerufen
 471:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 472:main.c        **** 
 473:main.c        ****   //nxt_avr_get_sensor_adc_raw()
 474:main.c        **** 
 475:main.c        ****   // Poti-Spannung über nxt_avr_get_sensor_adc_raw(Port). Der Wertebereich liegt
 476:main.c        ****   // im Bereich von 0x000..0x3FF
 477:main.c        **** 
 478:main.c        **** 
 479:main.c        **** 
 480:main.c        **** void ui_init(void) {}
 1778              		.loc 1 480 20
 1779              		.cfi_startproc
 1780              		@ Function supports interworking.
 1781              		@ args = 0, pretend = 0, frame = 0
 1782              		@ frame_needed = 1, uses_anonymous_args = 0
 1783              		@ link register save eliminated.
 1784 0000 04B02DE5 		str	fp, [sp, #-4]!
 1785              		.cfi_def_cfa_offset 4
 1786              		.cfi_offset 11, -4
 1787 0004 00B08DE2 		add	fp, sp, #0
 1788              		.cfi_def_cfa_register 11
 1789              		.loc 1 480 21
 1790 0008 0000A0E1 		nop
 1791 000c 00D08BE2 		add	sp, fp, #0
 1792              		.cfi_def_cfa_register 13
 1793              		@ sp needed
 1794 0010 04B09DE4 		ldr	fp, [sp], #4
 1795              		.cfi_restore 11
 1796              		.cfi_def_cfa_offset 0
 1797 0014 1EFF2FE1 		bx	lr
 1798              		.cfi_endproc
 1799              	.LFE20:
 1801              		.section	.text.ui_process,"ax",%progbits
 1802              		.align	2
 1803              		.global	ui_process
 1804              		.syntax unified
 1805              		.arm
 1807              	ui_process:
 1808              	.LFB21:
 481:main.c        **** 
 482:main.c        **** void ui_process(void) {
 1809              		.loc 1 482 23
 1810              		.cfi_startproc
 1811              		@ Function supports interworking.
 1812              		@ args = 0, pretend = 0, frame = 8
 1813              		@ frame_needed = 1, uses_anonymous_args = 0
 1814 0000 00482DE9 		push	{fp, lr}
 1815              		.cfi_def_cfa_offset 8
 1816              		.cfi_offset 11, -8
 1817              		.cfi_offset 14, -4
 1818 0004 04B08DE2 		add	fp, sp, #4
 1819              		.cfi_def_cfa 11, 4
 1820 0008 08D04DE2 		sub	sp, sp, #8
 483:main.c        ****  
 484:main.c        **** 
 485:main.c        ****   button_t button_new = nxt_avr_get_buttons();
 1821              		.loc 1 485 25
 1822 000c 60349FE5 		ldr	r3, .L129
 1823 0010 0FE0A0E1 		mov	lr, pc
 1824 0014 13FF2FE1 		bx	r3
 1825              	.LVL9:
 1826 0018 0030A0E1 		mov	r3, r0
 1827 001c 08304BE5 		strb	r3, [fp, #-8]
 486:main.c        **** 
 487:main.c        ****   if ((button_new.orange == 1) && (schrittmotor_data.button_old.orange == 0)) {
 1828              		.loc 1 487 26
 1829 0020 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1830 0024 013003E2 		and	r3, r3, #1
 1831 0028 FF3003E2 		and	r3, r3, #255
 1832              		.loc 1 487 6
 1833 002c 000053E3 		cmp	r3, #0
 1834 0030 1F00000A 		beq	.L113
 1835              		.loc 1 487 72 discriminator 1
 1836 0034 3C349FE5 		ldr	r3, .L129+4
 1837 0038 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1838 003c 013003E2 		and	r3, r3, #1
 1839 0040 FF3003E2 		and	r3, r3, #255
 1840              		.loc 1 487 32 discriminator 1
 1841 0044 000053E3 		cmp	r3, #0
 1842 0048 1900001A 		bne	.L113
 488:main.c        **** 
 489:main.c        ****     if (schrittmotor_data.schritt_mode + 1 < SCHRITT_END) {
 1843              		.loc 1 489 26
 1844 004c 24349FE5 		ldr	r3, .L129+4
 1845 0050 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1846              		.loc 1 489 8
 1847 0054 020053E3 		cmp	r3, #2
 1848 0058 0C00008A 		bhi	.L114
 490:main.c        ****       schrittmotor_data.schritt_mode++;
 1849              		.loc 1 490 24
 1850 005c 14349FE5 		ldr	r3, .L129+4
 1851 0060 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1852              		.loc 1 490 37
 1853 0064 013083E2 		add	r3, r3, #1
 1854 0068 FF2003E2 		and	r2, r3, #255
 1855 006c 04349FE5 		ldr	r3, .L129+4
 1856 0070 0120C3E5 		strb	r2, [r3, #1]
 491:main.c        ****       schrittmotor_init(schrittmotor_data.schritt_mode);
 1857              		.loc 1 491 7
 1858 0074 FC339FE5 		ldr	r3, .L129+4
 1859 0078 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1860 007c 0300A0E1 		mov	r0, r3
 1861 0080 F4339FE5 		ldr	r3, .L129+8
 1862 0084 0FE0A0E1 		mov	lr, pc
 1863 0088 13FF2FE1 		bx	r3
 1864              	.LVL10:
 1865 008c 080000EA 		b	.L113
 1866              	.L114:
 492:main.c        ****     } else {
 493:main.c        ****       schrittmotor_data.schritt_mode = SCHRITT_VOLL_1;
 1867              		.loc 1 493 38
 1868 0090 E0339FE5 		ldr	r3, .L129+4
 1869 0094 0020A0E3 		mov	r2, #0
 1870 0098 0120C3E5 		strb	r2, [r3, #1]
 494:main.c        ****       schrittmotor_init(schrittmotor_data.schritt_mode);
 1871              		.loc 1 494 7
 1872 009c D4339FE5 		ldr	r3, .L129+4
 1873 00a0 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1874 00a4 0300A0E1 		mov	r0, r3
 1875 00a8 CC339FE5 		ldr	r3, .L129+8
 1876 00ac 0FE0A0E1 		mov	lr, pc
 1877 00b0 13FF2FE1 		bx	r3
 1878              	.LVL11:
 1879              	.L113:
 495:main.c        ****     }
 496:main.c        **** 
 497:main.c        ****   }
 498:main.c        **** 
 499:main.c        ****   if ((button_new.grey == 1) && (schrittmotor_data.button_old.grey == 0)) {
 1880              		.loc 1 499 24
 1881 00b4 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1882 00b8 083003E2 		and	r3, r3, #8
 1883 00bc FF3003E2 		and	r3, r3, #255
 1884              		.loc 1 499 6
 1885 00c0 000053E3 		cmp	r3, #0
 1886 00c4 1300000A 		beq	.L115
 1887              		.loc 1 499 68 discriminator 1
 1888 00c8 A8339FE5 		ldr	r3, .L129+4
 1889 00cc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1890 00d0 083003E2 		and	r3, r3, #8
 1891 00d4 FF3003E2 		and	r3, r3, #255
 1892              		.loc 1 499 30 discriminator 1
 1893 00d8 000053E3 		cmp	r3, #0
 1894 00dc 0D00001A 		bne	.L115
 500:main.c        **** 
 501:main.c        ****     if (schrittmotor_data.position_mode + 1 < POSITION_END) {
 1895              		.loc 1 501 26
 1896 00e0 90339FE5 		ldr	r3, .L129+4
 1897 00e4 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1898              		.loc 1 501 8
 1899 00e8 000053E3 		cmp	r3, #0
 1900 00ec 0600001A 		bne	.L116
 502:main.c        ****       schrittmotor_data.position_mode++;
 1901              		.loc 1 502 24
 1902 00f0 80339FE5 		ldr	r3, .L129+4
 1903 00f4 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1904              		.loc 1 502 38
 1905 00f8 013083E2 		add	r3, r3, #1
 1906 00fc FF2003E2 		and	r2, r3, #255
 1907 0100 70339FE5 		ldr	r3, .L129+4
 1908 0104 0220C3E5 		strb	r2, [r3, #2]
 1909 0108 020000EA 		b	.L115
 1910              	.L116:
 503:main.c        ****     } else {
 504:main.c        ****       schrittmotor_data.position_mode = POSITION_MANUELL;
 1911              		.loc 1 504 39
 1912 010c 64339FE5 		ldr	r3, .L129+4
 1913 0110 0020A0E3 		mov	r2, #0
 1914 0114 0220C3E5 		strb	r2, [r3, #2]
 1915              	.L115:
 505:main.c        ****     }
 506:main.c        ****   }
 507:main.c        **** 
 508:main.c        **** if (schrittmotor_data.position_mode == POSITION_KONTINUIERLICH) {
 1916              		.loc 1 508 22
 1917 0118 58339FE5 		ldr	r3, .L129+4
 1918 011c 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1919              		.loc 1 508 4
 1920 0120 010053E3 		cmp	r3, #1
 1921 0124 7D00001A 		bne	.L117
 509:main.c        ****     if (((button_new.left == 1) && (schrittmotor_data.dir == 1)) && (schrittmotor_data.button_old.l
 1922              		.loc 1 509 27
 1923 0128 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1924 012c 023003E2 		and	r3, r3, #2
 1925 0130 FF3003E2 		and	r3, r3, #255
 1926              		.loc 1 509 8
 1927 0134 000053E3 		cmp	r3, #0
 1928 0138 1F00000A 		beq	.L118
 1929              		.loc 1 509 54 discriminator 1
 1930 013c 34339FE5 		ldr	r3, .L129+4
 1931 0140 223E83E2 		add	r3, r3, #544
 1932 0144 D030D3E1 		ldrsb	r3, [r3]
 1933              		.loc 1 509 33 discriminator 1
 1934 0148 010053E3 		cmp	r3, #1
 1935 014c 1A00001A 		bne	.L118
 1936              		.loc 1 509 104 discriminator 2
 1937 0150 20339FE5 		ldr	r3, .L129+4
 1938 0154 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1939 0158 023003E2 		and	r3, r3, #2
 1940 015c FF3003E2 		and	r3, r3, #255
 1941              		.loc 1 509 66 discriminator 2
 1942 0160 000053E3 		cmp	r3, #0
 1943 0164 1400001A 		bne	.L118
 510:main.c        ****         if (schrittmotor_data.speed > 0) {
 1944              		.loc 1 510 30
 1945 0168 08339FE5 		ldr	r3, .L129+4
 1946 016c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1947              		.loc 1 510 12
 1948 0170 000053E3 		cmp	r3, #0
 1949 0174 0600000A 		beq	.L119
 511:main.c        ****             schrittmotor_data.speed--;
 1950              		.loc 1 511 30
 1951 0178 F8329FE5 		ldr	r3, .L129+4
 1952 017c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1953              		.loc 1 511 36
 1954 0180 013043E2 		sub	r3, r3, #1
 1955 0184 FF2003E2 		and	r2, r3, #255
 1956 0188 E8329FE5 		ldr	r3, .L129+4
 1957 018c 0420C3E5 		strb	r2, [r3, #4]
 1958 0190 090000EA 		b	.L118
 1959              	.L119:
 512:main.c        ****         } else {
 513:main.c        ****             schrittmotor_data.dir = (schrittmotor_data.dir == 1) ? -1 : 1;
 1960              		.loc 1 513 55
 1961 0194 DC329FE5 		ldr	r3, .L129+4
 1962 0198 223E83E2 		add	r3, r3, #544
 1963 019c D030D3E1 		ldrsb	r3, [r3]
 1964              		.loc 1 513 35
 1965 01a0 010053E3 		cmp	r3, #1
 1966 01a4 0100001A 		bne	.L120
 1967              		.loc 1 513 35 is_stmt 0 discriminator 1
 1968 01a8 0020E0E3 		mvn	r2, #0
 1969 01ac 000000EA 		b	.L121
 1970              	.L120:
 1971              		.loc 1 513 35 discriminator 2
 1972 01b0 0120A0E3 		mov	r2, #1
 1973              	.L121:
 1974              		.loc 1 513 35 discriminator 4
 1975 01b4 BC329FE5 		ldr	r3, .L129+4
 1976 01b8 2022C3E5 		strb	r2, [r3, #544]
 1977              	.L118:
 514:main.c        ****         }
 515:main.c        ****     }
 516:main.c        ****     if (((button_new.left == 1) && (schrittmotor_data.dir == -1)) && (schrittmotor_data.button_old.
 1978              		.loc 1 516 27 is_stmt 1
 1979 01bc 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 1980 01c0 023003E2 		and	r3, r3, #2
 1981 01c4 FF3003E2 		and	r3, r3, #255
 1982              		.loc 1 516 8
 1983 01c8 000053E3 		cmp	r3, #0
 1984 01cc 1400000A 		beq	.L122
 1985              		.loc 1 516 54 discriminator 1
 1986 01d0 A0329FE5 		ldr	r3, .L129+4
 1987 01d4 223E83E2 		add	r3, r3, #544
 1988 01d8 D030D3E1 		ldrsb	r3, [r3]
 1989              		.loc 1 516 33 discriminator 1
 1990 01dc 010073E3 		cmn	r3, #1
 1991 01e0 0F00001A 		bne	.L122
 1992              		.loc 1 516 105 discriminator 2
 1993 01e4 8C329FE5 		ldr	r3, .L129+4
 1994 01e8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1995 01ec 023003E2 		and	r3, r3, #2
 1996 01f0 FF3003E2 		and	r3, r3, #255
 1997              		.loc 1 516 67 discriminator 2
 1998 01f4 000053E3 		cmp	r3, #0
 1999 01f8 0900001A 		bne	.L122
 517:main.c        ****         if (schrittmotor_data.speed <4 ) {
 2000              		.loc 1 517 30
 2001 01fc 74329FE5 		ldr	r3, .L129+4
 2002 0200 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2003              		.loc 1 517 12
 2004 0204 030053E3 		cmp	r3, #3
 2005 0208 0500008A 		bhi	.L122
 518:main.c        ****             schrittmotor_data.speed++;
 2006              		.loc 1 518 30
 2007 020c 64329FE5 		ldr	r3, .L129+4
 2008 0210 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2009              		.loc 1 518 36
 2010 0214 013083E2 		add	r3, r3, #1
 2011 0218 FF2003E2 		and	r2, r3, #255
 2012 021c 54329FE5 		ldr	r3, .L129+4
 2013 0220 0420C3E5 		strb	r2, [r3, #4]
 2014              	.L122:
 519:main.c        ****         }
 520:main.c        ****     }
 521:main.c        **** 
 522:main.c        ****     if (((button_new.right == 1) && (schrittmotor_data.dir == 1)) && (schrittmotor_data.button_old.
 2015              		.loc 1 522 28
 2016 0224 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2017 0228 043003E2 		and	r3, r3, #4
 2018 022c FF3003E2 		and	r3, r3, #255
 2019              		.loc 1 522 8
 2020 0230 000053E3 		cmp	r3, #0
 2021 0234 1400000A 		beq	.L123
 2022              		.loc 1 522 55 discriminator 1
 2023 0238 38329FE5 		ldr	r3, .L129+4
 2024 023c 223E83E2 		add	r3, r3, #544
 2025 0240 D030D3E1 		ldrsb	r3, [r3]
 2026              		.loc 1 522 34 discriminator 1
 2027 0244 010053E3 		cmp	r3, #1
 2028 0248 0F00001A 		bne	.L123
 2029              		.loc 1 522 106 discriminator 2
 2030 024c 24329FE5 		ldr	r3, .L129+4
 2031 0250 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2032 0254 043003E2 		and	r3, r3, #4
 2033 0258 FF3003E2 		and	r3, r3, #255
 2034              		.loc 1 522 67 discriminator 2
 2035 025c 000053E3 		cmp	r3, #0
 2036 0260 0900001A 		bne	.L123
 523:main.c        ****         if (schrittmotor_data.speed < 4) {
 2037              		.loc 1 523 30
 2038 0264 0C329FE5 		ldr	r3, .L129+4
 2039 0268 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2040              		.loc 1 523 12
 2041 026c 030053E3 		cmp	r3, #3
 2042 0270 0500008A 		bhi	.L123
 524:main.c        ****             schrittmotor_data.speed++;
 2043              		.loc 1 524 30
 2044 0274 FC319FE5 		ldr	r3, .L129+4
 2045 0278 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2046              		.loc 1 524 36
 2047 027c 013083E2 		add	r3, r3, #1
 2048 0280 FF2003E2 		and	r2, r3, #255
 2049 0284 EC319FE5 		ldr	r3, .L129+4
 2050 0288 0420C3E5 		strb	r2, [r3, #4]
 2051              	.L123:
 525:main.c        ****         }
 526:main.c        ****     }
 527:main.c        ****      if (((button_new.right == 1) && (schrittmotor_data.dir == -1)) && (schrittmotor_data.button_ol
 2052              		.loc 1 527 29
 2053 028c 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2054 0290 043003E2 		and	r3, r3, #4
 2055 0294 FF3003E2 		and	r3, r3, #255
 2056              		.loc 1 527 9
 2057 0298 000053E3 		cmp	r3, #0
 2058 029c 1F00000A 		beq	.L117
 2059              		.loc 1 527 56 discriminator 1
 2060 02a0 D0319FE5 		ldr	r3, .L129+4
 2061 02a4 223E83E2 		add	r3, r3, #544
 2062 02a8 D030D3E1 		ldrsb	r3, [r3]
 2063              		.loc 1 527 35 discriminator 1
 2064 02ac 010073E3 		cmn	r3, #1
 2065 02b0 1A00001A 		bne	.L117
 2066              		.loc 1 527 108 discriminator 2
 2067 02b4 BC319FE5 		ldr	r3, .L129+4
 2068 02b8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2069 02bc 043003E2 		and	r3, r3, #4
 2070 02c0 FF3003E2 		and	r3, r3, #255
 2071              		.loc 1 527 69 discriminator 2
 2072 02c4 000053E3 		cmp	r3, #0
 2073 02c8 1400001A 		bne	.L117
 528:main.c        ****         if (schrittmotor_data.speed > 0) {
 2074              		.loc 1 528 30
 2075 02cc A4319FE5 		ldr	r3, .L129+4
 2076 02d0 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2077              		.loc 1 528 12
 2078 02d4 000053E3 		cmp	r3, #0
 2079 02d8 0600000A 		beq	.L124
 529:main.c        ****             schrittmotor_data.speed--;
 2080              		.loc 1 529 30
 2081 02dc 94319FE5 		ldr	r3, .L129+4
 2082 02e0 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2083              		.loc 1 529 36
 2084 02e4 013043E2 		sub	r3, r3, #1
 2085 02e8 FF2003E2 		and	r2, r3, #255
 2086 02ec 84319FE5 		ldr	r3, .L129+4
 2087 02f0 0420C3E5 		strb	r2, [r3, #4]
 2088 02f4 090000EA 		b	.L117
 2089              	.L124:
 530:main.c        ****         } else {
 531:main.c        ****             schrittmotor_data.dir = (schrittmotor_data.dir == -1) ? 1 : -1;
 2090              		.loc 1 531 55
 2091 02f8 78319FE5 		ldr	r3, .L129+4
 2092 02fc 223E83E2 		add	r3, r3, #544
 2093 0300 D030D3E1 		ldrsb	r3, [r3]
 2094              		.loc 1 531 35
 2095 0304 010073E3 		cmn	r3, #1
 2096 0308 0100001A 		bne	.L125
 2097              		.loc 1 531 35 is_stmt 0 discriminator 1
 2098 030c 0120A0E3 		mov	r2, #1
 2099 0310 000000EA 		b	.L126
 2100              	.L125:
 2101              		.loc 1 531 35 discriminator 2
 2102 0314 0020E0E3 		mvn	r2, #0
 2103              	.L126:
 2104              		.loc 1 531 35 discriminator 4
 2105 0318 58319FE5 		ldr	r3, .L129+4
 2106 031c 2022C3E5 		strb	r2, [r3, #544]
 2107              	.L117:
 532:main.c        ****         }
 533:main.c        ****     }
 534:main.c        **** }
 535:main.c        **** 
 536:main.c        ****   if (schrittmotor_data.position_mode == POSITION_MANUELL) {
 2108              		.loc 1 536 24 is_stmt 1
 2109 0320 50319FE5 		ldr	r3, .L129+4
 2110 0324 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2111              		.loc 1 536 6
 2112 0328 000053E3 		cmp	r3, #0
 2113 032c 2700001A 		bne	.L127
 537:main.c        **** 
 538:main.c        ****     if ((button_new.left == 1) && (schrittmotor_data.button_old.left == 0)) {
 2114              		.loc 1 538 26
 2115 0330 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2116 0334 023003E2 		and	r3, r3, #2
 2117 0338 FF3003E2 		and	r3, r3, #255
 2118              		.loc 1 538 8
 2119 033c 000053E3 		cmp	r3, #0
 2120 0340 0E00000A 		beq	.L128
 2121              		.loc 1 538 70 discriminator 1
 2122 0344 2C319FE5 		ldr	r3, .L129+4
 2123 0348 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2124 034c 023003E2 		and	r3, r3, #2
 2125 0350 FF3003E2 		and	r3, r3, #255
 2126              		.loc 1 538 32 discriminator 1
 2127 0354 000053E3 		cmp	r3, #0
 2128 0358 0800001A 		bne	.L128
 539:main.c        ****       schrittmotor_data.pos--;
 2129              		.loc 1 539 24
 2130 035c 14319FE5 		ldr	r3, .L129+4
 2131 0360 D330D3E1 		ldrsb	r3, [r3, #3]
 2132              		.loc 1 539 28
 2133 0364 FF3003E2 		and	r3, r3, #255
 2134 0368 013043E2 		sub	r3, r3, #1
 2135 036c FF3003E2 		and	r3, r3, #255
 2136 0370 033CA0E1 		lsl	r3, r3, #24
 2137 0374 432CA0E1 		asr	r2, r3, #24
 2138 0378 F8309FE5 		ldr	r3, .L129+4
 2139 037c 0320C3E5 		strb	r2, [r3, #3]
 2140              	.L128:
 540:main.c        ****     }
 541:main.c        ****     if ((button_new.right == 1) && (schrittmotor_data.button_old.right == 0)) {
 2141              		.loc 1 541 27
 2142 0380 08305BE5 		ldrb	r3, [fp, #-8]	@ zero_extendqisi2
 2143 0384 043003E2 		and	r3, r3, #4
 2144 0388 FF3003E2 		and	r3, r3, #255
 2145              		.loc 1 541 8
 2146 038c 000053E3 		cmp	r3, #0
 2147 0390 0E00000A 		beq	.L127
 2148              		.loc 1 541 72 discriminator 1
 2149 0394 DC309FE5 		ldr	r3, .L129+4
 2150 0398 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2151 039c 043003E2 		and	r3, r3, #4
 2152 03a0 FF3003E2 		and	r3, r3, #255
 2153              		.loc 1 541 33 discriminator 1
 2154 03a4 000053E3 		cmp	r3, #0
 2155 03a8 0800001A 		bne	.L127
 542:main.c        ****       schrittmotor_data.pos++;
 2156              		.loc 1 542 24
 2157 03ac C4309FE5 		ldr	r3, .L129+4
 2158 03b0 D330D3E1 		ldrsb	r3, [r3, #3]
 2159              		.loc 1 542 28
 2160 03b4 FF3003E2 		and	r3, r3, #255
 2161 03b8 013083E2 		add	r3, r3, #1
 2162 03bc FF3003E2 		and	r3, r3, #255
 2163 03c0 033CA0E1 		lsl	r3, r3, #24
 2164 03c4 432CA0E1 		asr	r2, r3, #24
 2165 03c8 A8309FE5 		ldr	r3, .L129+4
 2166 03cc 0320C3E5 		strb	r2, [r3, #3]
 2167              	.L127:
 543:main.c        ****     }
 544:main.c        ****   }
 545:main.c        **** 
 546:main.c        ****   // Bei Änderung des Modes: schrittmotor_init() aufrufen (Hilfreiche für später
 547:main.c        ****   // folgende Ergänzung)
 548:main.c        **** 
 549:main.c        ****   // Beispielanwendung für Display
 550:main.c        ****   static uint32_t count = 0;
 551:main.c        ****   display_goto_xy(0, 1);
 2168              		.loc 1 551 3
 2169 03d0 0110A0E3 		mov	r1, #1
 2170 03d4 0000A0E3 		mov	r0, #0
 2171 03d8 A0309FE5 		ldr	r3, .L129+12
 2172 03dc 0FE0A0E1 		mov	lr, pc
 2173 03e0 13FF2FE1 		bx	r3
 2174              	.LVL12:
 552:main.c        ****   display_unsigned(++count, 4);
 2175              		.loc 1 552 3
 2176 03e4 98309FE5 		ldr	r3, .L129+16
 2177 03e8 003093E5 		ldr	r3, [r3]
 2178 03ec 013083E2 		add	r3, r3, #1
 2179 03f0 8C209FE5 		ldr	r2, .L129+16
 2180 03f4 003082E5 		str	r3, [r2]
 2181 03f8 84309FE5 		ldr	r3, .L129+16
 2182 03fc 003093E5 		ldr	r3, [r3]
 2183 0400 0410A0E3 		mov	r1, #4
 2184 0404 0300A0E1 		mov	r0, r3
 2185 0408 78309FE5 		ldr	r3, .L129+20
 2186 040c 0FE0A0E1 		mov	lr, pc
 2187 0410 13FF2FE1 		bx	r3
 2188              	.LVL13:
 553:main.c        ****   display_goto_xy(0, 2);
 2189              		.loc 1 553 3
 2190 0414 0210A0E3 		mov	r1, #2
 2191 0418 0000A0E3 		mov	r0, #0
 2192 041c 5C309FE5 		ldr	r3, .L129+12
 2193 0420 0FE0A0E1 		mov	lr, pc
 2194 0424 13FF2FE1 		bx	r3
 2195              	.LVL14:
 554:main.c        ****   display_string(schritt_mode2str[schrittmotor_data.schritt_mode]);
 2196              		.loc 1 554 52
 2197 0428 48309FE5 		ldr	r3, .L129+4
 2198 042c 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2199 0430 0320A0E1 		mov	r2, r3
 2200              		.loc 1 554 3
 2201 0434 50309FE5 		ldr	r3, .L129+24
 2202 0438 023193E7 		ldr	r3, [r3, r2, lsl #2]
 2203 043c 0300A0E1 		mov	r0, r3
 2204 0440 48309FE5 		ldr	r3, .L129+28
 2205 0444 0FE0A0E1 		mov	lr, pc
 2206 0448 13FF2FE1 		bx	r3
 2207              	.LVL15:
 555:main.c        ****   display_update();
 2208              		.loc 1 555 3
 2209 044c 40309FE5 		ldr	r3, .L129+32
 2210 0450 0FE0A0E1 		mov	lr, pc
 2211 0454 13FF2FE1 		bx	r3
 2212              	.LVL16:
 556:main.c        **** 
 557:main.c        ****   schrittmotor_data.button_old = button_new;
 2213              		.loc 1 557 32
 2214 0458 18209FE5 		ldr	r2, .L129+4
 2215 045c 08305BE5 		ldrb	r3, [fp, #-8]
 2216 0460 0030C2E5 		strb	r3, [r2]
 558:main.c        **** }
 2217              		.loc 1 558 1
 2218 0464 0000A0E1 		nop
 2219 0468 04D04BE2 		sub	sp, fp, #4
 2220              		.cfi_def_cfa 13, 8
 2221              		@ sp needed
 2222 046c 0048BDE8 		pop	{fp, lr}
 2223              		.cfi_restore 14
 2224              		.cfi_restore 11
 2225              		.cfi_def_cfa_offset 0
 2226 0470 1EFF2FE1 		bx	lr
 2227              	.L130:
 2228              		.align	2
 2229              	.L129:
 2230 0474 00000000 		.word	nxt_avr_get_buttons
 2231 0478 00000000 		.word	schrittmotor_data
 2232 047c 00000000 		.word	schrittmotor_init
 2233 0480 00000000 		.word	display_goto_xy
 2234 0484 28030000 		.word	count.2
 2235 0488 00000000 		.word	display_unsigned
 2236 048c 00000000 		.word	schritt_mode2str
 2237 0490 00000000 		.word	display_string
 2238 0494 00000000 		.word	display_update
 2239              		.cfi_endproc
 2240              	.LFE21:
 2242              		.section	.text.task_4ms,"ax",%progbits
 2243              		.align	2
 2244              		.global	task_4ms
 2245              		.syntax unified
 2246              		.arm
 2248              	task_4ms:
 2249              	.LFB22:
 559:main.c        **** 
 560:main.c        **** /*****************************************************************************/
 561:main.c        **** /*   Hilfsroutinen                                                           */
 562:main.c        **** /*****************************************************************************/
 563:main.c        **** 
 564:main.c        **** void task_4ms(void) {
 2250              		.loc 1 564 21
 2251              		.cfi_startproc
 2252              		@ Function supports interworking.
 2253              		@ args = 0, pretend = 0, frame = 0
 2254              		@ frame_needed = 1, uses_anonymous_args = 0
 2255 0000 00482DE9 		push	{fp, lr}
 2256              		.cfi_def_cfa_offset 8
 2257              		.cfi_offset 11, -8
 2258              		.cfi_offset 14, -4
 2259 0004 04B08DE2 		add	fp, sp, #4
 2260              		.cfi_def_cfa 11, 4
 565:main.c        ****     schrittmotor_data.current_reload = schrittmotor_data.reload_table[schrittmotor_data.speed];
 2261              		.loc 1 565 88
 2262 0008 DC309FE5 		ldr	r3, .L135
 2263 000c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2264              		.loc 1 565 70
 2265 0010 D4209FE5 		ldr	r2, .L135
 2266 0014 043083E2 		add	r3, r3, #4
 2267 0018 8330A0E1 		lsl	r3, r3, #1
 2268 001c 033082E0 		add	r3, r2, r3
 2269 0020 063083E2 		add	r3, r3, #6
 2270 0024 B030D3E1 		ldrh	r3, [r3]
 2271              		.loc 1 565 38
 2272 0028 BC209FE5 		ldr	r2, .L135
 2273 002c B831C2E1 		strh	r3, [r2, #24]	@ movhi
 566:main.c        **** 
 567:main.c        ****     if (schrittmotor_data.position_mode == POSITION_KONTINUIERLICH) {
 2274              		.loc 1 567 26
 2275 0030 B4309FE5 		ldr	r3, .L135
 2276 0034 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2277              		.loc 1 567 8
 2278 0038 010053E3 		cmp	r3, #1
 2279 003c 2000001A 		bne	.L132
 568:main.c        ****         schrittmotor_data.counter++;
 2280              		.loc 1 568 26
 2281 0040 A4309FE5 		ldr	r3, .L135
 2282 0044 BA31D3E1 		ldrh	r3, [r3, #26]
 2283              		.loc 1 568 34
 2284 0048 013083E2 		add	r3, r3, #1
 2285 004c 0338A0E1 		lsl	r3, r3, #16
 2286 0050 2338A0E1 		lsr	r3, r3, #16
 2287 0054 90209FE5 		ldr	r2, .L135
 2288 0058 BA31C2E1 		strh	r3, [r2, #26]	@ movhi
 569:main.c        ****         if (schrittmotor_data.counter >= schrittmotor_data.current_reload) {
 2289              		.loc 1 569 30
 2290 005c 88309FE5 		ldr	r3, .L135
 2291 0060 BA21D3E1 		ldrh	r2, [r3, #26]
 2292              		.loc 1 569 59
 2293 0064 80309FE5 		ldr	r3, .L135
 2294 0068 B831D3E1 		ldrh	r3, [r3, #24]
 2295              		.loc 1 569 12
 2296 006c 030052E1 		cmp	r2, r3
 2297 0070 1900003A 		bcc	.L134
 570:main.c        ****             schrittmotor_data.counter = 0;
 2298              		.loc 1 570 39
 2299 0074 70309FE5 		ldr	r3, .L135
 2300 0078 0020A0E3 		mov	r2, #0
 2301 007c BA21C3E1 		strh	r2, [r3, #26]	@ movhi
 571:main.c        ****             /* move according to dir flag: +1 forward, -1 backward */
 572:main.c        ****             schrittmotor_data.pos += (int32_t)schrittmotor_data.dir;
 2302              		.loc 1 572 30
 2303 0080 64309FE5 		ldr	r3, .L135
 2304 0084 D330D3E1 		ldrsb	r3, [r3, #3]
 2305 0088 FF2003E2 		and	r2, r3, #255
 2306              		.loc 1 572 64
 2307 008c 58309FE5 		ldr	r3, .L135
 2308 0090 223E83E2 		add	r3, r3, #544
 2309 0094 D030D3E1 		ldrsb	r3, [r3]
 2310 0098 FF3003E2 		and	r3, r3, #255
 2311              		.loc 1 572 35
 2312 009c 033082E0 		add	r3, r2, r3
 2313 00a0 FF3003E2 		and	r3, r3, #255
 2314 00a4 033CA0E1 		lsl	r3, r3, #24
 2315 00a8 432CA0E1 		asr	r2, r3, #24
 2316 00ac 38309FE5 		ldr	r3, .L135
 2317 00b0 0320C3E5 		strb	r2, [r3, #3]
 573:main.c        ****             schrittmotor_process();
 2318              		.loc 1 573 13
 2319 00b4 34309FE5 		ldr	r3, .L135+4
 2320 00b8 0FE0A0E1 		mov	lr, pc
 2321 00bc 13FF2FE1 		bx	r3
 2322              	.LVL17:
 574:main.c        ****         }
 575:main.c        ****     } else {
 576:main.c        ****         schrittmotor_process();
 577:main.c        ****         schrittmotor_data.counter = 0;
 578:main.c        ****     }
 579:main.c        **** }
 2323              		.loc 1 579 1
 2324 00c0 050000EA 		b	.L134
 2325              	.L132:
 576:main.c        ****         schrittmotor_data.counter = 0;
 2326              		.loc 1 576 9
 2327 00c4 24309FE5 		ldr	r3, .L135+4
 2328 00c8 0FE0A0E1 		mov	lr, pc
 2329 00cc 13FF2FE1 		bx	r3
 2330              	.LVL18:
 577:main.c        ****     }
 2331              		.loc 1 577 35
 2332 00d0 14309FE5 		ldr	r3, .L135
 2333 00d4 0020A0E3 		mov	r2, #0
 2334 00d8 BA21C3E1 		strh	r2, [r3, #26]	@ movhi
 2335              	.L134:
 2336              		.loc 1 579 1
 2337 00dc 0000A0E1 		nop
 2338 00e0 04D04BE2 		sub	sp, fp, #4
 2339              		.cfi_def_cfa 13, 8
 2340              		@ sp needed
 2341 00e4 0048BDE8 		pop	{fp, lr}
 2342              		.cfi_restore 14
 2343              		.cfi_restore 11
 2344              		.cfi_def_cfa_offset 0
 2345 00e8 1EFF2FE1 		bx	lr
 2346              	.L136:
 2347              		.align	2
 2348              	.L135:
 2349 00ec 00000000 		.word	schrittmotor_data
 2350 00f0 00000000 		.word	schrittmotor_process
 2351              		.cfi_endproc
 2352              	.LFE22:
 2354              		.section	.text.task_8ms,"ax",%progbits
 2355              		.align	2
 2356              		.global	task_8ms
 2357              		.syntax unified
 2358              		.arm
 2360              	task_8ms:
 2361              	.LFB23:
 580:main.c        **** 
 581:main.c        **** void task_8ms(void) {
 2362              		.loc 1 581 21
 2363              		.cfi_startproc
 2364              		@ Function supports interworking.
 2365              		@ args = 0, pretend = 0, frame = 0
 2366              		@ frame_needed = 1, uses_anonymous_args = 0
 2367              		@ link register save eliminated.
 2368 0000 04B02DE5 		str	fp, [sp, #-4]!
 2369              		.cfi_def_cfa_offset 4
 2370              		.cfi_offset 11, -4
 2371 0004 00B08DE2 		add	fp, sp, #0
 2372              		.cfi_def_cfa_register 11
 582:main.c        ****   // Keine blockierende Aufrufe
 583:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 584:main.c        **** }
 2373              		.loc 1 584 1
 2374 0008 0000A0E1 		nop
 2375 000c 00D08BE2 		add	sp, fp, #0
 2376              		.cfi_def_cfa_register 13
 2377              		@ sp needed
 2378 0010 04B09DE4 		ldr	fp, [sp], #4
 2379              		.cfi_restore 11
 2380              		.cfi_def_cfa_offset 0
 2381 0014 1EFF2FE1 		bx	lr
 2382              		.cfi_endproc
 2383              	.LFE23:
 2385              		.section	.text.task_16ms,"ax",%progbits
 2386              		.align	2
 2387              		.global	task_16ms
 2388              		.syntax unified
 2389              		.arm
 2391              	task_16ms:
 2392              	.LFB24:
 585:main.c        **** 
 586:main.c        **** void task_16ms(void) {
 2393              		.loc 1 586 22
 2394              		.cfi_startproc
 2395              		@ Function supports interworking.
 2396              		@ args = 0, pretend = 0, frame = 0
 2397              		@ frame_needed = 1, uses_anonymous_args = 0
 2398              		@ link register save eliminated.
 2399 0000 04B02DE5 		str	fp, [sp, #-4]!
 2400              		.cfi_def_cfa_offset 4
 2401              		.cfi_offset 11, -4
 2402 0004 00B08DE2 		add	fp, sp, #0
 2403              		.cfi_def_cfa_register 11
 587:main.c        ****   // Keine blockierende Aufrufe
 588:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 589:main.c        **** }
 2404              		.loc 1 589 1
 2405 0008 0000A0E1 		nop
 2406 000c 00D08BE2 		add	sp, fp, #0
 2407              		.cfi_def_cfa_register 13
 2408              		@ sp needed
 2409 0010 04B09DE4 		ldr	fp, [sp], #4
 2410              		.cfi_restore 11
 2411              		.cfi_def_cfa_offset 0
 2412 0014 1EFF2FE1 		bx	lr
 2413              		.cfi_endproc
 2414              	.LFE24:
 2416              		.section	.text.task_32ms,"ax",%progbits
 2417              		.align	2
 2418              		.global	task_32ms
 2419              		.syntax unified
 2420              		.arm
 2422              	task_32ms:
 2423              	.LFB25:
 590:main.c        **** 
 591:main.c        **** void task_32ms(void) {
 2424              		.loc 1 591 22
 2425              		.cfi_startproc
 2426              		@ Function supports interworking.
 2427              		@ args = 0, pretend = 0, frame = 0
 2428              		@ frame_needed = 1, uses_anonymous_args = 0
 2429              		@ link register save eliminated.
 2430 0000 04B02DE5 		str	fp, [sp, #-4]!
 2431              		.cfi_def_cfa_offset 4
 2432              		.cfi_offset 11, -4
 2433 0004 00B08DE2 		add	fp, sp, #0
 2434              		.cfi_def_cfa_register 11
 592:main.c        ****   // Keine blockierende Aufrufe
 593:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 594:main.c        **** }
 2435              		.loc 1 594 1
 2436 0008 0000A0E1 		nop
 2437 000c 00D08BE2 		add	sp, fp, #0
 2438              		.cfi_def_cfa_register 13
 2439              		@ sp needed
 2440 0010 04B09DE4 		ldr	fp, [sp], #4
 2441              		.cfi_restore 11
 2442              		.cfi_def_cfa_offset 0
 2443 0014 1EFF2FE1 		bx	lr
 2444              		.cfi_endproc
 2445              	.LFE25:
 2447              		.section	.text.task_64ms,"ax",%progbits
 2448              		.align	2
 2449              		.global	task_64ms
 2450              		.syntax unified
 2451              		.arm
 2453              	task_64ms:
 2454              	.LFB26:
 595:main.c        **** 
 596:main.c        **** void task_64ms(void) {
 2455              		.loc 1 596 22
 2456              		.cfi_startproc
 2457              		@ Function supports interworking.
 2458              		@ args = 0, pretend = 0, frame = 0
 2459              		@ frame_needed = 1, uses_anonymous_args = 0
 2460 0000 00482DE9 		push	{fp, lr}
 2461              		.cfi_def_cfa_offset 8
 2462              		.cfi_offset 11, -8
 2463              		.cfi_offset 14, -4
 2464 0004 04B08DE2 		add	fp, sp, #4
 2465              		.cfi_def_cfa 11, 4
 597:main.c        ****   // Keine blockierende Aufrufe
 598:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 599:main.c        ****   ui_process();
 2466              		.loc 1 599 3
 2467 0008 14309FE5 		ldr	r3, .L141
 2468 000c 0FE0A0E1 		mov	lr, pc
 2469 0010 13FF2FE1 		bx	r3
 2470              	.LVL19:
 600:main.c        **** }
 2471              		.loc 1 600 1
 2472 0014 0000A0E1 		nop
 2473 0018 04D04BE2 		sub	sp, fp, #4
 2474              		.cfi_def_cfa 13, 8
 2475              		@ sp needed
 2476 001c 0048BDE8 		pop	{fp, lr}
 2477              		.cfi_restore 14
 2478              		.cfi_restore 11
 2479              		.cfi_def_cfa_offset 0
 2480 0020 1EFF2FE1 		bx	lr
 2481              	.L142:
 2482              		.align	2
 2483              	.L141:
 2484 0024 00000000 		.word	ui_process
 2485              		.cfi_endproc
 2486              	.LFE26:
 2488              		.section	.text.task_128ms,"ax",%progbits
 2489              		.align	2
 2490              		.global	task_128ms
 2491              		.syntax unified
 2492              		.arm
 2494              	task_128ms:
 2495              	.LFB27:
 601:main.c        **** 
 602:main.c        **** void task_128ms(void) {
 2496              		.loc 1 602 23
 2497              		.cfi_startproc
 2498              		@ Function supports interworking.
 2499              		@ args = 0, pretend = 0, frame = 0
 2500              		@ frame_needed = 1, uses_anonymous_args = 0
 2501              		@ link register save eliminated.
 2502 0000 04B02DE5 		str	fp, [sp, #-4]!
 2503              		.cfi_def_cfa_offset 4
 2504              		.cfi_offset 11, -4
 2505 0004 00B08DE2 		add	fp, sp, #0
 2506              		.cfi_def_cfa_register 11
 603:main.c        ****   // Keine blockierende Aufrufe
 604:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 605:main.c        **** }
 2507              		.loc 1 605 1
 2508 0008 0000A0E1 		nop
 2509 000c 00D08BE2 		add	sp, fp, #0
 2510              		.cfi_def_cfa_register 13
 2511              		@ sp needed
 2512 0010 04B09DE4 		ldr	fp, [sp], #4
 2513              		.cfi_restore 11
 2514              		.cfi_def_cfa_offset 0
 2515 0014 1EFF2FE1 		bx	lr
 2516              		.cfi_endproc
 2517              	.LFE27:
 2519              		.section	.text.task_256ms,"ax",%progbits
 2520              		.align	2
 2521              		.global	task_256ms
 2522              		.syntax unified
 2523              		.arm
 2525              	task_256ms:
 2526              	.LFB28:
 606:main.c        **** 
 607:main.c        **** void task_256ms(void) {
 2527              		.loc 1 607 23
 2528              		.cfi_startproc
 2529              		@ Function supports interworking.
 2530              		@ args = 0, pretend = 0, frame = 0
 2531              		@ frame_needed = 1, uses_anonymous_args = 0
 2532              		@ link register save eliminated.
 2533 0000 04B02DE5 		str	fp, [sp, #-4]!
 2534              		.cfi_def_cfa_offset 4
 2535              		.cfi_offset 11, -4
 2536 0004 00B08DE2 		add	fp, sp, #0
 2537              		.cfi_def_cfa_register 11
 608:main.c        ****   // Keine blockierende Aufrufe
 609:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 610:main.c        **** }
 2538              		.loc 1 610 1
 2539 0008 0000A0E1 		nop
 2540 000c 00D08BE2 		add	sp, fp, #0
 2541              		.cfi_def_cfa_register 13
 2542              		@ sp needed
 2543 0010 04B09DE4 		ldr	fp, [sp], #4
 2544              		.cfi_restore 11
 2545              		.cfi_def_cfa_offset 0
 2546 0014 1EFF2FE1 		bx	lr
 2547              		.cfi_endproc
 2548              	.LFE28:
 2550              		.section	.text.task_512ms,"ax",%progbits
 2551              		.align	2
 2552              		.global	task_512ms
 2553              		.syntax unified
 2554              		.arm
 2556              	task_512ms:
 2557              	.LFB29:
 611:main.c        **** 
 612:main.c        **** void task_512ms(void) {
 2558              		.loc 1 612 23
 2559              		.cfi_startproc
 2560              		@ Function supports interworking.
 2561              		@ args = 0, pretend = 0, frame = 0
 2562              		@ frame_needed = 1, uses_anonymous_args = 0
 2563              		@ link register save eliminated.
 2564 0000 04B02DE5 		str	fp, [sp, #-4]!
 2565              		.cfi_def_cfa_offset 4
 2566              		.cfi_offset 11, -4
 2567 0004 00B08DE2 		add	fp, sp, #0
 2568              		.cfi_def_cfa_register 11
 613:main.c        ****   // Keine blockierende Aufrufe
 614:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 615:main.c        **** }
 2569              		.loc 1 615 1
 2570 0008 0000A0E1 		nop
 2571 000c 00D08BE2 		add	sp, fp, #0
 2572              		.cfi_def_cfa_register 13
 2573              		@ sp needed
 2574 0010 04B09DE4 		ldr	fp, [sp], #4
 2575              		.cfi_restore 11
 2576              		.cfi_def_cfa_offset 0
 2577 0014 1EFF2FE1 		bx	lr
 2578              		.cfi_endproc
 2579              	.LFE29:
 2581              		.section	.text.task_1024ms,"ax",%progbits
 2582              		.align	2
 2583              		.global	task_1024ms
 2584              		.syntax unified
 2585              		.arm
 2587              	task_1024ms:
 2588              	.LFB30:
 616:main.c        **** 
 617:main.c        **** void task_1024ms(void) {
 2589              		.loc 1 617 24
 2590              		.cfi_startproc
 2591              		@ Function supports interworking.
 2592              		@ args = 0, pretend = 0, frame = 0
 2593              		@ frame_needed = 1, uses_anonymous_args = 0
 2594              		@ link register save eliminated.
 2595 0000 04B02DE5 		str	fp, [sp, #-4]!
 2596              		.cfi_def_cfa_offset 4
 2597              		.cfi_offset 11, -4
 2598 0004 00B08DE2 		add	fp, sp, #0
 2599              		.cfi_def_cfa_register 11
 618:main.c        ****   // Keine blockierende Aufrufe
 619:main.c        ****   // Max. Bearbeitungsdauer: ZYKLUS_MS
 620:main.c        **** }
 2600              		.loc 1 620 1
 2601 0008 0000A0E1 		nop
 2602 000c 00D08BE2 		add	sp, fp, #0
 2603              		.cfi_def_cfa_register 13
 2604              		@ sp needed
 2605 0010 04B09DE4 		ldr	fp, [sp], #4
 2606              		.cfi_restore 11
 2607              		.cfi_def_cfa_offset 0
 2608 0014 1EFF2FE1 		bx	lr
 2609              		.cfi_endproc
 2610              	.LFE30:
 2612              		.section	.text.task_idle,"ax",%progbits
 2613              		.align	2
 2614              		.global	task_idle
 2615              		.syntax unified
 2616              		.arm
 2618              	task_idle:
 2619              	.LFB31:
 621:main.c        **** 
 622:main.c        **** void task_idle(void) {
 2620              		.loc 1 622 22
 2621              		.cfi_startproc
 2622              		@ Function supports interworking.
 2623              		@ args = 0, pretend = 0, frame = 0
 2624              		@ frame_needed = 1, uses_anonymous_args = 0
 2625              		@ link register save eliminated.
 2626 0000 04B02DE5 		str	fp, [sp, #-4]!
 2627              		.cfi_def_cfa_offset 4
 2628              		.cfi_offset 11, -4
 2629 0004 00B08DE2 		add	fp, sp, #0
 2630              		.cfi_def_cfa_register 11
 623:main.c        ****   // Keine blockierende Aufrufe
 624:main.c        ****   // Max. Bearbeitungsdauer: IDLE_MS
 625:main.c        **** }
 2631              		.loc 1 625 1
 2632 0008 0000A0E1 		nop
 2633 000c 00D08BE2 		add	sp, fp, #0
 2634              		.cfi_def_cfa_register 13
 2635              		@ sp needed
 2636 0010 04B09DE4 		ldr	fp, [sp], #4
 2637              		.cfi_restore 11
 2638              		.cfi_def_cfa_offset 0
 2639 0014 1EFF2FE1 		bx	lr
 2640              		.cfi_endproc
 2641              	.LFE31:
 2643              		.section	.text.premain_init,"ax",%progbits
 2644              		.align	2
 2645              		.global	premain_init
 2646              		.syntax unified
 2647              		.arm
 2649              	premain_init:
 2650              	.LFB32:
 626:main.c        **** 
 627:main.c        **** /*****************************************************************************/
 628:main.c        **** /*    Pre-Main-Funktion                                                      */
 629:main.c        **** /*****************************************************************************/
 630:main.c        **** // Zur Vermeidung von malloc(1024) bei der ersten Ausgabe über stdout!
 631:main.c        **** //__attribute__(constructor) stellt sicher, dass premain_init() direkt nach
 632:main.c        **** //__sinit() aufgerufen wird (beides innerhalb von __libc_init_array())
 633:main.c        **** void __attribute__((constructor)) premain_init(void) {
 2651              		.loc 1 633 54
 2652              		.cfi_startproc
 2653              		@ Function supports interworking.
 2654              		@ args = 0, pretend = 0, frame = 0
 2655              		@ frame_needed = 1, uses_anonymous_args = 0
 2656 0000 30482DE9 		push	{r4, r5, fp, lr}
 2657              		.cfi_def_cfa_offset 16
 2658              		.cfi_offset 4, -16
 2659              		.cfi_offset 5, -12
 2660              		.cfi_offset 11, -8
 2661              		.cfi_offset 14, -4
 2662 0004 0CB08DE2 		add	fp, sp, #12
 2663              		.cfi_def_cfa 11, 4
 634:main.c        **** #if 0
 635:main.c        **** 	//No linebuffering, call stdio_write() immediately
 636:main.c        **** 	//-> Langsam, da mit jedem Zeichen __sflush_r()/_write()/stdio_write() aufgerufen wird 
 637:main.c        **** 	setvbuf(stdout,NULL,_IONBF,0);
 638:main.c        **** #else
 639:main.c        ****   static char linebuf[10];
 640:main.c        ****   // LineBuffering into global Varialbe (guter Kompromiss)
 641:main.c        ****   setvbuf(stdout, linebuf, _IOLBF, sizeof(linebuf)); // Linebuffering in
 2664              		.loc 1 641 11
 2665 0008 2C309FE5 		ldr	r3, .L149
 2666 000c 003093E5 		ldr	r3, [r3]
 2667 0010 080093E5 		ldr	r0, [r3, #8]
 2668              		.loc 1 641 3
 2669 0014 0A30A0E3 		mov	r3, #10
 2670 0018 0120A0E3 		mov	r2, #1
 2671 001c 1C109FE5 		ldr	r1, .L149+4
 2672 0020 1C409FE5 		ldr	r4, .L149+8
 2673 0024 0FE0A0E1 		mov	lr, pc
 2674 0028 14FF2FE1 		bx	r4
 2675              	.LVL20:
 642:main.c        **** #endif
 643:main.c        **** }
 2676              		.loc 1 643 1
 2677 002c 0000A0E1 		nop
 2678 0030 0CD04BE2 		sub	sp, fp, #12
 2679              		.cfi_def_cfa 13, 16
 2680              		@ sp needed
 2681 0034 3048BDE8 		pop	{r4, r5, fp, lr}
 2682              		.cfi_restore 14
 2683              		.cfi_restore 11
 2684              		.cfi_restore 5
 2685              		.cfi_restore 4
 2686              		.cfi_def_cfa_offset 0
 2687 0038 1EFF2FE1 		bx	lr
 2688              	.L150:
 2689              		.align	2
 2690              	.L149:
 2691 003c 00000000 		.word	_impure_ptr
 2692 0040 2C030000 		.word	linebuf.1
 2693 0044 00000000 		.word	setvbuf
 2694              		.cfi_endproc
 2695              	.LFE32:
 2697              		.section	.init_array,"aw",%init_array
 2698              		.align	2
 2699 0000 00000000 		.word	premain_init(target1)
 2700              		.section	.rodata
 2701              		.align	2
 2702              	.LC9:
 2703 009c 68616C6C 		.ascii	"hallo\012\015\000"
 2703      6F0A0D00 
 2704              		.align	2
 2705              	.LC10:
 2706 00a4 1B5B324A 		.ascii	"\033[2J\033[H\033[0m\000"
 2706      1B5B481B 
 2706      5B306D00 
 2707              		.align	2
 2708              	.LC11:
 2709 00b0 50726F67 		.ascii	"Prog: demo\012\015Version von: Oct 27 2025 14:38:26"
 2709      3A206465 
 2709      6D6F0A0D 
 2709      56657273 
 2709      696F6E20 
 2710 00dd 0A0D00   		.ascii	"\012\015\000"
 2711              		.align	2
 2712              	.LC12:
 2713 00e0 27762E76 		.ascii	"'v.view %e schrittmotor_data' zur Variablendarstell"
 2713      69657720 
 2713      25652073 
 2713      63687269 
 2713      74746D6F 
 2714 0113 756E670A 		.ascii	"ung\012\015\000"
 2714      0D00
 2715 0119 000000   		.align	2
 2716              	.LC13:
 2717 011c 5669656C 		.ascii	"Viel Erfolg!\012\015\000"
 2717      20457266 
 2717      6F6C6721 
 2717      0A0D00
 2718 012b 00       		.align	2
 2719              	.LC14:
 2720 012c 00       		.ascii	"\000"
 2721 012d 000000   		.align	2
 2722              	.LC15:
 2723 0130 346D7300 		.ascii	"4ms\000"
 2724              		.align	2
 2725              	.LC16:
 2726 0134 386D7300 		.ascii	"8ms\000"
 2727              		.align	2
 2728              	.LC17:
 2729 0138 31366D73 		.ascii	"16ms\000"
 2729      00
 2730 013d 000000   		.align	2
 2731              	.LC18:
 2732 0140 33326D73 		.ascii	"32ms\000"
 2732      00
 2733 0145 000000   		.align	2
 2734              	.LC19:
 2735 0148 36346D73 		.ascii	"64ms\000"
 2735      00
 2736 014d 000000   		.align	2
 2737              	.LC20:
 2738 0150 3132386D 		.ascii	"128ms\000"
 2738      7300
 2739 0156 0000     		.align	2
 2740              	.LC21:
 2741 0158 3235366D 		.ascii	"256ms\000"
 2741      7300
 2742 015e 0000     		.align	2
 2743              	.LC22:
 2744 0160 3531326D 		.ascii	"512ms\000"
 2744      7300
 2745 0166 0000     		.align	2
 2746              	.LC23:
 2747 0168 49646C65 		.ascii	"Idle\000"
 2747      00
 2748 016d 000000   		.align	2
 2749              	.LC24:
 2750 0170 1B5B3331 		.ascii	"\033[31mTiming durch '\000"
 2750      6D54696D 
 2750      696E6720 
 2750      64757263 
 2750      68202700 
 2751              		.align	2
 2752              	.LC25:
 2753 0184 27207665 		.ascii	"' verletzt\012\015\033[39m\000"
 2753      726C6574 
 2753      7A740A0D 
 2753      1B5B3339 
 2753      6D00
 2754 0196 0000     		.align	2
 2755              	.LC26:
 2756 0198 1B5B3331 		.ascii	"\033[31mStack overflow durch '\000"
 2756      6D537461 
 2756      636B206F 
 2756      76657266 
 2756      6C6F7720 
 2757              		.align	2
 2758              	.LC27:
 2759 01b4 270A0D1B 		.ascii	"'\012\015\033[39m\000"
 2759      5B33396D 
 2759      00
 2760 01bd 000000   		.align	2
 2761              	.LC28:
 2762 01c0 1B5B3331 		.ascii	"\033[31m\012\015Low Battery\012\015\033[39m\000"
 2762      6D0A0D4C 
 2762      6F772042 
 2762      61747465 
 2762      72790A0D 
 2763 01da 0000     		.align	2
 2764              	.LC29:
 2765 01dc 1B5B3331 		.ascii	"\033[31m\012\015Terminal Overflow\012\015\033[39m\000"
 2765      6D0A0D54 
 2765      65726D69 
 2765      6E616C20 
 2765      4F766572 
 2766              		.section	.text.main,"ax",%progbits
 2767              		.align	2
 2768              		.global	main
 2769              		.syntax unified
 2770              		.arm
 2772              	main:
 2773              	.LFB33:
 644:main.c        **** /*****************************************************************************/
 645:main.c        **** /*    Main-Funktion                                                          */
 646:main.c        **** /*****************************************************************************/
 647:main.c        **** #if 0
 648:main.c        **** //Variante 1: Deklaration der main() Funktion
 649:main.c        **** //da es keine CLI gibt, über welcher die Anwendung getartet wird
 650:main.c        **** //sondern der start über startup.s erfolgt, macht dies kein Sinn
 651:main.c        **** //und belegt unnötige Speicherplatz auf den Stack
 652:main.c        **** int main(int argc, char *argv[]) 
 653:main.c        **** {
 654:main.c        **** 	(void) argc;
 655:main.c        **** 	(void) argv;
 656:main.c        **** #else
 657:main.c        **** // Variante 2: Deklaration der main() funktion
 658:main.c        **** int main(void) {
 2774              		.loc 1 658 16
 2775              		.cfi_startproc
 2776              		@ Function supports interworking.
 2777              		@ args = 0, pretend = 0, frame = 24
 2778              		@ frame_needed = 1, uses_anonymous_args = 0
 2779 0000 00482DE9 		push	{fp, lr}
 2780              		.cfi_def_cfa_offset 8
 2781              		.cfi_offset 11, -8
 2782              		.cfi_offset 14, -4
 2783 0004 04B08DE2 		add	fp, sp, #4
 2784              		.cfi_def_cfa 11, 4
 2785 0008 18D04DE2 		sub	sp, sp, #24
 659:main.c        **** #endif
 660:main.c        ****   /* Interrupts zu diesem Zeitpunkt disabled !!!! */
 661:main.c        **** 
 662:main.c        ****   /* 'Pflicht' Initialisierung, können nicht ausgelassen werden */
 663:main.c        ****   aic_init();          // Interrupt-Controller initialisieren
 2786              		.loc 1 663 3
 2787 000c E4359FE5 		ldr	r3, .L180
 2788 0010 0FE0A0E1 		mov	lr, pc
 2789 0014 13FF2FE1 		bx	r3
 2790              	.LVL21:
 664:main.c        ****   systick_init();      // System-Timer initialisieren
 2791              		.loc 1 664 3
 2792 0018 DC359FE5 		ldr	r3, .L180+4
 2793 001c 0FE0A0E1 		mov	lr, pc
 2794 0020 13FF2FE1 		bx	r3
 2795              	.LVL22:
 665:main.c        ****   interrupts_enable(); // Ohne Worte
 2796              		.loc 1 665 3
 2797 0024 D4359FE5 		ldr	r3, .L180+8
 2798 0028 0FE0A0E1 		mov	lr, pc
 2799 002c 13FF2FE1 		bx	r3
 2800              	.LVL23:
 666:main.c        ****   nxt_avr_init(8);
 2801              		.loc 1 666 3
 2802 0030 0800A0E3 		mov	r0, #8
 2803 0034 C8359FE5 		ldr	r3, .L180+12
 2804 0038 0FE0A0E1 		mov	lr, pc
 2805 003c 13FF2FE1 		bx	r3
 2806              	.LVL24:
 667:main.c        **** #if defined(MODE_RAM) || defined(MODE_SIM)
 668:main.c        ****   udmon3_init(); // Speicherzugriff durch den Debugger
 2807              		.loc 1 668 3
 2808 0040 C0359FE5 		ldr	r3, .L180+16
 2809 0044 0FE0A0E1 		mov	lr, pc
 2810 0048 13FF2FE1 		bx	r3
 2811              	.LVL25:
 669:main.c        ****                  // zur Programmlaufzeit mittels der
 670:main.c        ****                  // DCC Schnittstelle ermöglichen
 671:main.c        **** #endif
 672:main.c        **** 
 673:main.c        ****   /* 'Wahl' Initialisierung, hängt von den benötigten Komponenten ab */
 674:main.c        ****   term_init();
 2812              		.loc 1 674 3
 2813 004c B8359FE5 		ldr	r3, .L180+20
 2814 0050 0FE0A0E1 		mov	lr, pc
 2815 0054 13FF2FE1 		bx	r3
 2816              	.LVL26:
 675:main.c        ****   display_init();
 2817              		.loc 1 675 3
 2818 0058 B0359FE5 		ldr	r3, .L180+24
 2819 005c 0FE0A0E1 		mov	lr, pc
 2820 0060 13FF2FE1 		bx	r3
 2821              	.LVL27:
 676:main.c        **** 
 677:main.c        ****   ui_init();
 2822              		.loc 1 677 3
 2823 0064 A8359FE5 		ldr	r3, .L180+28
 2824 0068 0FE0A0E1 		mov	lr, pc
 2825 006c 13FF2FE1 		bx	r3
 2826              	.LVL28:
 678:main.c        ****   schrittmotor_init(schrittmotor_data.schritt_mode);
 2827              		.loc 1 678 3
 2828 0070 A0359FE5 		ldr	r3, .L180+32
 2829 0074 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2830 0078 0300A0E1 		mov	r0, r3
 2831 007c 98359FE5 		ldr	r3, .L180+36
 2832 0080 0FE0A0E1 		mov	lr, pc
 2833 0084 13FF2FE1 		bx	r3
 2834              	.LVL29:
 679:main.c        **** 
 680:main.c        ****   display_clear(0);
 2835              		.loc 1 680 3
 2836 0088 0000A0E3 		mov	r0, #0
 2837 008c 8C359FE5 		ldr	r3, .L180+40
 2838 0090 0FE0A0E1 		mov	lr, pc
 2839 0094 13FF2FE1 		bx	r3
 2840              	.LVL30:
 681:main.c        ****   display_update();
 2841              		.loc 1 681 3
 2842 0098 84359FE5 		ldr	r3, .L180+44
 2843 009c 0FE0A0E1 		mov	lr, pc
 2844 00a0 13FF2FE1 		bx	r3
 2845              	.LVL31:
 682:main.c        **** 
 683:main.c        ****   // ANSI Escape sequences - VT100 / VT52 (see main.h)
 684:main.c        ****   (void)term_string("hallo\n\r", ASYNCSYNC_BLOCK);
 2846              		.loc 1 684 9
 2847 00a4 0110A0E3 		mov	r1, #1
 2848 00a8 78059FE5 		ldr	r0, .L180+48
 2849 00ac 78359FE5 		ldr	r3, .L180+52
 2850 00b0 0FE0A0E1 		mov	lr, pc
 2851 00b4 13FF2FE1 		bx	r3
 2852              	.LVL32:
 685:main.c        ****   (void)term_string(
 2853              		.loc 1 685 9
 2854 00b8 0110A0E3 		mov	r1, #1
 2855 00bc 6C059FE5 		ldr	r0, .L180+56
 2856 00c0 64359FE5 		ldr	r3, .L180+52
 2857 00c4 0FE0A0E1 		mov	lr, pc
 2858 00c8 13FF2FE1 		bx	r3
 2859              	.LVL33:
 686:main.c        ****       "\033[2J" VT100_CURSORHOME // Move Cursor to home position (0,0)
 687:main.c        ****           VT100_DEFAULT,
 688:main.c        ****       ASYNCSYNC_BLOCK);
 689:main.c        ****   (void)term_string("Prog: " APP_NAME "\n\rVersion von: " __DATE__ " " __TIME__
 2860              		.loc 1 689 9
 2861 00cc 0110A0E3 		mov	r1, #1
 2862 00d0 5C059FE5 		ldr	r0, .L180+60
 2863 00d4 50359FE5 		ldr	r3, .L180+52
 2864 00d8 0FE0A0E1 		mov	lr, pc
 2865 00dc 13FF2FE1 		bx	r3
 2866              	.LVL34:
 690:main.c        ****                     "\n\r",
 691:main.c        ****                     ASYNCSYNC_BLOCK);
 692:main.c        ****   (void)term_string(
 2867              		.loc 1 692 9
 2868 00e0 0110A0E3 		mov	r1, #1
 2869 00e4 4C059FE5 		ldr	r0, .L180+64
 2870 00e8 3C359FE5 		ldr	r3, .L180+52
 2871 00ec 0FE0A0E1 		mov	lr, pc
 2872 00f0 13FF2FE1 		bx	r3
 2873              	.LVL35:
 693:main.c        ****       "'v.view %e schrittmotor_data' zur Variablendarstellung\n\r",
 694:main.c        ****       ASYNCSYNC_BLOCK);
 695:main.c        ****   (void)term_string("Viel Erfolg!\n\r", ASYNCSYNC_BLOCK);
 2874              		.loc 1 695 9
 2875 00f4 0110A0E3 		mov	r1, #1
 2876 00f8 3C059FE5 		ldr	r0, .L180+68
 2877 00fc 28359FE5 		ldr	r3, .L180+52
 2878 0100 0FE0A0E1 		mov	lr, pc
 2879 0104 13FF2FE1 		bx	r3
 2880              	.LVL36:
 696:main.c        **** 
 697:main.c        ****   // Alternativ zu term_xxx() kann auch printf() oder noch besser iprintf
 698:main.c        ****   // genutzt werden beide bedingen jedoch einen großen Speicherbedarf!
 699:main.c        ****   // Alternativ zu term_read() kann auch scanf() genutzt werden. Auch diese
 700:main.c        ****   // Funktion
 701:main.c        ****   //  bedingt einen großen Speicherbedarf
 702:main.c        **** 
 703:main.c        **** #ifndef MODE_ROM
 704:main.c        ****   /* Watchdog Disable */
 705:main.c        ****   /* Mode-Register kann nur einmal beschrieben werden */
 706:main.c        ****   AT91C_BASE_WDTC->WDTC_WDMR = 0xFFF | AT91C_WDTC_WDDIS | /*WD Disable */
 2881              		.loc 1 706 18
 2882 0108 30359FE5 		ldr	r3, .L180+72
 2883              		.loc 1 706 30
 2884 010c 30259FE5 		ldr	r2, .L180+76
 2885 0110 042083E5 		str	r2, [r3, #4]
 2886              	.LBB8:
 2887              	.LBB9:
 2888              		.file 4 "lib/../main.h"
   1:lib/../main.h **** #ifndef main_h
   2:lib/../main.h **** #define main_h
   3:lib/../main.h **** #include <stdint.h>
   4:lib/../main.h **** 
   5:lib/../main.h **** //ASCII-Zeichen
   6:lib/../main.h **** //\a The “alert” character, Ctrl-g, ASCII code 7 (BEL). (This usually makes some sort of audibl
   7:lib/../main.h **** //\b Backspace, Ctrl-h, ASCII code 8 (BS).
   8:lib/../main.h **** //\f Formfeed, Ctrl-l, ASCII code 12 (FF).
   9:lib/../main.h **** //\n Newline, Ctrl-j, ASCII code 10 (LF).
  10:lib/../main.h **** //\r Carriage return, Ctrl-m, ASCII code 13 (CR).
  11:lib/../main.h **** //\t Horizontal TAB, Ctrl-i, ASCII code 9 (HT).
  12:lib/../main.h **** //\v Vertical tab, Ctrl-k, ASCII code 11 (VT).
  13:lib/../main.h **** //\nnn The octal value nnn, where nnn stands for 1 to 3 digits between ‘0’ and ‘7’. For exa
  14:lib/../main.h **** //\xhh...The hexadecimal value hh, where hh stands for a sequence of hexadecimal digits (‘0’–
  15:lib/../main.h **** //       Like the same construct in ISO C, the escape sequence continues until 
  16:lib/../main.h **** //       the first nonhexadecimal digit is seen. (c.e.) However, using more 
  17:lib/../main.h **** //       than two hexadecimal digits produces undefined results. 
  18:lib/../main.h **** //       (The ‘\x’ escape sequence is not allowed in POSIX awk.)
  19:lib/../main.h **** //\/ A literal slash (necessary for regexp constants only). This sequence 
  20:lib/../main.h **** //       is used when you want to write a regexp constant that contains a 
  21:lib/../main.h **** //       slash. Because the regexp is delimited by slashes, you need to 
  22:lib/../main.h **** //       escape the slash that is part of the pattern, in order to tell 
  23:lib/../main.h **** //       awk to keep processing the rest of the regexp.
  24:lib/../main.h **** //\"  A literal double quote (necessary for string constants only). 
  25:lib/../main.h **** //       This sequence is used when you want to write a string constant 
  26:lib/../main.h **** //       that contains a double quote. Because the string is delimited by 
  27:lib/../main.h **** //       double quotes, you need to escape the quote that is part of 
  28:lib/../main.h **** //       the string, in order to tell awk to keep processing the rest
  29:lib/../main.h **** //       of the string.#define ANSI_BLACK   30
  30:lib/../main.h **** 
  31:lib/../main.h **** //https://www-user.tu-chemnitz.de/~heha/hsn/terminal/terminal.htm
  32:lib/../main.h **** //https://gist.github.com/ConnerWill/d4b6c776b509add763e17f9f113fd25b
  33:lib/../main.h **** //Cursor Control
  34:lib/../main.h **** #define VT100_CURSORHOME      "\e[H"
  35:lib/../main.h **** #define VT100_CLEARSCREEN     "\e[2J"
  36:lib/../main.h **** #define VT100_GOTOYX          "\e[%d;%dH"
  37:lib/../main.h **** #define VT100_SAVEPOS         "\e7"
  38:lib/../main.h **** #define VT100_RESTOREPOS      "\e8"
  39:lib/../main.h **** #define VT100_ROLLY1Y2        "\e[%d;%dr"
  40:lib/../main.h **** #define VT100_ROLLOFF         "\e[r"
  41:lib/../main.h **** //Erase Functions
  42:lib/../main.h **** #define VT100_ERASEFROMCURSOR "\e[0J"
  43:lib/../main.h **** #define VT100_ERASETOCURSOR   "\e[1J"
  44:lib/../main.h **** #define VT100_ERASESCREEN     "\e[2J"
  45:lib/../main.h **** #define VT100_DEL_UNTILEOL    "\e[K"
  46:lib/../main.h **** #define VT100_DEL_TOCUR       "\e[1K"
  47:lib/../main.h **** #define VT100_DEL_LINE        "\e[2K"
  48:lib/../main.h **** //Color/Graphics Mode
  49:lib/../main.h **** #define VT100_DEFAULT         "\e[0m"  //stellt hellgraue Schrift auf schwarzem Grund ein
  50:lib/../main.h **** #define VT100_FETT              "\e[1m"
  51:lib/../main.h **** #define VT100_FETT_AUS          "\e[22m"
  52:lib/../main.h **** #define VT100_UNTERSTRICHEN     "\e[4m"
  53:lib/../main.h **** #define VT100_UNTERSTRICHEN_AUS "\e[24m"
  54:lib/../main.h **** #define VT100_BLINKEN           "\e[5m"
  55:lib/../main.h **** #define VT100_BLINKEN_AUS       "\e[25m"
  56:lib/../main.h **** #define VT100_INVERS            "\e[7m"
  57:lib/../main.h **** #define VT100_INVERS_AUS        "\e[27m"
  58:lib/../main.h **** #define VT100_UNSICHTBAR        "\e[8m"
  59:lib/../main.h **** #define VT100_SICHTBAR          "\e[28m"
  60:lib/../main.h **** #define VT100_VORDERGRUND_SCHWARZ "\e[30m"
  61:lib/../main.h **** #define VT100_VORDERGRUND_ROT     "\e[31m"
  62:lib/../main.h **** #define VT100_VORDERGRUND_GRUEN   "\e[32m"
  63:lib/../main.h **** #define VT100_VORDERGRUND_BRAUN   "\e[33m"
  64:lib/../main.h **** #define VT100_VORDERGRUND_BLAU    "\e[34m"
  65:lib/../main.h **** #define VT100_VORDERGRUND_BLAUROT "\e[35m"
  66:lib/../main.h **** #define VT100_VORDERGRUND_ZYAN    "\e[36m"
  67:lib/../main.h **** #define VT100_VORDERGRUND_WEISS   "\e[37m"  //Default
  68:lib/../main.h **** #define VT100_VORDERGRUND_DEFAULT "\e[39m"  //Nicht VT100
  69:lib/../main.h **** #define VT100_HINTERGRUND_SCHWARZ "\e[40m"  //Default
  70:lib/../main.h **** #define VT100_HINTERGRUND_ROT     "\e[41m"  
  71:lib/../main.h **** #define VT100_HINTERGRUND_GRUEN   "\e[42m"  
  72:lib/../main.h **** #define VT100_HINTERGRUND_BRAUN   "\e[43m"  
  73:lib/../main.h **** #define VT100_HINTERGRUND_BLAU    "\e[44m"  
  74:lib/../main.h **** #define VT100_HINTERGRUND_BLAUROT "\e[45m"  
  75:lib/../main.h **** #define VT100_HINTERGRUND_ZYAN    "\e[46m"  
  76:lib/../main.h **** #define VT100_HINTERGRUND_WEISS   "\e[47m"  
  77:lib/../main.h **** #define VT100_HINTERGRUND_DEFAULT "\e[49m"
  78:lib/../main.h **** 
  79:lib/../main.h ****                                                          /* Main Clock [Hz] */
  80:lib/../main.h **** #define MAINCK            18432000
  81:lib/../main.h ****                                      /* Maseter Clock (PLLRC div by 2) [Hz] */
  82:lib/../main.h **** #define MCK               47923200
  83:lib/../main.h ****                                              /* System clock tick rate [Hz] */
  84:lib/../main.h **** #define BSP_TICKS_PER_SEC 1000
  85:lib/../main.h **** 
  86:lib/../main.h **** //#define NODISCARD __attribute__((warn_unused_result))  
  87:lib/../main.h **** #define NODISCARD  [[nodiscard]]
  88:lib/../main.h **** 
  89:lib/../main.h **** typedef enum __attribute__((packed)) {ASYNCSYNC_NONBLOCK,ASYNCSYNC_BLOCK,ASYNCSYNC_ASYNCGET} asyncs
  90:lib/../main.h **** 
  91:lib/../main.h **** typedef enum {SENSOR_1,SENSOR_2,SENSOR_3,SENSOR_4,SENSOR_MAX} sensor_t;
  92:lib/../main.h **** 
  93:lib/../main.h **** typedef enum {MOTOR_A,MOTOR_B,MOTOR_C} motor_t;
  94:lib/../main.h **** 
  95:lib/../main.h **** typedef enum {MOTOR_BREAK, MOTOR_FLOAT} motor_zustand_t;
  96:lib/../main.h **** 
  97:lib/../main.h **** typedef enum {SENSOR_OFF=0x00, SENSOR_9V_PULSED=0x01, SENSOR_9V=0x10 } sensor_power_t;
  98:lib/../main.h **** 
  99:lib/../main.h **** typedef enum {BATTERY_AA, BATTERY_ACCU} battery_t;
 100:lib/../main.h **** 
 101:lib/../main.h **** typedef struct {
 102:lib/../main.h **** 	uint8_t orange : 1;
 103:lib/../main.h **** 	uint8_t left : 1;
 104:lib/../main.h **** 	uint8_t right : 1;
 105:lib/../main.h **** 	uint8_t grey : 1;
 106:lib/../main.h **** 	uint8_t reserved : 4;
 107:lib/../main.h **** } button_t;
 108:lib/../main.h **** 
 109:lib/../main.h **** #define I2C_BAUDRATE 10000  //Orignal 9600
 110:lib/../main.h **** 
 111:lib/../main.h **** extern uint32_t __stack_start__[];   //Definiert in link.ld
 112:lib/../main.h **** extern uint32_t __stack_end__;       //Definiert in link.ld
 113:lib/../main.h **** #define STACK_FILL 0x11111111
 114:lib/../main.h **** 
 115:lib/../main.h **** static __inline__ void stack_fill(void) __attribute__((always_inline));
 116:lib/../main.h **** static __inline__ void stack_fill(void)
 117:lib/../main.h **** {
 118:lib/../main.h **** 	         uint32_t *ptr;
 119:lib/../main.h **** 	register uint32_t *sp asm("r13");
 120:lib/../main.h **** 	for(ptr=&__stack_start__[0];ptr<sp;ptr++)
 2889              		.loc 4 120 9
 2890 0114 2C359FE5 		ldr	r3, .L180+80
 2891 0118 14300BE5 		str	r3, [fp, #-20]
 2892              		.loc 4 120 2
 2893 011c 050000EA 		b	.L152
 2894              	.L153:
 121:lib/../main.h **** 		*ptr=STACK_FILL;
 2895              		.loc 4 121 7
 2896 0120 14301BE5 		ldr	r3, [fp, #-20]
 2897 0124 20259FE5 		ldr	r2, .L180+84
 2898 0128 002083E5 		str	r2, [r3]
 120:lib/../main.h **** 		*ptr=STACK_FILL;
 2899              		.loc 4 120 40 discriminator 3
 2900 012c 14301BE5 		ldr	r3, [fp, #-20]
 2901 0130 043083E2 		add	r3, r3, #4
 2902 0134 14300BE5 		str	r3, [fp, #-20]
 2903              	.L152:
 120:lib/../main.h **** 		*ptr=STACK_FILL;
 2904              		.loc 4 120 33 discriminator 1
 2905 0138 0D20A0E1 		mov	r2, sp
 2906 013c 14301BE5 		ldr	r3, [fp, #-20]
 2907 0140 020053E1 		cmp	r3, r2
 2908 0144 F5FFFF3A 		bcc	.L153
 122:lib/../main.h **** }
 2909              		.loc 4 122 1
 2910 0148 0000A0E1 		nop
 2911              	.L154:
 2912              	.LBE9:
 2913              	.LBE8:
 707:main.c        ****                                AT91C_WDTC_WDDBGHLT |      /*Debug Halt */
 708:main.c        ****                                AT91C_WDTC_WDIDLEHLT;      /*Idle Halt  */
 709:main.c        **** #else
 710:main.c        **** #if 0
 711:main.c        **** 	/* Watchdog Enable */
 712:main.c        **** 	/* Da in dieser Version kein zyklischer Reset des Watchdogs */
 713:main.c        **** 	/* vorhanden ist, wird von einem Watchdog Enable abgesehen  */
 714:main.c        **** 	/* Mit Reset wird der Wachdog aktiviert!                    */
 715:main.c        **** #else
 716:main.c        **** /* Watchdog Disable */
 717:main.c        **** /* Mode-Register kann nur einmal beschrieben werden */
 718:main.c        **** AT91C_BASE_WDTC->WDTC_WDMR = 0xFFF | AT91C_WDTC_WDDIS | /*WD Disable */
 719:main.c        ****                              AT91C_WDTC_WDDBGHLT |      /*Debug Halt */
 720:main.c        ****                              AT91C_WDTC_WDIDLEHLT;      /*Idle Halt  */
 721:main.c        **** #endif
 722:main.c        **** #endif
 723:main.c        ****   // Vorangegangenen Stackaufbau 'löschen'
 724:main.c        ****   stack_fill();
 725:main.c        ****   // Label, so das mit 'go start' hierin gesprungen werden kann
 726:main.c        **** start:
 727:main.c        ****   __attribute__((unused));
 728:main.c        ****   uint32_t start_tick = systick_get_ms();
 2914              		.loc 1 728 25
 2915 014c FC349FE5 		ldr	r3, .L180+88
 2916 0150 0FE0A0E1 		mov	lr, pc
 2917 0154 13FF2FE1 		bx	r3
 2918              	.LVL37:
 2919 0158 08000BE5 		str	r0, [fp, #-8]
 729:main.c        ****   uint32_t zeitscheibe = 0;
 2920              		.loc 1 729 12
 2921 015c 0030A0E3 		mov	r3, #0
 2922 0160 0C300BE5 		str	r3, [fp, #-12]
 730:main.c        ****   char *task_aktiv = "";
 2923              		.loc 1 730 9
 2924 0164 E8349FE5 		ldr	r3, .L180+92
 2925 0168 10300BE5 		str	r3, [fp, #-16]
 2926              	.L179:
 731:main.c        ****   while (1) {
 732:main.c        ****     // Warten bis zum nächsten TimeSlot
 733:main.c        ****     while ((int)(start_tick - systick_get_ms()) > 0)
 2927              		.loc 1 733 11
 2928 016c 0000A0E1 		nop
 2929              	.L155:
 2930              		.loc 1 733 31 discriminator 1
 2931 0170 D8349FE5 		ldr	r3, .L180+88
 2932 0174 0FE0A0E1 		mov	lr, pc
 2933 0178 13FF2FE1 		bx	r3
 2934              	.LVL38:
 2935 017c 0020A0E1 		mov	r2, r0
 2936              		.loc 1 733 29 discriminator 1
 2937 0180 08301BE5 		ldr	r3, [fp, #-8]
 2938 0184 023043E0 		sub	r3, r3, r2
 2939              		.loc 1 733 49 discriminator 1
 2940 0188 000053E3 		cmp	r3, #0
 2941 018c F7FFFFCA 		bgt	.L155
 734:main.c        ****       ;
 735:main.c        ****     start_tick += ZYKLUS_MS;
 2942              		.loc 1 735 16
 2943 0190 08301BE5 		ldr	r3, [fp, #-8]
 2944 0194 023083E2 		add	r3, r3, #2
 2945 0198 08300BE5 		str	r3, [fp, #-8]
 2946              	.L156:
 736:main.c        ****     // Label, so das mit 'go zyklus' hierhin gesprungen werden kann
 737:main.c        ****   zyklus:
 738:main.c        ****     __attribute__((unused)) if ((zeitscheibe & 0b000000001) == 0b000000001) {
 2947              		.loc 1 738 46
 2948 019c 0C301BE5 		ldr	r3, [fp, #-12]
 2949 01a0 013003E2 		and	r3, r3, #1
 2950              		.loc 1 738 32
 2951 01a4 000053E3 		cmp	r3, #0
 2952 01a8 0500000A 		beq	.L157
 739:main.c        ****       task_aktiv = "4ms";
 2953              		.loc 1 739 18
 2954 01ac A4349FE5 		ldr	r3, .L180+96
 2955 01b0 10300BE5 		str	r3, [fp, #-16]
 740:main.c        ****       task_4ms();
 2956              		.loc 1 740 7
 2957 01b4 A0349FE5 		ldr	r3, .L180+100
 2958 01b8 0FE0A0E1 		mov	lr, pc
 2959 01bc 13FF2FE1 		bx	r3
 2960              	.LVL39:
 2961 01c0 440000EA 		b	.L158
 2962              	.L157:
 741:main.c        ****     }
 742:main.c        ****     else if ((zeitscheibe & 0b000000011) == 0b000000010) {
 2963              		.loc 1 742 27
 2964 01c4 0C301BE5 		ldr	r3, [fp, #-12]
 2965 01c8 033003E2 		and	r3, r3, #3
 2966              		.loc 1 742 13
 2967 01cc 020053E3 		cmp	r3, #2
 2968 01d0 0500001A 		bne	.L159
 743:main.c        ****       task_aktiv = "8ms";
 2969              		.loc 1 743 18
 2970 01d4 84349FE5 		ldr	r3, .L180+104
 2971 01d8 10300BE5 		str	r3, [fp, #-16]
 744:main.c        ****       task_8ms();
 2972              		.loc 1 744 7
 2973 01dc 80349FE5 		ldr	r3, .L180+108
 2974 01e0 0FE0A0E1 		mov	lr, pc
 2975 01e4 13FF2FE1 		bx	r3
 2976              	.LVL40:
 2977 01e8 3A0000EA 		b	.L158
 2978              	.L159:
 745:main.c        ****     }
 746:main.c        ****     else if ((zeitscheibe & 0b000000111) == 0b000000100) {
 2979              		.loc 1 746 27
 2980 01ec 0C301BE5 		ldr	r3, [fp, #-12]
 2981 01f0 073003E2 		and	r3, r3, #7
 2982              		.loc 1 746 13
 2983 01f4 040053E3 		cmp	r3, #4
 2984 01f8 0500001A 		bne	.L160
 747:main.c        ****       task_aktiv = "16ms";
 2985              		.loc 1 747 18
 2986 01fc 64349FE5 		ldr	r3, .L180+112
 2987 0200 10300BE5 		str	r3, [fp, #-16]
 748:main.c        ****       task_16ms();
 2988              		.loc 1 748 7
 2989 0204 60349FE5 		ldr	r3, .L180+116
 2990 0208 0FE0A0E1 		mov	lr, pc
 2991 020c 13FF2FE1 		bx	r3
 2992              	.LVL41:
 2993 0210 300000EA 		b	.L158
 2994              	.L160:
 749:main.c        ****     }
 750:main.c        ****     else if ((zeitscheibe & 0b000001111) == 0b000001000) {
 2995              		.loc 1 750 27
 2996 0214 0C301BE5 		ldr	r3, [fp, #-12]
 2997 0218 0F3003E2 		and	r3, r3, #15
 2998              		.loc 1 750 13
 2999 021c 080053E3 		cmp	r3, #8
 3000 0220 0500001A 		bne	.L161
 751:main.c        ****       task_aktiv = "32ms";
 3001              		.loc 1 751 18
 3002 0224 44349FE5 		ldr	r3, .L180+120
 3003 0228 10300BE5 		str	r3, [fp, #-16]
 752:main.c        ****       task_32ms();
 3004              		.loc 1 752 7
 3005 022c 40349FE5 		ldr	r3, .L180+124
 3006 0230 0FE0A0E1 		mov	lr, pc
 3007 0234 13FF2FE1 		bx	r3
 3008              	.LVL42:
 3009 0238 260000EA 		b	.L158
 3010              	.L161:
 753:main.c        ****     }
 754:main.c        ****     else if ((zeitscheibe & 0b000011111) == 0b000010000) {
 3011              		.loc 1 754 27
 3012 023c 0C301BE5 		ldr	r3, [fp, #-12]
 3013 0240 1F3003E2 		and	r3, r3, #31
 3014              		.loc 1 754 13
 3015 0244 100053E3 		cmp	r3, #16
 3016 0248 0500001A 		bne	.L162
 755:main.c        ****       task_aktiv = "64ms";
 3017              		.loc 1 755 18
 3018 024c 24349FE5 		ldr	r3, .L180+128
 3019 0250 10300BE5 		str	r3, [fp, #-16]
 756:main.c        ****       task_64ms();
 3020              		.loc 1 756 7
 3021 0254 20349FE5 		ldr	r3, .L180+132
 3022 0258 0FE0A0E1 		mov	lr, pc
 3023 025c 13FF2FE1 		bx	r3
 3024              	.LVL43:
 3025 0260 1C0000EA 		b	.L158
 3026              	.L162:
 757:main.c        ****     }
 758:main.c        ****     else if ((zeitscheibe & 0b000111111) == 0b000100000) {
 3027              		.loc 1 758 27
 3028 0264 0C301BE5 		ldr	r3, [fp, #-12]
 3029 0268 3F3003E2 		and	r3, r3, #63
 3030              		.loc 1 758 13
 3031 026c 200053E3 		cmp	r3, #32
 3032 0270 0500001A 		bne	.L163
 759:main.c        ****       task_aktiv = "128ms";
 3033              		.loc 1 759 18
 3034 0274 04349FE5 		ldr	r3, .L180+136
 3035 0278 10300BE5 		str	r3, [fp, #-16]
 760:main.c        ****       task_128ms();
 3036              		.loc 1 760 7
 3037 027c 00349FE5 		ldr	r3, .L180+140
 3038 0280 0FE0A0E1 		mov	lr, pc
 3039 0284 13FF2FE1 		bx	r3
 3040              	.LVL44:
 3041 0288 120000EA 		b	.L158
 3042              	.L163:
 761:main.c        ****     }
 762:main.c        ****     else if ((zeitscheibe & 0b001111111) == 0b001000000) {
 3043              		.loc 1 762 27
 3044 028c 0C301BE5 		ldr	r3, [fp, #-12]
 3045 0290 7F3003E2 		and	r3, r3, #127
 3046              		.loc 1 762 13
 3047 0294 400053E3 		cmp	r3, #64
 3048 0298 0500001A 		bne	.L164
 763:main.c        ****       task_aktiv = "256ms";
 3049              		.loc 1 763 18
 3050 029c E4339FE5 		ldr	r3, .L180+144
 3051 02a0 10300BE5 		str	r3, [fp, #-16]
 764:main.c        ****       task_256ms();
 3052              		.loc 1 764 7
 3053 02a4 E0339FE5 		ldr	r3, .L180+148
 3054 02a8 0FE0A0E1 		mov	lr, pc
 3055 02ac 13FF2FE1 		bx	r3
 3056              	.LVL45:
 3057 02b0 080000EA 		b	.L158
 3058              	.L164:
 765:main.c        ****     }
 766:main.c        ****     else if ((zeitscheibe & 0b011111111) == 0b010000000) {
 3059              		.loc 1 766 27
 3060 02b4 0C301BE5 		ldr	r3, [fp, #-12]
 3061 02b8 FF3003E2 		and	r3, r3, #255
 3062              		.loc 1 766 13
 3063 02bc 800053E3 		cmp	r3, #128
 3064 02c0 0400001A 		bne	.L158
 767:main.c        ****       task_aktiv = "512ms";
 3065              		.loc 1 767 18
 3066 02c4 C4339FE5 		ldr	r3, .L180+152
 3067 02c8 10300BE5 		str	r3, [fp, #-16]
 768:main.c        ****       task_512ms();
 3068              		.loc 1 768 7
 3069 02cc C0339FE5 		ldr	r3, .L180+156
 3070 02d0 0FE0A0E1 		mov	lr, pc
 3071 02d4 13FF2FE1 		bx	r3
 3072              	.LVL46:
 3073              	.L158:
 769:main.c        ****     }
 770:main.c        ****     // Zeit für IDLE-Task verfügbar
 771:main.c        ****     if ((int)(start_tick - systick_get_ms()) >= IDLE_MS) {
 3074              		.loc 1 771 28
 3075 02d8 70339FE5 		ldr	r3, .L180+88
 3076 02dc 0FE0A0E1 		mov	lr, pc
 3077 02e0 13FF2FE1 		bx	r3
 3078              	.LVL47:
 3079 02e4 0020A0E1 		mov	r2, r0
 3080              		.loc 1 771 26 discriminator 1
 3081 02e8 08301BE5 		ldr	r3, [fp, #-8]
 3082 02ec 023043E0 		sub	r3, r3, r2
 3083              		.loc 1 771 8 discriminator 1
 3084 02f0 000053E3 		cmp	r3, #0
 3085 02f4 040000DA 		ble	.L165
 772:main.c        ****       task_aktiv = "Idle";
 3086              		.loc 1 772 18
 3087 02f8 98339FE5 		ldr	r3, .L180+160
 3088 02fc 10300BE5 		str	r3, [fp, #-16]
 773:main.c        ****       task_idle();
 3089              		.loc 1 773 7
 3090 0300 94339FE5 		ldr	r3, .L180+164
 3091 0304 0FE0A0E1 		mov	lr, pc
 3092 0308 13FF2FE1 		bx	r3
 3093              	.LVL48:
 3094              	.L165:
 774:main.c        ****     }
 775:main.c        ****     // Max. Zeitdauer einer Zeitscheibe überschritten?
 776:main.c        ****     if ((int)(start_tick - systick_get_ms()) <= 0) {
 3095              		.loc 1 776 28
 3096 030c 3C339FE5 		ldr	r3, .L180+88
 3097 0310 0FE0A0E1 		mov	lr, pc
 3098 0314 13FF2FE1 		bx	r3
 3099              	.LVL49:
 3100 0318 0020A0E1 		mov	r2, r0
 3101              		.loc 1 776 26 discriminator 1
 3102 031c 08301BE5 		ldr	r3, [fp, #-8]
 3103 0320 023043E0 		sub	r3, r3, r2
 3104              		.loc 1 776 8 discriminator 1
 3105 0324 000053E3 		cmp	r3, #0
 3106 0328 2C0000CA 		bgt	.L166
 777:main.c        ****       main_data.term_status |= term_string(
 3107              		.loc 1 777 32
 3108 032c 0010A0E3 		mov	r1, #0
 3109 0330 68039FE5 		ldr	r0, .L180+168
 3110 0334 F0329FE5 		ldr	r3, .L180+52
 3111 0338 0FE0A0E1 		mov	lr, pc
 3112 033c 13FF2FE1 		bx	r3
 3113              	.LVL50:
 3114 0340 0030A0E1 		mov	r3, r0
 3115              		.loc 1 777 16 discriminator 1
 3116 0344 58239FE5 		ldr	r2, .L180+172
 3117 0348 D020D2E1 		ldrsb	r2, [r2]
 3118              		.loc 1 777 29 discriminator 1
 3119 034c 033CA0E1 		lsl	r3, r3, #24
 3120 0350 433CA0E1 		asr	r3, r3, #24
 3121 0354 033082E1 		orr	r3, r2, r3
 3122 0358 033CA0E1 		lsl	r3, r3, #24
 3123 035c 432CA0E1 		asr	r2, r3, #24
 3124 0360 3C339FE5 		ldr	r3, .L180+172
 3125 0364 0020C3E5 		strb	r2, [r3]
 778:main.c        ****           VT100_VORDERGRUND_ROT "Timing durch '", ASYNCSYNC_NONBLOCK);
 779:main.c        ****       main_data.term_status |= term_string(task_aktiv, ASYNCSYNC_NONBLOCK);
 3126              		.loc 1 779 32
 3127 0368 0010A0E3 		mov	r1, #0
 3128 036c 10001BE5 		ldr	r0, [fp, #-16]
 3129 0370 B4329FE5 		ldr	r3, .L180+52
 3130 0374 0FE0A0E1 		mov	lr, pc
 3131 0378 13FF2FE1 		bx	r3
 3132              	.LVL51:
 3133 037c 0030A0E1 		mov	r3, r0
 3134              		.loc 1 779 16 discriminator 1
 3135 0380 1C239FE5 		ldr	r2, .L180+172
 3136 0384 D020D2E1 		ldrsb	r2, [r2]
 3137              		.loc 1 779 29 discriminator 1
 3138 0388 033CA0E1 		lsl	r3, r3, #24
 3139 038c 433CA0E1 		asr	r3, r3, #24
 3140 0390 033082E1 		orr	r3, r2, r3
 3141 0394 033CA0E1 		lsl	r3, r3, #24
 3142 0398 432CA0E1 		asr	r2, r3, #24
 3143 039c 00339FE5 		ldr	r3, .L180+172
 3144 03a0 0020C3E5 		strb	r2, [r3]
 780:main.c        ****       main_data.term_status |= term_string(
 3145              		.loc 1 780 32
 3146 03a4 0010A0E3 		mov	r1, #0
 3147 03a8 F8029FE5 		ldr	r0, .L180+176
 3148 03ac 78329FE5 		ldr	r3, .L180+52
 3149 03b0 0FE0A0E1 		mov	lr, pc
 3150 03b4 13FF2FE1 		bx	r3
 3151              	.LVL52:
 3152 03b8 0030A0E1 		mov	r3, r0
 3153              		.loc 1 780 16 discriminator 1
 3154 03bc E0229FE5 		ldr	r2, .L180+172
 3155 03c0 D020D2E1 		ldrsb	r2, [r2]
 3156              		.loc 1 780 29 discriminator 1
 3157 03c4 033CA0E1 		lsl	r3, r3, #24
 3158 03c8 433CA0E1 		asr	r3, r3, #24
 3159 03cc 033082E1 		orr	r3, r2, r3
 3160 03d0 033CA0E1 		lsl	r3, r3, #24
 3161 03d4 432CA0E1 		asr	r2, r3, #24
 3162 03d8 C4329FE5 		ldr	r3, .L180+172
 3163 03dc 0020C3E5 		strb	r2, [r3]
 3164              	.L166:
 781:main.c        ****           "' verletzt\n\r" VT100_VORDERGRUND_DEFAULT, ASYNCSYNC_NONBLOCK);
 782:main.c        ****     }
 783:main.c        ****     // Zeitscheibe erhöhen
 784:main.c        ****     zeitscheibe++;
 3165              		.loc 1 784 16
 3166 03e0 0C301BE5 		ldr	r3, [fp, #-12]
 3167 03e4 013083E2 		add	r3, r3, #1
 3168 03e8 0C300BE5 		str	r3, [fp, #-12]
 3169              	.LBB10:
 3170              	.LBB11:
 123:lib/../main.h **** 
 124:lib/../main.h **** static __inline__ int32_t stack_check(void) __attribute__((always_inline));
 125:lib/../main.h **** static __inline__ int32_t stack_check(void)
 126:lib/../main.h **** {
 127:lib/../main.h **** 	         uint32_t *ptr;
 128:lib/../main.h **** //	register uint32_t *sp asm("r13");
 129:lib/../main.h **** 	for(ptr=&__stack_start__[0];*ptr==STACK_FILL;++ptr);
 3171              		.loc 4 129 9
 3172 03ec 54329FE5 		ldr	r3, .L180+80
 3173 03f0 18300BE5 		str	r3, [fp, #-24]
 3174              		.loc 4 129 2
 3175 03f4 020000EA 		b	.L167
 3176              	.L168:
 3177              		.loc 4 129 47 discriminator 3
 3178 03f8 18301BE5 		ldr	r3, [fp, #-24]
 3179 03fc 043083E2 		add	r3, r3, #4
 3180 0400 18300BE5 		str	r3, [fp, #-24]
 3181              	.L167:
 3182              		.loc 4 129 30 discriminator 1
 3183 0404 18301BE5 		ldr	r3, [fp, #-24]
 3184 0408 003093E5 		ldr	r3, [r3]
 3185              		.loc 4 129 34 discriminator 1
 3186 040c 38229FE5 		ldr	r2, .L180+84
 3187 0410 020053E1 		cmp	r3, r2
 3188 0414 F7FFFF0A 		beq	.L168
 130:lib/../main.h **** 	return (int32_t)(ptr-&__stack_start__[0]);
 3189              		.loc 4 130 22
 3190 0418 18301BE5 		ldr	r3, [fp, #-24]
 3191 041c 24229FE5 		ldr	r2, .L180+80
 3192 0420 023043E0 		sub	r3, r3, r2
 3193              		.loc 4 130 9
 3194 0424 4331A0E1 		asr	r3, r3, #2
 3195              	.LBE11:
 3196              	.LBE10:
 785:main.c        **** 
 786:main.c        ****     // Stack Testen
 787:main.c        ****     if (stack_check() < (1 * 4)) {
 3197              		.loc 1 787 8 discriminator 1
 3198 0428 030053E3 		cmp	r3, #3
 3199 042c 350000CA 		bgt	.L170
 3200              	.LBB12:
 788:main.c        ****       static uint8_t stack_cnt = 0;
 789:main.c        ****       if (stack_cnt == 0) {
 3201              		.loc 1 789 21
 3202 0430 74329FE5 		ldr	r3, .L180+180
 3203 0434 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 3204              		.loc 1 789 10
 3205 0438 000053E3 		cmp	r3, #0
 3206 043c 3100001A 		bne	.L170
 790:main.c        ****         stack_cnt = 1;
 3207              		.loc 1 790 19
 3208 0440 64329FE5 		ldr	r3, .L180+180
 3209 0444 0120A0E3 		mov	r2, #1
 3210 0448 0020C3E5 		strb	r2, [r3]
 791:main.c        ****         main_data.term_status |= term_string(
 3211              		.loc 1 791 34
 3212 044c 0010A0E3 		mov	r1, #0
 3213 0450 58029FE5 		ldr	r0, .L180+184
 3214 0454 D0319FE5 		ldr	r3, .L180+52
 3215 0458 0FE0A0E1 		mov	lr, pc
 3216 045c 13FF2FE1 		bx	r3
 3217              	.LVL53:
 3218 0460 0030A0E1 		mov	r3, r0
 3219              		.loc 1 791 18 discriminator 1
 3220 0464 38229FE5 		ldr	r2, .L180+172
 3221 0468 D020D2E1 		ldrsb	r2, [r2]
 3222              		.loc 1 791 31 discriminator 1
 3223 046c 033CA0E1 		lsl	r3, r3, #24
 3224 0470 433CA0E1 		asr	r3, r3, #24
 3225 0474 033082E1 		orr	r3, r2, r3
 3226 0478 033CA0E1 		lsl	r3, r3, #24
 3227 047c 432CA0E1 		asr	r2, r3, #24
 3228 0480 1C329FE5 		ldr	r3, .L180+172
 3229 0484 0020C3E5 		strb	r2, [r3]
 792:main.c        ****             VT100_VORDERGRUND_ROT "Stack overflow durch '", ASYNCSYNC_NONBLOCK);
 793:main.c        ****         main_data.term_status |= term_string(task_aktiv, ASYNCSYNC_NONBLOCK);
 3230              		.loc 1 793 34
 3231 0488 0010A0E3 		mov	r1, #0
 3232 048c 10001BE5 		ldr	r0, [fp, #-16]
 3233 0490 94319FE5 		ldr	r3, .L180+52
 3234 0494 0FE0A0E1 		mov	lr, pc
 3235 0498 13FF2FE1 		bx	r3
 3236              	.LVL54:
 3237 049c 0030A0E1 		mov	r3, r0
 3238              		.loc 1 793 18 discriminator 1
 3239 04a0 FC219FE5 		ldr	r2, .L180+172
 3240 04a4 D020D2E1 		ldrsb	r2, [r2]
 3241              		.loc 1 793 31 discriminator 1
 3242 04a8 033CA0E1 		lsl	r3, r3, #24
 3243 04ac 433CA0E1 		asr	r3, r3, #24
 3244 04b0 033082E1 		orr	r3, r2, r3
 3245 04b4 033CA0E1 		lsl	r3, r3, #24
 3246 04b8 432CA0E1 		asr	r2, r3, #24
 3247 04bc E0319FE5 		ldr	r3, .L180+172
 3248 04c0 0020C3E5 		strb	r2, [r3]
 794:main.c        ****         main_data.term_status |=
 795:main.c        ****             term_string("'\n\r" VT100_VORDERGRUND_DEFAULT, ASYNCSYNC_NONBLOCK);
 3249              		.loc 1 795 13
 3250 04c4 0010A0E3 		mov	r1, #0
 3251 04c8 E4019FE5 		ldr	r0, .L180+188
 3252 04cc 58319FE5 		ldr	r3, .L180+52
 3253 04d0 0FE0A0E1 		mov	lr, pc
 3254 04d4 13FF2FE1 		bx	r3
 3255              	.LVL55:
 3256 04d8 0030A0E1 		mov	r3, r0
 794:main.c        ****         main_data.term_status |=
 3257              		.loc 1 794 18
 3258 04dc C0219FE5 		ldr	r2, .L180+172
 3259 04e0 D020D2E1 		ldrsb	r2, [r2]
 794:main.c        ****         main_data.term_status |=
 3260              		.loc 1 794 31
 3261 04e4 033CA0E1 		lsl	r3, r3, #24
 3262 04e8 433CA0E1 		asr	r3, r3, #24
 3263 04ec 033082E1 		orr	r3, r2, r3
 3264 04f0 033CA0E1 		lsl	r3, r3, #24
 3265 04f4 432CA0E1 		asr	r2, r3, #24
 3266 04f8 A4319FE5 		ldr	r3, .L180+172
 3267 04fc 0020C3E5 		strb	r2, [r3]
 3268              	.L171:
 796:main.c        ****         while (1)
 3269              		.loc 1 796 15
 3270 0500 0000A0E1 		nop
 3271 0504 FDFFFFEA 		b	.L171
 3272              	.L170:
 3273              	.LBE12:
 797:main.c        ****           ;
 798:main.c        ****       }
 799:main.c        ****     }
 800:main.c        **** 
 801:main.c        ****     // Batteriespannung überprüfen
 802:main.c        ****     // Ggf. schlägt die Unterspannungsprüfung im Akku zuvor ein!
 803:main.c        ****     if (nxt_avr_get_battery_raw() < ((2 * 3000 /*mV*/) << 10) / 14180) {
 3274              		.loc 1 803 9
 3275 0508 A8319FE5 		ldr	r3, .L180+192
 3276 050c 0FE0A0E1 		mov	lr, pc
 3277 0510 13FF2FE1 		bx	r3
 3278              	.LVL56:
 3279 0514 0030A0E1 		mov	r3, r0
 3280              		.loc 1 803 8 discriminator 1
 3281 0518 1B0E53E3 		cmp	r3, #432
 3282 051c 1D00008A 		bhi	.L172
 804:main.c        ****       if (main_data.lowbat_cnt++ > 100)
 3283              		.loc 1 804 20
 3284 0520 7C319FE5 		ldr	r3, .L180+172
 3285 0524 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3286              		.loc 1 804 31
 3287 0528 012083E2 		add	r2, r3, #1
 3288 052c FF1002E2 		and	r1, r2, #255
 3289 0530 6C219FE5 		ldr	r2, .L180+172
 3290 0534 0210C2E5 		strb	r1, [r2, #2]
 3291              		.loc 1 804 10
 3292 0538 640053E3 		cmp	r3, #100
 3293 053c 0100009A 		bls	.L173
 3294              	.L174:
 805:main.c        ****         while (1)
 3295              		.loc 1 805 15
 3296 0540 0000A0E1 		nop
 3297 0544 FDFFFFEA 		b	.L174
 3298              	.L173:
 806:main.c        ****           ;
 807:main.c        ****       else if (main_data.lowbat_cnt == 10)
 3299              		.loc 1 807 25
 3300 0548 54319FE5 		ldr	r3, .L180+172
 3301 054c 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3302              		.loc 1 807 15
 3303 0550 0A0053E3 		cmp	r3, #10
 3304 0554 1200001A 		bne	.L175
 808:main.c        ****         main_data.term_status |=
 809:main.c        ****             term_string(VT100_VORDERGRUND_ROT
 3305              		.loc 1 809 13
 3306 0558 0010A0E3 		mov	r1, #0
 3307 055c 58019FE5 		ldr	r0, .L180+196
 3308 0560 C4309FE5 		ldr	r3, .L180+52
 3309 0564 0FE0A0E1 		mov	lr, pc
 3310 0568 13FF2FE1 		bx	r3
 3311              	.LVL57:
 3312 056c 0030A0E1 		mov	r3, r0
 808:main.c        ****         main_data.term_status |=
 3313              		.loc 1 808 18
 3314 0570 2C219FE5 		ldr	r2, .L180+172
 3315 0574 D020D2E1 		ldrsb	r2, [r2]
 808:main.c        ****         main_data.term_status |=
 3316              		.loc 1 808 31
 3317 0578 033CA0E1 		lsl	r3, r3, #24
 3318 057c 433CA0E1 		asr	r3, r3, #24
 3319 0580 033082E1 		orr	r3, r2, r3
 3320 0584 033CA0E1 		lsl	r3, r3, #24
 3321 0588 432CA0E1 		asr	r2, r3, #24
 3322 058c 10319FE5 		ldr	r3, .L180+172
 3323 0590 0020C3E5 		strb	r2, [r3]
 3324 0594 020000EA 		b	.L175
 3325              	.L172:
 810:main.c        ****                         "\n\rLow Battery\n\r" VT100_VORDERGRUND_DEFAULT,
 811:main.c        ****                         ASYNCSYNC_NONBLOCK);
 812:main.c        ****     } else {
 813:main.c        ****       main_data.lowbat_cnt = 0;
 3326              		.loc 1 813 28
 3327 0598 04319FE5 		ldr	r3, .L180+172
 3328 059c 0020A0E3 		mov	r2, #0
 3329 05a0 0220C3E5 		strb	r2, [r3, #2]
 3330              	.L175:
 814:main.c        ****     }
 815:main.c        **** 
 816:main.c        ****     // Termstatus ueberpruefen
 817:main.c        ****     if (main_data.term_cnt == 0 && main_data.term_status != 0) {
 3331              		.loc 1 817 18
 3332 05a4 F8309FE5 		ldr	r3, .L180+172
 3333 05a8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3334              		.loc 1 817 8
 3335 05ac 000053E3 		cmp	r3, #0
 3336 05b0 EDFEFF1A 		bne	.L179
 3337              		.loc 1 817 45 discriminator 1
 3338 05b4 E8309FE5 		ldr	r3, .L180+172
 3339 05b8 D030D3E1 		ldrsb	r3, [r3]
 3340              		.loc 1 817 33 discriminator 1
 3341 05bc 000053E3 		cmp	r3, #0
 3342 05c0 E9FEFF0A 		beq	.L179
 818:main.c        ****       main_data.term_cnt++;
 3343              		.loc 1 818 16
 3344 05c4 D8309FE5 		ldr	r3, .L180+172
 3345 05c8 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3346              		.loc 1 818 25
 3347 05cc 013083E2 		add	r3, r3, #1
 3348 05d0 FF2003E2 		and	r2, r3, #255
 3349 05d4 C8309FE5 		ldr	r3, .L180+172
 3350 05d8 0120C3E5 		strb	r2, [r3, #1]
 3351              	.L177:
 819:main.c        ****     overflow:
 820:main.c        ****       __attribute__((unused));
 821:main.c        **** 
 822:main.c        ****       (void)term_string(VT100_VORDERGRUND_ROT
 3352              		.loc 1 822 13
 3353 05dc 0110A0E3 		mov	r1, #1
 3354 05e0 D8009FE5 		ldr	r0, .L180+200
 3355 05e4 40309FE5 		ldr	r3, .L180+52
 3356 05e8 0FE0A0E1 		mov	lr, pc
 3357 05ec 13FF2FE1 		bx	r3
 3358              	.LVL58:
 3359              	.L178:
 823:main.c        ****                         "\n\rTerminal Overflow\n\r" VT100_VORDERGRUND_DEFAULT,
 824:main.c        ****                         ASYNCSYNC_BLOCK);
 825:main.c        ****       while (1)
 3360              		.loc 1 825 13
 3361 05f0 0000A0E1 		nop
 3362 05f4 FDFFFFEA 		b	.L178
 3363              	.L181:
 3364              		.align	2
 3365              	.L180:
 3366 05f8 00000000 		.word	aic_init
 3367 05fc 00000000 		.word	systick_init
 3368 0600 00000000 		.word	interrupts_enable
 3369 0604 00000000 		.word	nxt_avr_init
 3370 0608 00000000 		.word	udmon3_init
 3371 060c 00000000 		.word	term_init
 3372 0610 00000000 		.word	display_init
 3373 0614 00000000 		.word	ui_init
 3374 0618 00000000 		.word	schrittmotor_data
 3375 061c 00000000 		.word	schrittmotor_init
 3376 0620 00000000 		.word	display_clear
 3377 0624 00000000 		.word	display_update
 3378 0628 9C000000 		.word	.LC9
 3379 062c 00000000 		.word	term_string
 3380 0630 A4000000 		.word	.LC10
 3381 0634 B0000000 		.word	.LC11
 3382 0638 E0000000 		.word	.LC12
 3383 063c 1C010000 		.word	.LC13
 3384 0640 40FDFFFF 		.word	-704
 3385 0644 FF8F0030 		.word	805343231
 3386 0648 00000000 		.word	__stack_start__
 3387 064c 11111111 		.word	286331153
 3388 0650 00000000 		.word	systick_get_ms
 3389 0654 2C010000 		.word	.LC14
 3390 0658 30010000 		.word	.LC15
 3391 065c 00000000 		.word	task_4ms
 3392 0660 34010000 		.word	.LC16
 3393 0664 00000000 		.word	task_8ms
 3394 0668 38010000 		.word	.LC17
 3395 066c 00000000 		.word	task_16ms
 3396 0670 40010000 		.word	.LC18
 3397 0674 00000000 		.word	task_32ms
 3398 0678 48010000 		.word	.LC19
 3399 067c 00000000 		.word	task_64ms
 3400 0680 50010000 		.word	.LC20
 3401 0684 00000000 		.word	task_128ms
 3402 0688 58010000 		.word	.LC21
 3403 068c 00000000 		.word	task_256ms
 3404 0690 60010000 		.word	.LC22
 3405 0694 00000000 		.word	task_512ms
 3406 0698 68010000 		.word	.LC23
 3407 069c 00000000 		.word	task_idle
 3408 06a0 70010000 		.word	.LC24
 3409 06a4 00000000 		.word	main_data
 3410 06a8 84010000 		.word	.LC25
 3411 06ac 36030000 		.word	stack_cnt.0
 3412 06b0 98010000 		.word	.LC26
 3413 06b4 B4010000 		.word	.LC27
 3414 06b8 00000000 		.word	nxt_avr_get_battery_raw
 3415 06bc C0010000 		.word	.LC28
 3416 06c0 DC010000 		.word	.LC29
 3417              		.cfi_endproc
 3418              	.LFE33:
 3420              		.bss
 3421              		.align	2
 3422              	trace_index.3:
 3423 0324 00000000 		.space	4
 3425              		.align	2
 3426              	count.2:
 3427 0328 00000000 		.space	4
 3429              		.align	2
 3430              	linebuf.1:
 3431 032c 00000000 		.space	10
 3431      00000000 
 3431      0000
 3433              	stack_cnt.0:
 3434 0336 00       		.space	1
 3436              		.text
 3437              	.Letext0:
 3438              		.file 5 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/lib/gcc/arm-none-eabi/14.3.
 3439              		.file 6 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/machi
 3440              		.file 7 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/_
 3441              		.file 8 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/r
 3442              		.file 9 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/l
 3443              		.file 10 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/
 3444              		.file 11 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/stdi
 3445              		.file 12 "AT91SAM7S64.h"
 3446              		.file 13 "lib/nxt_avr.h"
 3447              		.file 14 "lib/systick.h"
 3448              		.file 15 "lib/display.h"
 3449              		.file 16 "lib/term.h"
 3450              		.file 17 "trace32/udmon3.h"
 3451              		.file 18 "lib/isr.h"
 3452              		.file 19 "lib/aic.h"
 3453              		.file 20 "/usr/lib/gcc/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi/arm-none-eabi/include/sys/
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cc7cGNzX.s:19     .text.byte_fifo_put_possible:00000000 $a
     /tmp/cc7cGNzX.s:23     .text.byte_fifo_put_possible:00000000 byte_fifo_put_possible
     /tmp/cc7cGNzX.s:75     .text.byte_fifo_remain:00000000 $a
     /tmp/cc7cGNzX.s:79     .text.byte_fifo_remain:00000000 byte_fifo_remain
     /tmp/cc7cGNzX.s:133    .text.byte_fifo_used:00000000 $a
     /tmp/cc7cGNzX.s:137    .text.byte_fifo_used:00000000 byte_fifo_used
     /tmp/cc7cGNzX.s:188    .text.byte_fifo_put:00000000 $a
     /tmp/cc7cGNzX.s:192    .text.byte_fifo_put:00000000 byte_fifo_put
     /tmp/cc7cGNzX.s:277    .text.byte_fifo_get_possible:00000000 $a
     /tmp/cc7cGNzX.s:281    .text.byte_fifo_get_possible:00000000 byte_fifo_get_possible
     /tmp/cc7cGNzX.s:325    .text.byte_fifo_get:00000000 $a
     /tmp/cc7cGNzX.s:329    .text.byte_fifo_get:00000000 byte_fifo_get
     /tmp/cc7cGNzX.s:408    .text.byte_fifo_cb_put_possible:00000000 $a
     /tmp/cc7cGNzX.s:412    .text.byte_fifo_cb_put_possible:00000000 byte_fifo_cb_put_possible
     /tmp/cc7cGNzX.s:450    .text.byte_fifo_cb_put_possible:0000003c $d
     /tmp/cc7cGNzX.s:455    .text.byte_fifo_cb_put:00000000 $a
     /tmp/cc7cGNzX.s:459    .text.byte_fifo_cb_put:00000000 byte_fifo_cb_put
     /tmp/cc7cGNzX.s:520    .text.byte_fifo_cb_put:0000007c $d
     /tmp/cc7cGNzX.s:525    .text.byte_fifo_cb_get_possible:00000000 $a
     /tmp/cc7cGNzX.s:529    .text.byte_fifo_cb_get_possible:00000000 byte_fifo_cb_get_possible
     /tmp/cc7cGNzX.s:566    .text.byte_fifo_cb_get_possible:0000003c $d
     /tmp/cc7cGNzX.s:571    .text.byte_fifo_cb_get:00000000 $a
     /tmp/cc7cGNzX.s:575    .text.byte_fifo_cb_get:00000000 byte_fifo_cb_get
     /tmp/cc7cGNzX.s:614    .text.byte_fifo_cb_get:00000044 $d
     /tmp/cc7cGNzX.s:623    .bss:00000000 main_data
     /tmp/cc7cGNzX.s:620    .bss:00000000 $d
     /tmp/cc7cGNzX.s:626    .text._exit:00000000 $a
     /tmp/cc7cGNzX.s:631    .text._exit:00000000 _exit
     /tmp/cc7cGNzX.s:658    .bss:00000004 trace_buf0
     /tmp/cc7cGNzX.s:664    .bss:00000194 trace_buf1
     /tmp/cc7cGNzX.s:667    .text.trace_scope:00000000 $a
     /tmp/cc7cGNzX.s:672    .text.trace_scope:00000000 trace_scope
     /tmp/cc7cGNzX.s:760    .text.trace_scope:000000c8 $d
     /tmp/cc7cGNzX.s:3422   .bss:00000324 trace_index.3
     /tmp/cc7cGNzX.s:771    .data:00000000 pio
     /tmp/cc7cGNzX.s:768    .data:00000000 $d
     /tmp/cc7cGNzX.s:777    .data:00000004 pmc
     /tmp/cc7cGNzX.s:783    .data:00000008 pwm_ctl
     /tmp/cc7cGNzX.s:789    .data:0000000c pwm_pa23
     /tmp/cc7cGNzX.s:795    .data:00000010 pwm_pa2
     /tmp/cc7cGNzX.s:815    .data:00000014 schritt_mode2str
     /tmp/cc7cGNzX.s:799    .rodata:00000000 $d
     /tmp/cc7cGNzX.s:824    .data:00000028 schrittmotor_data
     /tmp/cc7cGNzX.s:877    .text.schrittmotor_init:00000000 $a
     /tmp/cc7cGNzX.s:882    .text.schrittmotor_init:00000000 schrittmotor_init
     /tmp/cc7cGNzX.s:1054   .text.schrittmotor_init:000001a0 $d
     /tmp/cc7cGNzX.s:1070   .text.schrittmotor_update:00000000 $a
     /tmp/cc7cGNzX.s:1075   .text.schrittmotor_update:00000000 schrittmotor_update
     /tmp/cc7cGNzX.s:1232   .text.schrittmotor_update:00000168 $d
     /tmp/cc7cGNzX.s:1238   .text.schrittmotor_process:00000000 $a
     /tmp/cc7cGNzX.s:1243   .text.schrittmotor_process:00000000 schrittmotor_process
     /tmp/cc7cGNzX.s:1752   .text.schrittmotor_process:00000440 $d
     /tmp/cc7cGNzX.s:1771   .text.ui_init:00000000 $a
     /tmp/cc7cGNzX.s:1776   .text.ui_init:00000000 ui_init
     /tmp/cc7cGNzX.s:1802   .text.ui_process:00000000 $a
     /tmp/cc7cGNzX.s:1807   .text.ui_process:00000000 ui_process
     /tmp/cc7cGNzX.s:2230   .text.ui_process:00000474 $d
     /tmp/cc7cGNzX.s:3426   .bss:00000328 count.2
     /tmp/cc7cGNzX.s:2243   .text.task_4ms:00000000 $a
     /tmp/cc7cGNzX.s:2248   .text.task_4ms:00000000 task_4ms
     /tmp/cc7cGNzX.s:2349   .text.task_4ms:000000ec $d
     /tmp/cc7cGNzX.s:2355   .text.task_8ms:00000000 $a
     /tmp/cc7cGNzX.s:2360   .text.task_8ms:00000000 task_8ms
     /tmp/cc7cGNzX.s:2386   .text.task_16ms:00000000 $a
     /tmp/cc7cGNzX.s:2391   .text.task_16ms:00000000 task_16ms
     /tmp/cc7cGNzX.s:2417   .text.task_32ms:00000000 $a
     /tmp/cc7cGNzX.s:2422   .text.task_32ms:00000000 task_32ms
     /tmp/cc7cGNzX.s:2448   .text.task_64ms:00000000 $a
     /tmp/cc7cGNzX.s:2453   .text.task_64ms:00000000 task_64ms
     /tmp/cc7cGNzX.s:2484   .text.task_64ms:00000024 $d
     /tmp/cc7cGNzX.s:2489   .text.task_128ms:00000000 $a
     /tmp/cc7cGNzX.s:2494   .text.task_128ms:00000000 task_128ms
     /tmp/cc7cGNzX.s:2520   .text.task_256ms:00000000 $a
     /tmp/cc7cGNzX.s:2525   .text.task_256ms:00000000 task_256ms
     /tmp/cc7cGNzX.s:2551   .text.task_512ms:00000000 $a
     /tmp/cc7cGNzX.s:2556   .text.task_512ms:00000000 task_512ms
     /tmp/cc7cGNzX.s:2582   .text.task_1024ms:00000000 $a
     /tmp/cc7cGNzX.s:2587   .text.task_1024ms:00000000 task_1024ms
     /tmp/cc7cGNzX.s:2613   .text.task_idle:00000000 $a
     /tmp/cc7cGNzX.s:2618   .text.task_idle:00000000 task_idle
     /tmp/cc7cGNzX.s:2644   .text.premain_init:00000000 $a
     /tmp/cc7cGNzX.s:2649   .text.premain_init:00000000 premain_init
     /tmp/cc7cGNzX.s:2691   .text.premain_init:0000003c $d
     /tmp/cc7cGNzX.s:3430   .bss:0000032c linebuf.1
     /tmp/cc7cGNzX.s:2698   .init_array:00000000 $d
     /tmp/cc7cGNzX.s:2767   .text.main:00000000 $a
     /tmp/cc7cGNzX.s:2772   .text.main:00000000 main
     /tmp/cc7cGNzX.s:3366   .text.main:000005f8 $d
     /tmp/cc7cGNzX.s:3433   .bss:00000336 stack_cnt.0

UNDEFINED SYMBOLS
nxt_avr_get_buttons
display_goto_xy
display_unsigned
display_string
display_update
_impure_ptr
setvbuf
aic_init
systick_init
interrupts_enable
nxt_avr_init
udmon3_init
term_init
display_init
display_clear
term_string
__stack_start__
systick_get_ms
nxt_avr_get_battery_raw
